#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! File Name:   D2PSTGRE.tpw
#! Purpose:     DCT to POSTGRESQL creation script
#! Author:      Copyright © 1999-2999 by Roberto Artigas Jr
#!              All rights reserved world wide.
#! Changes:
#! 2008.09.18   Roberto Artigas
#!  *   Specific table SQL permisions options added to the grant section. Michael Gould request.
#!      This meant some restructuring of the template and cleanup of the code.
#!  *   Added CHECK options to generate grant for ALL tables and for SPECIFIC tables.
#!      This was done for consistency and to deal with the fact that there is a default for ALL the tables
#!      that can not be deleted because of the logic (you can try to delete it, but it will not work).
#! 2008.08.18   Michael Gould
#!  *   Added support for UUID data types - This support requires that contrib module uuid-ossp be installed
#!      You can get more information in Appendix F of the PostGres manual.  This implementation supports 3
#!      different algorithms to set this up.  In this implementation, you should make the UUID column UUID1,
#!      UUID2,UUID3 and this will generate the proper default statement.
#! 2008.08.13   Roberto Artigas
#!  *   Added 'Comments' options to the 'Options' tab.
#!  *   Made 'COMMENT ON' generation to the backend database an option.
#!  *   Added 'COMMENT ON' relationship constraints generation and option.
#!  *   Added SQL table level options to all scripts and made optional.
#! 2008.08.12   Roberto Artigas
#!  *   Changed DELATE to DELETE (cascade changes).
#!  *   QUOTE'd all comments to allow for apostrophes.
#!  *   Combined 'External' and 'Arrays' tabs.
#!  *   Combined 'Varchar' and 'Picture' tabs.
#! 2008.08.11   Roberto Artigas
#!  *   Refactored the prefix section in the "Options" tab to be more
#!      usefull and generic for those with messed up dictionaries.
#!      You might not have created the dictionary to begin with,
#!      but you got to fix it and make it run.
#!      Added options to either generate all of the prefixes for all
#!      the components or just the components that you need.
#! 2008.08.10   Roberto Artigas
#!  *   Re-arranged "Options" tab. Need to ponder prefixing individual
#!      components and changing the generated SQL code.
#!  *   Cleaned up small generated SQL spacing problems
#! 2008.08.06   Roberto Artigas
#!  *   Change BLOB generation to BYTEA on the PostgreSQL backend.
#!  *   Change MEMO generation to TEXT on the PostgreSQL backend.
#! 2008.07.19   Roberto Artigas
#!  *   Added generate VIEWS option to the template.
#! 2008.07.18   Michael Gould (Robert Artigas installed here)
#!  *   Added the ON DELETE / ON UPDATE processing for building relations
#!  *   Added the ability to Defer the constraint check until the transaction ends
#! 2008.07.01   Roberto Artigas
#!  *   Option added for making INT's that are a key into BIGINT's.
#! 2008.06.30   Roberto Artigas
#!  *   Created trigger implementation at the field option level with:
#!      RASQLBEFOREINSERT, RASQLBEFOREUPDATE, RASQLBEFOREDELETE,
#!      RASQLAFTERINSERT,  RASQLAFTERUPDATE,  RASQLAFTERDELETE
#! 2008.06.29   Roberto Artigas
#!  *   Enhanced the GRANT options. Added GRANT ALL checkbox option.
#! 2008.06.24   Roberto Artigas
#!  *   Additional search path SQL statements when using a schema name.
#!  *   Implemented CHECK based on dictionary validations. INFILE not done at this time.
#!  *   Change order (where processed) the RASQLCHECK option. Now overides dictionary.
#! 2008.06.20   Roverto Artigas
#!  *   Fixed RASQLCHECK option to handle IN ('','','','').
#! 2008.03.22   Roberto Artigas
#!  *   Corrected small template error in the unique index lowercase logic.
#!  *   Disabled posible errors in the automatic generation of serial fields.
#! 2008.03.14   Roberto Artigas
#!  *   Added function creation for descriptions.
#!  *   Added RASQLCHECK option to template at the field level
#! 2008.02.23   Michael Gould
#!  *   Added ability to create elements in lower case
#! 2007.12.28   Roberto Artigas
#!  *   Added 'COMMENT ON' to field.
#! 2007.12.27   Roberto Artigas
#!  *   Added 'COMMENT ON' to table, sequence, primary key, and index.
#! 2007.12.26   Roberto Artigas
#!  *   Correct index names to obey the IGNORE reserved words option.
#! 2007.12.05   Dave Harms
#!  *   Added file prefix to index names
#! 2007.11.25   Roberto Artigas
#!  *   Logic changes to make sure the scripts are generated in file name sequence
#!  *   Slight logic changes in the CASE statement for INLIST validation.
#! 2007.10.31   Roberto Artigas
#!  *   Added ignore NOT NULL for all fields to avoid Clarion pre-insert failures of the
#!      blank record on the SQL backend. The validation will be still generated in the program.
#! 2007.10.27   Roberto Artigas
#!  *   Added ignore NOT NULL for all keys lookup and set up.
#!  *   Added mechanism for the 'inteligent' field default of backend specific values
#!      by way of the third field option in RASQL having a 'YES' value or an actual value.
#! 2007.10.24   Roberto Artigas
#!  *   Made "Making Strings Into VarChar" an option. Default to NO.
#! 2007.10.21   Roberto Artigas
#!  *   Corrected relation to ALIAS by replacing the ALIAS'ed name with the real file name
#!      since ALIAS'es do not exit in the database backend. They are a clarion construction.
#! 2007.10.07   Roberto Artigas
#!  *   Finish up validations on the backend for BOOLEAN and INLIST.
#!  *   Added CHECK option and implemented.
#! 2007.10.03   Roberto Artigas
#!  *   Begin adding the validation functions for the backend.
#! 2007.09.28   Roberto Artigas
#!  *   Added logic and types for TIME WITHOUT TIME ZONE which Clarion implements.
#! 2007.09.20   Roberto Artigas
#!  *   Added logic for file option EMULATEAUTONUMKEY and field option ISIDENTITY.
#!  *   Added option for SERIAL or BIGSERIAL depending on dictionary option ISIDENTITY.
#! 2007.07.17   Roberto Artigas
#!  *   Added ignore reserved words option and schema name option.
#!  *   Added modify name #GROUPs to simplify and localize name manipulation logic
#! 2007.07.16   Roberto Artigas
#!  *   Added PosgreSQL data types to the template
#! 2007.05.08   Douglas E. Johnson <douglas.e.johnson@colorado.edu>
#!  *   Added External Names option to the template.
#! 2003.02.12   Gunnar Sønsteby <gunnar@nor-net.no>
#!  *   Added   TAB Picture.
#!              Choice for converting PICTURE-fields to char(n).
#! 2003.02.12   Gunnar Sønsteby <gunnar@nor-net.no>
#!  *   Added   TAB VarChar.
#!              Lets user choose how many characters before turning string to varchar(n).
#! 2003.02.10   Gunnar Sønsteby <gunnar@nor-net.no>
#!  *   Changed ALTER TABLE filename ADD CONSTRAINT keyname UNIQUE [KEY]|INDEX (field,...)
#!              to
#!              CREATE [UNIQUE] INDEX keyname ON filename (field,...)
#! 2003.01.18   Gunnar Sønsteby <gunnar@nor-net.no>
#!  *   Changed BYTE, UTINYINT, UINT1 from TINYINT to SMALLINT as TINYINT does not exist in Postgres.
#! 2002.05.03   Roberto Artigas Jr
#!  *   Created skeleton for the POSTGRESQL variant.
#!---------------------------------------------------------------------
#UTILITY(Dct2PostgreSQL, '2016.02.17: Dictionary to POSTGRESQL script')
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#BOXED('Hidden Variables'),HIDE
  #PROMPT('DictName: '    ,@S40 ),%DictName
  #PROMPT('DictPath: '    ,@S80 ),%DictPath
  #PROMPT('nLoc1: '       ,@N4  ),%nLoc1
  #PROMPT('nLoc2: '       ,@N4  ),%nLoc2
  #PROMPT('aFileUser: '   ,@s40 ),%aFileUser                    #! RA.2008.09.17
  #PROMPT('aFileOpt1: '   ,@s40 ),%aFileOpt1                    #! RA.2008.09.17
  #PROMPT('aFileOpt2: '   ,@s40 ),%aFileOpt2                    #! RA.2008.09.17
  #PROMPT('aFileOpt3: '   ,@s40 ),%aFileOpt3                    #! RA.2008.09.17
  #PROMPT('aFileOpt4: '   ,@s40 ),%aFileOpt4                    #! RA.2008.09.17
  #PROMPT('OutTableName: ',@S120),%OutTableName
  #PROMPT('OutGrantName: ',@S120),%OutGrantName
  #PROMPT('OutIndexName: ',@S120),%OutIndexName
  #PROMPT('OutRelatName: ',@S120),%OutRelatName
  #PROMPT('OutValidName: ',@S120),%OutValidName
  #PROMPT('OutTrigrName: ',@S120),%OutTrigrName
  #PROMPT('OutViewsName: ',@S120),%OutViewsName
#ENDBOXED
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#PREPARE
#!-----------------------------------------------------------------------------------!
#! RA.2008.09.17 - Created this in the front of template.                            !
#! This will create the correct tables list for the SPECIFIC table grant area.       !
#!-----------------------------------------------------------------------------------!
#DECLARE(%GrantFile),MULTI,UNIQUE                               #! RA.2008.09.17
#FOR(%File)                                                     #! RA.2008.09.17
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%aFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
      #CYCLE
  #ENDCASE
#!
  #ADD(%GrantFile,%File)                                        #! RA.2008.09.17
#ENDFOR                                                         #! RA.2008.09.17
#ENDPREPARE
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#BOXED('POSTGRESQL SCRIPT CREATOR')
  #DISPLAY('')
  #DISPLAY('The POSTGRESQL Script Creator.')
  #DISPLAY('Copyright 2002-2015 © by Roberto Artigas Jr.')
  #DISPLAY('All Rights Reserved World Wide.')
  #DISPLAY('')
#ENDBOXED
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#SHEET,HSCROLL,AT(,,288)                                        #! RA.2017.0906 - #SHEET,HSCROLL
 #TAB('General')
  #BOXED('')
   #DISPLAY('The POSTGRESQL Script Creator.')
   #DISPLAY('Copyright 2002-2009 © by Roberto Artigas Jr.')
   #DISPLAY('All Rights Reserved World Wide.')
   #DISPLAY('')
   #PROMPT('Directory:'  ,@S80 ),%SQLDirectory,AT(52,,130)
   #DISPLAY('')
   #PROMPT('Generate CREATE?'   ,CHECK),%SQLTable,DEFAULT(%TRUE),AT(10)
   #PROMPT('CREATE Script:'     ,@S40 ),%SQLTableName,AT(82,,100)
   #DISPLAY('')
   #PROMPT('Generate GRANT? '   ,CHECK),%SQLGrant,DEFAULT(%FALSE),AT(10)
   #PROMPT('GRANT Script:'      ,@S40 ),%SQLGrantName,AT(82,,100)
   #DISPLAY('')
   #PROMPT('Generate KEYS?'     ,CHECK),%SQLIndex,DEFAULT(%TRUE),AT(10)
   #PROMPT('KEYS Script:'       ,@S40 ),%SQLIndexName,AT(82,,100)
   #DISPLAY('')
   #PROMPT('Generate RELATION?' ,CHECK),%SQLRelat,DEFAULT(%FALSE),AT(10)
   #ENABLE(%SQLRelat)
     #PROMPT('Allow for Deferrable Constraints?',CHECK),%SQLRelatDefer,DEFAULT(%FALSE),AT(20)
   #ENDENABLE
   #PROMPT('RELATION Script:'   ,@S40 ),%SQLRelatName,AT(82,,100)
   #DISPLAY('')
   #PROMPT('Generate VALIDATE?' ,CHECK),%SQLValid,DEFAULT(%FALSE),AT(10)
   #ENABLE(%SQLValid)
     #PROMPT('Generate CHECK?' ,CHECK),%SQLValidCheck,DEFAULT(%FALSE),AT(20)
   #ENDENABLE
   #PROMPT('VALIDATE Script:'   ,@S40 ),%SQLValidName,AT(82,,100)
   #DISPLAY('')
   #PROMPT('Generate TRIGGER?' ,CHECK),%SQLTrigr,DEFAULT(%FALSE),AT(10)
   #ENABLE(%SQLTrigr)
     #PROMPT('Connect TRIGGER?' ,CHECK),%SQLTrigrConnect,DEFAULT(%FALSE),AT(20)
   #ENDENABLE
   #PROMPT('TRIGGER Script:'   ,@S40 ),%SQLTrigrName,AT(82,,100)
   #DISPLAY('')
   #PROMPT('Generate VIEWS?'   ,CHECK),%SQLViews,DEFAULT(%FALSE),AT(10)
   #PROMPT('VIEWS Script:'     ,@S40 ),%SQLViewsName,AT(82,,100)
  #ENDBOXED
 #ENDTAB
 #!-----------------------------------------------------------!
 #! RA.2008.06.29 - Added enxhancements to the GRANT options. !
 #!-----------------------------------------------------------!
 #TAB('Grant')
   #BOXED('')
    #PROMPT('Grant ALL priviledges ', CHECK), %optGrantAll, DEFAULT(0), AT(10)
    #ENABLE(%optGrantAll)
      #PROMPT('Grant ALL user name: ', @S40), %optGrantAllUser, DEFAULT('postgres')
    #ENDENABLE
    #DISPLAY('')
    #!#DISPLAY('Grants for ALL tables')
    #PROMPT('Generate grants for ALL tables ', CHECK), %optGrantDoit, DEFAULT(1), AT(10)
    #BUTTON('Tables: User or Groups'), MULTI(%optGrant, %optGrantType & '  ' & %optGrantName & '  ' & (%optGrantSelect + %optGrantInsert + %optGrantUpdate + %optGrantDelete)), INLINE, AT(,,,100)
      #PROMPT('Type of Grant: ',OPTION), %optGrantType, AT(,,100), DEFAULT('User'), REQ
      #PROMPT('&User', RADIO)
      #PROMPT('&Group', RADIO)
      #PROMPT('User or Group Name: ', @S40 ), %optGrantName, DEFAULT('public'), REQ
      #PROMPT('Select', CHECK), %optGrantSelect, DEFAULT(1)
      #PROMPT('Insert', CHECK), %optGrantInsert, DEFAULT(1)
      #PROMPT('Update', CHECK), %optGrantUpdate, DEFAULT(1)
      #PROMPT('Delete', CHECK), %optGrantDelete, DEFAULT(1)
    #ENDBUTTON
    #DISPLAY('')
    #!#DISPLAY('Grants for SPECIFIC tables')
    #PROMPT('Generate grants for SPECIFIC tables ', CHECK), %opt2GrantDoit, DEFAULT(0), AT(10)
    #BUTTON('Table: User or Groups'), MULTI(%opt2Grant, %opt2GrantTable & '  ' & %opt2GrantType & '  ' & %opt2GrantName & '  ' & (%opt2GrantSelect + %opt2GrantInsert + %opt2GrantUpdate + %opt2GrantDelete)), INLINE, AT(,,,100)
      #PROMPT('Table: ', FROM (%GrantFile)), %opt2GrantTable, AT(,,100), DEFAULT(''), REQ
      #PROMPT('Type of Grant: ',OPTION), %opt2GrantType, AT(,,100), DEFAULT('User'), REQ
      #PROMPT('&User', RADIO)
      #PROMPT('&Group', RADIO)
      #PROMPT('User or Group Name: ', @S40 ), %opt2GrantName, DEFAULT('public'), REQ
      #PROMPT('Select', CHECK), %opt2GrantSelect, DEFAULT(1)
      #PROMPT('Insert', CHECK), %opt2GrantInsert, DEFAULT(1)
      #PROMPT('Update', CHECK), %opt2GrantUpdate, DEFAULT(1)
      #PROMPT('Delete', CHECK), %opt2GrantDelete, DEFAULT(1)
    #ENDBUTTON
   #ENDBOXED
 #ENDTAB
 #PREPARE
 #IF(~ITEMS(%optGrant))
   #ADD(%optGrant,'User')
 #ENDIF
 #ENDPREPARE
 #!----------------------------------------------------------------------!
 #! RA.2007.07.17 - Added ignore reserved words and schema name options. !
 #!----------------------------------------------------------------------!
 #TAB('Options')
   #BOXED('General')
     #PROMPT('Ignore NOT NULL for all keys ',CHECK),%IgnoreNotNullKeys,AT(10),DEFAULT(%TRUE)
     #PROMPT('Ignore NOT NULL for all fields ',CHECK),%IgnoreNotNullFields,AT(10),DEFAULT(%TRUE)
     #DISPLAY('')
     #PROMPT('Use SEQUENCE for auto-increment ',CHECK),%UseSerial,AT(10),DEFAULT(%TRUE)
     #PROMPT('Key fields type INT to BIGINT ', CHECK),%MakeIntBigint,AT(10),DEFAULT(%True)              #! RA.2008.07.01
     #DISPLAY('')
     #PROMPT('Ignore reserved words ',CHECK),%IgnoreReserved,AT(10),DEFAULT(%TRUE)
     #DISPLAY('')
     #PROMPT('Create table and column names in lowercase',CHECK),%UseLowerCase,AT(10),Default(%True)    #! MAG 02.21.08
     #DISPLAY('')
#!     #PROMPT('Generate OWNER for tables ',CHECK),%UseOwner,AT(10),DEFAULT(0)
#!     #ENABLE(%UseOwner)
#!       #PROMPT('Owner Name:',@S40),%OwnerName,AT(82,,100),DEFAULT('postgres')
#!     #ENDENABLE
#!     #DISPLAY('')
     #PROMPT('Use schema name ',CHECK),%UseSchemaName,AT(10),DEFAULT(%FALSE)
     #ENABLE(%UseSchemaName)
       #PROMPT('Schema Name:',@S40),%SchemaName,AT(82,,100),DEFAULT('public')
     #ENDENABLE
   #ENDBOXED
   #BOXED('Prefixes')
     #PROMPT('Prefix Options ',OPTION),%UsePrefix,DEFAULT('None')
     #PROMPT('None',RADIO),AT(15)
     #PROMPT('All',RADIO),AT(15)
     #PROMPT('Some',RADIO),AT(15)
     #ENABLE(%UsePrefix='Some')
       #PROMPT('Use file prefix for table names ',CHECK),%PrefixTables,AT(10),DEFAULT(%False)
       #PROMPT('Use file prefix for column names ',CHECK),%PrefixColumns,AT(10),DEFAULT(%False)
       #PROMPT('Use file prefix for key names ',CHECK),%PrefixKeys,AT(10),DEFAULT(%False)
       #PROMPT('Use file prefix for relation names ',CHECK),%PrefixRelations,AT(10),DEFAULT(%False)
     #ENDENABLE
   #ENDBOXED
   #BOXED('Comments')
     #PROMPT('Generate database comments ',CHECK),%CommentsDB,AT(10),DEFAULT(%True)
     #PROMPT('Generate SQL script comments ',CHECK),%CommentsSQL,AT(10),DEFAULT(%True)
   #ENDBOXED
 #ENDTAB
#!$$------------------------------------------------!
#!$$ DEJ.2007.05.08 - Use External Field Name
#!$$------------------------------------------------!
 #TAB('External/Arrays')                                                                    #!$$
  #BOXED('External')                                                                        #!$$
   #DISPLAY('The default is to generate a create script that uses')                         #!$$
   #DISPLAY('any External Field Names defined in your dictionary.')                         #!$$
   #DISPLAY('In addition, Postgres will create the column names in')                        #!$$
   #DISPLAY('lowercase unless the name is generated within quotes.')                        #!$$
   #DISPLAY('')                                                                             #!$$
   #PROMPT('Generate External Name as Column',CHECK),%UseExtFieldName,AT(10),DEFAULT(0)     #!$$
   #ENABLE(%UseExtFieldName)                                                                #!$$
    #PROMPT('Generate Column in Quotes',CHECK),%UseExtFieldQuote,AT(25),DEFAULT(0)          #!$$
   #ENDENABLE                                                                               #!$$
  #ENDBOXED                                                                                 #!$$
  #BOXED('Arrays')
   #DISPLAY('There are two ways to handle arrays:')
   #DISPLAY('')
   #DISPLAY('1) You defined a group with all the fields of the array')
   #DISPLAY('inside this group. Then you put the array OVER the')
   #DISPLAY('group. If you set up your arrays in this manner, then')
   #DISPLAY('LEAVE the checkbox below OFF.')
   #DISPLAY('')
   #DISPLAY('2) You define your arrays as actual fields using no')
   #DISPLAY('groups whatsoever. If you set up your arrays this way,')
   #DISPLAY('then TURN ON the checkbox bellow.')
   #DISPLAY('')
   #PROMPT('I DO NOT HAVE ARRAYS OVER GROUPS. ',CHECK),%NoArrayOver,AT(10),DEFAULT(0)
  #ENDBOXED
 #ENDTAB                                                                                    #!$$
#!$$------------------------------------------------!
#!$$ End of Use External Name
#!$$------------------------------------------------!
#! #TAB('Arrays')
#!  #BOXED('')
#!   #DISPLAY('There are two ways to handle arrays:')
#!   #DISPLAY('')
#!   #DISPLAY('1) You defined a group with all the fields of the array')
#!   #DISPLAY('inside this group. Then you put the array OVER the')
#!   #DISPLAY('group. If you set up your arrays in this manner, then')
#!   #DISPLAY('LEAVE the checkbox below OFF.')
#!   #DISPLAY('')
#!   #DISPLAY('2) You define your arrays as actual fields using no')
#!   #DISPLAY('groups whatsoever. If you set up your arrays this way,')
#!   #DISPLAY('then TURN ON the checkbox bellow.')
#!   #DISPLAY('')
#!   #PROMPT('I DO NOT HAVE ARRAYS OVER GROUPS. ',CHECK),%NoArrayOver,AT(10),DEFAULT(0)
#!  #ENDBOXED
#! #ENDTAB
 #TAB('Varchar/Picture')
  #BOXED('Varchar')
   #DISPLAY('Postgres supports two primary character types.')
   #DISPLAY('  char(n)    - fixed length, blank padded')
   #DISPLAY('  varchar(n) - variable length with limit')
   #DISPLAY('')
   #DISPLAY('The storage requirement for varchar(n) is four bytes plus')
   #DISPLAY('actual string with a maximum limit of n characters.')
   #DISPLAY('So, if you excpect a string to be less than max')
   #DISPLAY('characters minus 4 bytes for more than half of the')
   #DISPLAY('records, you should probably turn it into a varchar.')
   #DISPLAY('To optimaly tune this, you have to edit the script')
   #DISPLAY('produced by the template on a field to field basis.')
   #DISPLAY('')
   #PROMPT('Varchar special processing ', CHECK), %VarCharSpecial, AT(10),DEFAULT(0)
   #DISPLAY('')
   #ENABLE(%VarCharSpecial)
     #PROMPT('Varchar for strings >= : ', @N4),%VarcharLen,AT(,,30,10),DEFAULT(256)
   #ENDENABLE
  #ENDBOXED
  #BOXED('Picture')
   #DISPLAY('You may convert PICTURE-fields to CHAR(n) by')
   #DISPLAY('checking this option.')
   #DISPLAY('')
   #DISPLAY('If not, the fields are showing up as ***PICTURE***')
   #DISPLAY('and you have to edit the generated script for this')
   #DISPLAY('fieldtype.')
   #DISPLAY('')
   #PROMPT('Make PICTURES as CHAR(n). ',CHECK),%PicAsChar,AT(10),DEFAULT(0)
  #ENDBOXED
 #ENDTAB
#! #TAB('Picture')
#!  #BOXED('')
#!   #DISPLAY('You may convert PICTURE-fields to CHAR(n) by')
#!   #DISPLAY('checking this option.')
#!   #DISPLAY('')
#!   #DISPLAY('If not, the fields are showing up as ***PICTURE***')
#!   #DISPLAY('and you have to edit the generated script for this')
#!   #DISPLAY('fieldtype.')
#!   #DISPLAY('')
#!   #PROMPT('Make PICTURES as CHAR(n). ',CHECK),%PicAsChar,AT(10),DEFAULT(0)
#!   #DISPLAY('')
#!  #ENDBOXED
#! #ENDTAB
 #TAB('UUID Processing')
   #BOXED('')
    #DISPLAY('PostGres 8.3.x now supports UUID/GUID data types.')
    #DISPLAY('')
    #DISPLAY('For this to work in these templates the contrib module')
    #DISPLAY('uuid-ossp must be installed in the database - PostGres ')
    #DISPLAY('manual - Appendix F')
    #DISPLAY('')
    #DISPLAY('You can also set up to call a default algorithm just like')
    #DISPLAY('an auto-incremented column.')
    #DISPLAY('')
    #DISPLAY('This is accomplished by using the field options in the')
    #DISPLAY('dictionary as follows:')
    #DISPLAY('')
    #DISPLAY('RASQL(,UUID) will generate the UUID with no default')
    #DISPLAY('UUID')
    #DISPLAY('')
    #DISPLAY('RASQL(,UUID1) will generate the statement')
    #DISPLAY('UUID DEFAULT uuid_generate_v1()')
    #DISPLAY('')
    #DISPLAY('RASQL(,UUID2) will generate the statement')
    #DISPLAY('UUID DEFAULT uuid_generate_v1mc()')
    #DISPLAY('')
    #DISPLAY('RASQL(,UUID3) will generate the statement')
    #DISPLAY('UUID DEFAULT uuid_generate_v4()')
    #DISPLAY('')
    #DISPLAY('On the Clarion dictionary side this needs to be defined')
    #DISPLAY('as a CSTRING(37).')
   #ENDBOXED
  #ENDTAB
#ENDSHEET
#BOXED('Hidden Variables'),HIDE
  #PROMPT('Force BOOLEAN validation to [Y,N] choices? ',CHECK),%ForceBoolYN,AT(10),DEFAULT(1)
  #PROMPT('Do KEYFIELD-FILE list to create relations? ',CHECK),%DoFieldFile,AT(10),DEFAULT(0)
  #PROMPT('True Value (Y,T,1): ',@S1),%TrueValue,REQ,DEFAULT('Y')
  #PROMPT('False Value (N,F,0): ',@S1),%FalseValue,REQ,DEFAULT('N')
#ENDBOXED
#!---------------------------------------------------------------------
#PREPARE
#!
#SET(%nLoc1,INSTRING('\',%DictionaryFile,1,1))
#LOOP,WHILE(%nLoc1)
  #SET(%nLoc2,%nLoc1)
  #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,%nLoc1+1))
#ENDLOOP
#SET(%DictName,UPPER(SUB(%DictionaryFile,%nLoc2+1,LEN(%DictionaryFile)-%nLoc2-4)))
#SET(%DictPath,UPPER(SUB(%DictionaryFile,1,%nLoc2)))
#!
#SET(%SQLDirectory,%DictPath)
#SET(%SQLTableName,%DictName & '_01_PG.SQL')
#SET(%SQLGrantName,%DictName & '_02_PG.SQL')
#SET(%SQLIndexName,%DictName & '_03_PG.SQL')
#SET(%SQLRelatName,%DictName & '_04_PG.SQL')
#SET(%SQLValidName,%DictName & '_05_PG.SQL')
#SET(%SQLTrigrName,%DictName & '_06_PG.SQL')
#SET(%SQLViewsName,%DictName & '_07_PG.SQL')
#!
#ENDPREPARE
#!---------------------------------------------------------------------
#! SQL specific options
#DECLARE(%NFileOpt0)                    #! File option 0  - EMULATEAUTONUMKEY(TRUE)
#DECLARE(%NFieldOpt0)                   #! Field option 0 - IsIdentity(TRUE)
#DECLARE(%NComment)                     #! Generate comments with QUOTE'd strings
#DECLARE(%WorkIt)                       #! Temporary variable
#!
#DECLARE(%NFileUser)                    #! File user options [RASQL]
#DECLARE(%NFileOpt1)                    #! File option 1 [NO]
#DECLARE(%NFileOpt2)                    #! File option 2
#DECLARE(%NFileOpt3)                    #! File option 3
#DECLARE(%NFileOpt4)                    #! File option 4
#!
#DECLARE(%NFieldUser)                   #! Field user options [RASQL]
#DECLARE(%NFieldOpt1)                   #! Field option 1 [NO]
#DECLARE(%NFieldOpt2)                   #! Field option 2 [<backend database type override>]
#DECLARE(%NFieldOpt3)                   #! Field option 3 [<backend database default value>]
#DECLARE(%NFieldOpt4)                   #! Field option 4
#!
#DECLARE(%NKeyUser)                     #! Key user options [RASQL]
#DECLARE(%NKeyOpt1)                     #! Key option 1 [NO]
#DECLARE(%NKeyOpt2)                     #! Key option 2
#DECLARE(%NKeyOpt3)                     #! Key option 3
#DECLARE(%NKeyOpt4)                     #! Key option 4
#!
#DECLARE(%NRelationUser)                #! Relation user options [RASQL]
#DECLARE(%NRelationOpt1)                #! Relation option 1 [NO]
#DECLARE(%NRelationOpt2)                #! Relation option 2
#DECLARE(%NRelationOpt3)                #! Relation option 3
#DECLARE(%NRelationOpt4)                #! Relation option 4
#!
#DECLARE(%NFileName)                    #! File Name
#DECLARE(%NFilePrefix)                  #! File Prefix - RA.2008.07.19
#DECLARE(%NFileType)                    #! TYPE=???
#DECLARE(%NFileRowFormat)               #! ROW_FORMAT=???
#!
#DECLARE(%NFieldPKey)                   #! Field is Primary Key?
#DECLARE(%NFieldLine)                   #! Field line
#DECLARE(%NFieldName)                   #! Field Name
#DECLARE(%NFieldTSql)                   #! Field SQL type
#DECLARE(%NFieldTDef)                   #! Field SQL default
#DECLARE(%NFieldType)                   #! Field type
#DECLARE(%NFieldDef)                    #! Field default
#DECLARE(%NFieldCheck)                  #! Field CHECK(...) constraint
#DECLARE(%NFieldCheckOver)              #! Field CHECK(...) constraint override
#DECLARE(%NFieldAuto)                   #! Field AUTO_INCREMENT
#DECLARE(%NFieldNN)                     #! Field NOT NULL
#DECLARE(%NFieldSize  ,LONG)            #! Field decimal size
#DECLARE(%NFieldDec   ,LONG)            #! Field decimal places
#DECLARE(%NLeadZero   ,LONG)            #! Have a leading zero
#DECLARE(%NFNameAuto)                   #! Field Name Auto Increment
#DECLARE(%NVarcharLen ,LONG)            #! Length before turning to VARCHAR
#SET(%NVarcharLen, %VarcharLen)         #! Turn the input field to a long
#!
#DECLARE(%NKeyName)                     #! Key name
#DECLARE(%NKeyFields)                   #! Key building line
#DECLARE(%NKeyField)                    #! Key field current
#DECLARE(%NKeyField1)                   #! Key field current (from)
#DECLARE(%NKeyField2)                   #! Key field current (to)
#DECLARE(%NKeyFieldCount)               #! Number of key fields
#DECLARE(%PrimaryCount)                 #! Primary key exists
#DECLARE(%SecondaryCount)               #! Secondary key exists
#DECLARE(%AutoIncrementCount)           #! Auto-Increment key exists
#!
#DECLARE(%NRelateItem)                  #! Working item number
#DECLARE(%NRelateCount)                 #! Total items to work
#DECLARE(%NRelateComma)                 #! Number of commas
#DECLARE(%NRelateFile)                  #! Related file
#DECLARE(%NRelateField1)                #! Related origin field
#DECLARE(%NRelateField2)                #! Related relate field
#DECLARE(%RelationField1Count)          #! Count of origin file key items
#DECLARE(%RelationField2Count)          #! Count of relate file key items
#DECLARE(%RelationField1)               #! The origin file keys
#DECLARE(%RelationField2)               #! The relate file keys
#DECLARE(%RelationUpdate)               #! ON UPDATE ?
#DECLARE(%RelationDelete)               #! ON DELETE ?
#!
#!#DECLARE(%nLoc1       ,LONG)            #! Location 1
#!#DECLARE(%nLoc2       ,LONG)            #! Location 2
#DECLARE(%TheCount    ,LONG)            #! Count posible relations
#DECLARE(%CStringLen)                   #! Length of types shortened by one
#DECLARE(%LastField)                    #! Last field processed
#DECLARE(%InnerGroup)                   #! Inner group level processed
#DECLARE(%FieldComma)                   #! Number of fields - 1
#!
#DECLARE(%ChoiceLine)                   #! Build ENUM field type line
#DECLARE(%ChoiceComma)                  #! Count ENUM values - 1
#!
#DECLARE(%DocVar)                       #! Documentation Variable
#DECLARE(%TableCount, 0)                #! Count of tables
#DECLARE(%AutoCount, 0)                 #! Count of Auto-Increment Keys
#DECLARE(%PKeyCount, 0)                 #! Count of primary keys (From Keys)
#DECLARE(%PKeyOption, 0)                #! Count of primary keys (From Options)
#DECLARE(%KeyOthers, 0)                 #! Count of secondary keys
#DECLARE(%KeyCount, 0)                  #! Count of all keys combined
#DECLARE(%FieldCount, 0)                #! Count of fields
#DECLARE(%RelCount, 0)                  #! Relationship Counts
#DECLARE(%FieldTable),MULTI,UNIQUE      #! List of unique fields
#DECLARE(%FieldUnique, 0)               #! Count of unique fields
#!
#DECLARE(%TheDate)                      #! Display current date
#DECLARE(%TheTime)                      #! Display current time
#SET(%TheDate,FORMAT(TODAY(),@D010))    #! Set current date
#SET(%TheTime,FORMAT(CLOCK(),@T06))     #! Set current time
#!
#DECLARE(%DimCount          ,LONG)      #! Number of dimensions
#DECLARE(%FldArray          ,STRING)    #! Created field name from array
#DECLARE(%FD1S              ,STRING)    #! Number for dimension 1
#DECLARE(%FD2S              ,STRING)    #! Number for dimension 2
#DECLARE(%FD3S              ,STRING)    #! Number for dimension 3
#DECLARE(%FD4S              ,STRING)    #! Number for dimension 4
#DECLARE(%FD1I              ,LONG)      #! Looping in Dimension 1
#DECLARE(%FD2I              ,LONG)      #! Looping in Dimension 2
#DECLARE(%FD3I              ,LONG)      #! Looping in Dimension 3
#DECLARE(%FD4I              ,LONG)      #! Looping in Dimension 4
#DECLARE(%FD1L              ,LONG)      #! Set to %FieldDimension1
#DECLARE(%FD2L              ,LONG)      #! Set to %FieldDimension2
#DECLARE(%FD3L              ,LONG)      #! Set to %FieldDimension3
#DECLARE(%FD4L              ,LONG)      #! Set to %fieldDimension4
#!
#DECLARE(%ValTypeDCT        ,STRING)    #! Original type from dictionary
#DECLARE(%ValType           ,STRING)    #! Validation type for backend
#DECLARE(%ValLength         ,LONG)      #! String length
#DECLARE(%ValNumeric        ,LONG)      #! Length of entry box
#DECLARE(%ValDecimal        ,LONG)      #! Number of decimal places
#DECLARE(%ValTrue           ,STRING)    #! TRUE Value
#DECLARE(%ValFalse          ,STRING)    #! FALSE Value
#DECLARE(%ValI              ,LONG)      #! Index into list of values
#DECLARE(%ValList),MULTI,UNIQUE         #! List of Values
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#DECLARE(%optGrantCount     ,LONG)      #! Number of options created                #! RA.2008.06.29
#DECLARE(%optGrantTotal     ,LONG)      #! Number of options checked on             #! RA.2008.06.29
#DECLARE(%optGrantLine      ,STRING)    #! Grant option line                        #! RA.2008.06.29
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#DECLARE(%TriggerBefore     ,LONG)                                                  #! RA.2008.06.30
#DECLARE(%TriggerAfter      ,LONG)                                                  #! RA.2008.06.30
#DECLARE(%TriggerList),MULTI                                                        #! RA.2008.06.30
#DECLARE(%TriggerWhen   ,%TriggerList)                                              #! RA.2008.06.30
#DECLARE(%TriggerOp     ,%TriggerList)                                              #! RA.2008.06.30
#DECLARE(%TriggerStmt   ,%TriggerList)                                              #! RA.2008.06.30
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#DECLARE(%ProcFile),MULTI,UNIQUE        #! RA.2007.11.25
#FOR(%File)                             #! RA.2007.11.25
  #ADD(%ProcFile,%File)                 #! RA.2007.11.25
#ENDFOR                                 #! RA.2007.11.25
#!--------------------------------------------------------------!
#! List of table, key and rows names found in reserved list.    !
#!--------------------------------------------------------------!
#DECLARE(%ReservedFieldList),MULTI,UNIQUE
#EQUATE (%FoundFileName     ,'File Name:          ')
#EQUATE (%FoundFileField    ,'File Field Name:    ')
#EQUATE (%FoundAIKeyName    ,'AI Key Name:        ')
#EQUATE (%FoundKeyName      ,'Key Name:           ')
#EQUATE (%FoundKeyField     ,'Key Field Name:     ')
#EQUATE (%FoundRelatedName  ,'Related File Name:  ')
#EQUATE (%FoundRelatedField ,'Related Field Name: ')
#!-------------------------------------------------------------------------!
#! RA.2001.12.15 - Table of field-table to be able to create relations.    !
#!-------------------------------------------------------------------------!
#DECLARE(%FieldTableList),MULTI,UNIQUE
#!---------------------------------------------------------------------
#DECLARE(%LFieldInKey),MULTI,UNIQUE     #! Field list that are used in keys
#DECLARE(%IFieldInKey)                  #! Field item to search for in list
#DECLARE(%LFieldInKeyCount)             #! How many fields are in keys?
#FREE(%LFieldInKey)
#FOR(%ProcFile)                         #! RA.2007.11.25
  #FIX(%File,%ProcFile)                 #! RA.2007.11.25
  #IF(ITEMS(%Key))
    #FOR(%Key)
      #FOR(%KeyField)
        #ADD(%LFieldInKey,%KeyField)
      #ENDFOR
    #ENDFOR
  #ENDIF
#ENDFOR
#SET(%LFieldInKeyCount,ITEMS(%LFieldInKey))
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#INSERT(%ClarionReservedWords)
#INSERT(%SqlReservedWords)
#FOR(%ClarionWordList)
  #ADD(%SqlWordList,%ClarionWordList)
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#SET(%TableCount, 0)                    #! Count of tables
#SET(%AutoCount, 0)                     #! Count of Auto-Increment Keys
#SET(%PKeyCount, 0)                     #! Count of primary keys (From Keys)
#SET(%PKeyOption, 0)                    #! Count of primary keys (From Options)
#SET(%KeyOthers, 0)                     #! Count of secondary keys
#SET(%KeyCount, 0)                      #! Count of all keys combined
#SET(%FieldCount, 0)                    #! Count of fields
#SET(%RelCount, 0)                      #! Relationship Counts
#SET(%FieldUnique, 0)                   #! Count of unique fields
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLTable)
  #SET(%OutTableName,%SQLDirectory & %SQLTableName)
  #CREATE(%OutTableName)
  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLTableName,1)
--
-- BOF: %OutTableName
--
-- SQL script creator for POSTGRESQL database [TABLE]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
DROP SCHEMA IF EXISTS %SchemaName CASCADE ;
CREATE SCHEMA %SchemaName ;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
  #!------------------------------------------------------------------------!
  #! IF it IS a primary key, AND it is an integer, AND NOT auto-increment,  !
  #! AND there is one item in the key (only thing I can be sure about),     !
  #! THEN assume that it IS an auto-increment handled by the SQL backend.   !
  #!------------------------------------------------------------------------!
  #SET(%NFNameAuto,'')
  #SET(%AutoIncrementCount,0)
  #IF(ITEMS(%Key))
    #FOR(%Key)
#!---- Key        = %Key
      #IF(%KeyPrimary <> 1)
        #CYCLE
      #ENDIF
#!---- KeyPrimary = %KeyPrimary
      #IF(%KeyAuto = 1)
        #CYCLE
      #ENDIF
#!---- KeyAuto    = %KeyAuto
#!
      #IF(ITEMS(%KeyField) > 1)
        #CYCLE
      #ENDIF
#!
      #FOR(%KeyField)
#!---- KeyField   = %KeyField
        #FIX(%Field,%KeyField)
#!---- Field      = %Field
#!---- FieldType  = %FieldType
        #CASE(%FieldType)
        #OF('LONG')
          #SET(%NFNameAuto, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
        #ENDCASE
      #ENDFOR
#!
      #IF(%NFNameAuto)
#!---- NFNameAuto = %NFNameAuto
        #SET(%AutoIncrementCount,%AutoIncrementCount + 1)
        #SET(%AutoCount, %AutoCount + 1)
#!        #SET(%NFNameAuto, SUB(%KeyAuto, INSTRING(':',%KeyAuto,1,1) + 1 , 50))
        #IF(%UsePrefix='All' OR %PrefixColumns)                                     #! RA.2008.08.11
          #SET(%NFNameAuto, %FilePrefix & '_' & %NFNameAuto)
        #ENDIF
        #!---------------------------------------------!
        #! RA.2007.10.10 - Behave according to option. !
        #!---------------------------------------------!
        #IF(NOT %IgnoreReserved)
          #SET(%SqlWordItem, UPPER(%NFNameAuto))
          #FIND(%SqlWordList, %SqlWordItem)
          #IF(%SqlWordList)
            #ADD(%ReservedFieldList, %FoundAIKeyName & %FilePrefix & ':' & %NFNameAuto)
            #SET(%NFNameAuto, %NFNameAuto & '_')
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDFOR
    #IF(%AutoIncrementCount = 0)
#!-- WARNING: %File(%FilePrefix) has no AUTO-INCREMENT KEY defined.
    #ENDIF
  #ENDIF
#!
#!PRINT '%NFileName'
#!
  #IF(%nFileOpt0)
--
-- DRIVER:  %FileDriver
-- OPTIONS: %FileDriverParameter
-- OWNER:   %FileOwner
-- NAME:    %FileName
--
  #ENDIF
#!
CREATE TABLE %NFileName (
#INSERT(%PGSQLField)                                            #! Process fields
)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%FileDescription))                        #! RA.2008.08.12
COMMENT ON TABLE %NFileName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13
#INSERT(%PGSQLFieldComment)                                     #! Process fields comments

#!  #IF (%UseOwner)
#!ALTER TABLE %NFileName OWNER TO %OwnerName
#!;
#!
#!  #ENDIF
  #!----------------------------------------------------------------!
  #! RA.2007.09.20 - If the ISIDENTITY() is set to TRUE this is     !
  #! an auto increment field. This is best descrived as a SERIAL    !
  #! (or BIG serial). SERIAL or BIGSERIAL sets up the equivalent    !
  #! in PostgreSQL of:                                              !
  #!                                                                !
  #!  CREATE TABLE pg_name (                                        !
  #!    auto_id INT NOT NULL ,                                      !
  #!    first_name CHAR(30) NOT NULL ,                              !
  #!    middle_name CHAR(30) NULL ,                                 !
  #!    last_name CHAR(30) NOT NULL ,                               !
  #!    last_name_father CHAR(30) NULL ,                            !
  #!    last_name_mother CHAR(30) NULL                              !
  #!  )                                                             !
  #!  ;                                                             !
  #!                                                                !
  #!  ALTER TABLE pg_name                                           !
  #!    ADD CONSTRAINT pg01_key0_pk PRIMARY KEY (auto_id)           !
  #!  ;                                                             !
  #!                                                                !
  #!  CREATE INDEX pg01_key1                                        !
  #!    ON pg_name (last_name)                                      !
  #!  ;                                                             !
  #!                                                                !
  #!  CREATE SEQUENCE pg_name_id_seq                                !
  #!      INCREMENT BY 1                                            !
  #!      CACHE 1                                                   !
  #!  ;                                                             !
  #!                                                                !
  #!  ALTER SEQUENCE pg_name_id_seq OWNED BY pg_name.auto_id        !
  #!  ;                                                             !
  #!                                                                !
  #!  ALTER TABLE pg_name ALTER COLUMN auto_id SET DEFAULT          !
  #!       nextval('pg_name_id_seq'::regclass)                      !
  #!  ;                                                             !
  #!                                                                !
  #!----------------------------------------------------------------!
  #IF(%nFileOpt0)                                               #! You have to have it set up in the dictionary
    #IF(%UseSerial)                                             #! And you have to want it in the template
CREATE SEQUENCE %NFileName_id_seq
  INCREMENT BY 1
  CACHE 1
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%FileDescription))                        #! RA.2008.08.12
COMMENT ON SEQUENCE %NFileName_id_seq IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

ALTER SEQUENCE %NFileName_id_seq
  OWNED BY %NFileName.%NFNameAuto
;

ALTER TABLE %NFileName ALTER COLUMN %NFNameAuto
  SET DEFAULT nextval('%NFileName_id_seq'::regclass)
;
    #ENDIF

  #ENDIF
#ENDFOR
--
-- EOF: %OutTableName
--
  #CLOSE(%OutTableName)
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLGrant)
  #SET(%OutGrantName,%SQLDirectory & %SQLGrantName)
  #CREATE(%OutGrantName)
  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLGrantName,1)
--
-- BOF: %OutGrantName
--
-- SQL script creator for POSTGRESQL database [GRANT]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, pg_catalog
;

#ENDIF
#IF(%optGrantAll)
GRANT ALL TO %optGrantAllUser WITH GRANT OPTION
;

#ENDIF
#!
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #IF(NOT %optGrantDoit)                                        #! RA.2008.09.17
    #CYCLE                                                      #! RA.2008.09.17
  #ENDIF                                                        #! RA.2008.09.17
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
  #FOR(%optGrant)
    #SET(%optGrantTotal     , %optGrantSelect + %optGrantInsert + %optGrantUpdate + %optGrantDelete)
    #SET(%optGrantCount     , 0)
    #SET(%optGrantLine      , '')
#!-- TOTAL: %optGrantTotal
    #CASE(%optGrantTotal)
    #OF(4)
      #SET(%optGrantLine, 'GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE ' & %NFileName)
      #SET(%optGrantCount, 4)
    #OF(3)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(2)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(1)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #ENDCASE
%optGrantLine
    #IF(%optGrantType = 'User')
  TO %optGrantName
    #ELSE
  TO GROUP %optGrantName
    #ENDIF
;
  #ENDFOR

#ENDFOR
#!
#IF(%opt2GrantDoit AND ITEMS(%opt2Grant))

--
-- SQL script creator for POSTGRESQL database [GRANT] - Specific Tables
-- Created: %TheDate - %TheTime
--

  #FOR(%opt2Grant)
    #FIX(%File          , %opt2GrantTable)
#INSERT(%PGModifyNameTable)
    #MESSAGE('Table of: ' & %File,2)
#!
    #IF(%CommentsSQL)                                           #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

    #ENDIF                                                      #! RA.2008.08.13
#!
    #SET(%optGrantType  , %opt2GrantType)
    #SET(%optGrantName  , %opt2GrantName)
    #SET(%optGrantSelect, %opt2GrantSelect)
    #SET(%optGrantInsert, %opt2GrantInsert)
    #SET(%optGrantUpdate, %opt2GrantUpdate)
    #SET(%optGrantDelete, %opt2GrantDelete)
#!
    #SET(%optGrantTotal     , %optGrantSelect + %optGrantInsert + %optGrantUpdate + %optGrantDelete)
    #SET(%optGrantCount     , 0)
    #SET(%optGrantLine      , '')
#!-- TOTAL: %optGrantTotal
    #CASE(%optGrantTotal)
    #OF(4)
      #SET(%optGrantLine, 'GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE ' & %NFileName)
      #SET(%optGrantCount, 4)
    #OF(3)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(2)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(1)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #ENDCASE
%optGrantLine
    #IF(%optGrantType = 'User')
  TO %optGrantName
    #ELSE
  TO GROUP %optGrantName
    #ENDIF
;

  #ENDFOR
#ENDIF
--
-- EOF: %OutGrantName
--
  #CLOSE(%OutGrantName)
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLIndex)
  #SET(%OutIndexName,%SQLDirectory & %SQLIndexName)
  #CREATE(%OutIndexName)
  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLIndexName,1)
--
-- BOF: %OutIndexName
--
-- SQL script creator for POSTGRESQL database [KEYS]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, pg_catalog
;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
#!PRINT '%NFileName'
  #SET(%PrimaryCount,0)                                         #! Primary key exists
  #SET(%SecondaryCount,0)                                       #! Secondary key exists
  #IF(ITEMS(%Key))
    #FOR(%Key)
      #IF(NOT ITEMS(%KeyField))                                 #! Key has fields? No!
        #CYCLE                                                  #! Then go to the next
      #ENDIF                                                    #! key to be processed
#!
      #SET(%nLoc1,INSTRING('RASQL(',%KeyUserOptions,1,1))
      #SET(%nLoc2,INSTRING(')',%KeyUserOptions,1,%nLoc1))
      #SET(%nKeyUser,UPPER(SUB(%KeyUserOptions,%nLoc1,%nLoc2)))
      #!SET(%NKeyUser,UPPER(EXTRACT(%KeyUserOptions,'RASQL')))
      #SET(%NKeyOpt1,EXTRACT(%NKeyUser,'RASQL',1))
      #SET(%NKeyOpt2,EXTRACT(%NKeyUser,'RASQL',2))
      #SET(%NKeyOpt3,EXTRACT(%NKeyUser,'RASQL',3))
      #SET(%NKeyOpt4,EXTRACT(%NKeyUser,'RASQL',4))
#!%NKeyUser, %NKeyOpt1, %NKeyOpt2, %NKeyOpt3, %NKeyOpt4
      #!------------------------------------------------------------!
      #! The first option RASQL(NO) controls if a key is processed. !
      #!------------------------------------------------------------!
      #IF(SUB(%NKeyOpt1,1,1)='N')
        #CYCLE
      #ENDIF
#!
#! -- FileName 00: %NFileName
#INSERT(%PGModifyNameKey00)
#! -- FileName 01: %NFileName
#!
      #SET(%NKeyFields,'')
      #SET(%NKeyFieldCount,0)
      #FOR(%KeyField)
        #SET(%NKeyField, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
        #!-------------------------------------------------------------------------!
        #! RA.2001.12.15 - Table of keyfield-table to be able to create relations. !
        #!-------------------------------------------------------------------------!
        #IF(%DoFieldFile)
          #ADD(%FieldTableList, %NKeyField & ' ==> ' & %File)
        #ENDIF
        #!
        #IF(%UsePrefix='All' OR %PrefixColumns)                                 #! RA.2008.08.11
          #SET(%NKeyField, %FilePrefix & '_' & %NKeyField)
        #ENDIF
        #!----------------------------------!
        #! RA.2007.12.26 - Obey the option. !
        #!----------------------------------!
        #IF(NOT %IgnoreReserved)
          #SET(%SqlWordItem, UPPER(%NKeyField))
#!-- SqlWordItem = '%SqlWordItem'
          #FIND(%SqlWordList, %SqlWordItem)
#!-- SqlWordList = '%SqlWordList'
          #IF(%SqlWordList)
            #ADD(%ReservedFieldList, %FoundKeyField & %FilePrefix & ':' & %NKeyField)
            #SET(%NKeyField, %NKeyField & '_')
          #ENDIF
        #ENDIF
        #SET(%NKeyFieldCount,%NKeyFieldCount + 1 )
        #IF(%NKeyFieldCount = 1)
          #SET(%NKeyFields,%NKeyField)
        #ELSE
          #SET(%NKeyFields, %NKeyFields & ', ' & %NKeyField)
        #ENDIF
      #ENDFOR
      #IF(%KeyPrimary)
        #SET(%PrimaryCount, 1)
        #SET(%PKeyCount, %PKeyCount + 1)
        #SET(%KeyCount, %KeyCount + 1)
#!-- 01
ALTER TABLE %NFileName
  ADD CONSTRAINT %NKeyName PRIMARY KEY (%NKeyFields)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON CONSTRAINT %NKeyName ON %NFileName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

      #ELSIF(NOT %KeyPrimary)
        #SET(%KeyOthers, %KeyOthers + 1)
        #SET(%KeyCount, %KeyCount + 1)
        #IF(%KeyDuplicate)
          #CASE(%KeyIndex)
          #OF  ('KEY')
#!-- 02
CREATE INDEX %NKeyName
 #IF(%UseLowerCase)                                             #! MAG 02.21.08
  #SET(%NKeyFields,lower(%NKeyFields))                          #! MAG 02.21.08
 #ENDIF                                                         #! MAG 02.21.08
  ON %NFileName (%NKeyFields)
;
#IF(%UseLowerCase)                                              #! MAG 02.21.08
 #SET(%NKeyName,lower(%NKeyName))                               #! MAG 02.21.08
#ENDIF                                                          #! MAG 02.21.08
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

          #OF  ('INDEX')
          #OROF('DYNAMIC')
#IF(%UseLowerCase)                                              #! MAG 02.21.08
 #SET(%NKeyName, lower(%NKeyName))                              #! MAG 02.21.08
 #SET(%NKeyFields, lower(%NKeyFields))                          #! MAG 02.21.08
#ENDIF                                                          #! MAG 02.21.08
#!-- 03
CREATE INDEX %NKeyName
  ON %NFileName (%NKeyFields)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

          #ENDCASE
        #ELSE
          #CASE(%KeyIndex)
          #OF  ('KEY')
#!-- 04
CREATE UNIQUE INDEX %NKeyName
#IF(%UseLowerCase)                                      #! MAG 02.21.08
  #SET(%NKeyFields,Lower(%NKeyFields))                  #! RA.2008.03.22 - Correction
#ENDIF                                                  #! MAG 02.21.08
  ON %NFileName (%NKeyFields)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

          #OF  ('INDEX')
          #OROF('DYNAMIC')
#!-- 05
CREATE UNIQUE INDEX %NKeyName
  #IF(%UseLowerCase)                                            #! MAG 02.21.08
  ON %NFileName (lower(%NKeyFields))
  #ELSE                                                         #! MAG 02.21.08
  ON %NFileName (%NKeyFields)
  #ENDIF                                                        #! MAG 02.21.08
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
#ENDIF                                                          #! RA.2008.08.13

          #ENDCASE
        #ENDIF
      #ENDIF
    #ENDFOR
    #IF(NOT %PrimaryCount)
--
-- WARNING: %File(%FilePrefix) has no PRIMARY KEY defined.
--
    #ENDIF
  #ELSE
--
-- WARNING: %File(%FilePrefix) has no KEYS defined.
--
  #ENDIF
  #! +++++ RA.2008.08.06 - Special indexes from options here
#ENDFOR
--
-- EOF: %OutIndexName
--
  #CLOSE(%OutIndexName)
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLRelat)
  #SET(%OutRelatName,%SQLDirectory & %SQLRelatName)
  #CREATE(%OutRelatName)
  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLRelatName,1)
--
-- BOF: %OutRelatName
--
-- SQL script creator for POSTGRESQL database [RELATIONS]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, pg_catalog
;

#ENDIF
#!
  #SET(%RelCount, 0)
  #FOR(%ProcFile)                           #! RA.2007.11.25
    #FIX(%File,%ProcFile)                   #! RA.2007.11.25
    #CASE(%FileDriver)
      #OF('ASCII')
    #OROF('BASIC')
    #OROF('DOS')
        #CYCLE
    #ENDCASE
#!
    #CASE(%FileType)
    #OF  ('VIEW')
#!------------------------------------------------------------!
#! RA.2001.07.22 - Need to deal with aliases for the purpose  !
#! of discovering additional key relationships that can not   !
#! be done with a single file from Clarion. In specific       !
#!                                                            !
#! Tables                                                     !
#!  Party_Table         Party_Relationship_Table              !
#!  Party_Id            Party_Id_From                         !
#!                      Party_Id_To                           !
#! Relations                                                  !
#!  Party_Id    <->>    Party_Id_From                         !
#!  Party_Id    <->>    Party_Id_To                           !
#!                                                            !
#! Clarion would need an alias of Party_Relationship_Table to !
#! deal with the second relationship. There would be no way   !
#! to use the second table again since Clarion restricts that !
#! specific operation.                                        !
#!                                                            !
#! SQL handles these type of relationships correctly and they !
#! need to be generated as an original file relationship.     !
#!------------------------------------------------------------!
#!  #OROF('ALIAS')
        #CYCLE
    #ENDCASE
#!
#INSERT(%PGModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
    #SET(%TheCount, 0)
    #IF(ITEMS(%Relation))
      #FOR(%Relation)
        #SET(%nLoc1,INSTRING('RASQL(',%RelationUserOptions,1,1))
        #SET(%nLoc2,INSTRING(')',%RelationUserOptions,1,%nLoc1))
        #SET(%nRelationUser,UPPER(SUB(%RelationUserOptions,%nLoc1,%nLoc2)))
        #!SET(%NRelationUser,UPPER(EXTRACT(%RelationUserOptions,'RASQL')))
        #SET(%NRelationOpt1,EXTRACT(%NRelationUser,'RASQL',1))
        #SET(%NRelationOpt2,EXTRACT(%NRelationUser,'RASQL',2))
        #SET(%NRelationOpt3,EXTRACT(%NRelationUser,'RASQL',3))
        #SET(%NRelationOpt4,EXTRACT(%NRelationUser,'RASQL',4))
#!-- %FileRelationType
#!-- %NFileName  <=  %NRelateFile [ %FileType ] %AliasFile : %Relation  ==  %RelationAlias
#!-- %NRelationUser, %NRelationOpt1, %NRelationOpt2, %NRelationOpt3, %NRelationOpt4
        #!-----------------------------------------------------------------!
        #! The first option RASQL(NO) controls if a relation is processed. !
        #!-----------------------------------------------------------------!
        #IF(SUB(%NRelationOpt1,1,1)='N')
          #CYCLE
        #ENDIF
#!
        #!--------------------------------------------------------------------!
        #! RA.2007.10.02 - References always go from the child to the parent. !
        #!--------------------------------------------------------------------!
        #IF(%FileRelationType = 'MANY:1')
          #SET(%Relationfield1, '')
          #SET(%Relationfield2, '')
#INSERT(%PGModifyNameKey01)
          #!
#INSERT(%PGModifyNameRelTable)
#!-- [%FileRelationType] %NFileName  <=  %NRelateFile [ %FileType ] %AliasFile : %Relation  ==  %RelationAlias
          #!
          #SET(%RelationField1Count, ITEMS(%FileKeyField))
          #SET(%RelationField2Count, ITEMS(%RelationKeyField))
          #!
          #SET(%NRelateCount, %RelationField1Count)
          #SET(%NRelateComma, %NRelateCount - 1)
          #SET(%NRelateItem, 0)
          #FOR(%FileKeyField)
            #IF(%NRelateItem > %NRelateCount)
              #BREAK
            #ENDIF
            #SET(%NRelateItem, %NRelateItem + 1)
            #SET(%NRelateField1, SUB(%FileKeyField,INSTRING(':',%FileKeyField,1,1)+1,50))
            #SET(%NRelateField2, SUB(%FileKeyFieldLink,INSTRING(':',%FileKeyFieldLink,1,1)+1,50))
            #!
#INSERT(%PGModifyNameRelField1)
            #!
#INSERT(%PGModifyNameRelField2)
            #!
            #SET(%RelationField1, %RelationField1 & %NRelateField1)
            #SET(%RelationField2, %RelationField2 & %NRelateField2)
            #IF(%NRelateComma)
              #SET(%NRelateComma, %NRelateComma - 1)
              #SET(%RelationField1, %RelationField1 & ', ')
              #SET(%RelationField2, %RelationField2 & ', ')
            #ENDIF
          #ENDFOR
          #!-------------------------------------------!
          #! RA.2001.01.20 - Added this feature.       !
          #! Has syntax errors, so commented out.      !
          #!-------------------------------------------!
          #! Added to the comments so programmer is at !
          #! aware that other relationships may exist. !
          #!-------------------------------------------!
          #SET(%RelationUpdate,%RelationConstraintUpdate)       #! ON UPDATE ?
          #SET(%RelationDelete,%RelationConstraintDelete)       #! ON DELETE ?
          #!-------------------------------------------!
          #IF(%Relationfield1)
            #MESSAGE('Relation of: ' & %File,2)
            #SET(%RelCount, %RelCount + 1)
            #!----------------------------------------------------------!
            #! RA.2001.07.22 - The alias name gets changed to the real  !
            #! name to generate the SQL statement for the relationship. !
            #!----------------------------------------------------------!
            #IF(%FileType = 'ALIAS')
              #SET(%NFileName,%AliasFile)
              #FIX(%File, %AliasFile)
              #IF(%UsePrefix='All' OR %PrefixTables)                        #! RA.2008.08.11
                #SET(%NFileName,%FilePrefix & '_' & %File)
              #ENDIF
            #ENDIF
            #IF(%TheCount = 0)
#!PRINT '%NFileName'
            #ENDIF
            #SET(%TheCount,%TheCount+1)
ALTER TABLE %NFileName
   ADD CONSTRAINT rel_%NKeyField
   FOREIGN KEY (%Relationfield1)
   REFERENCES %NRelateFile (%Relationfield2)
   #!--------------------------------------------------------!
   #! MG.2008.07.17 - Completed work on the Relationships.   !
   #! RA.2007.10.03 - Work on this - PostgreSQL supports it. !
   #!--------------------------------------------------------!
            #IF(%RelationUpdate)
              #CASE(%RelationUpdate)
              #OF('RESTRICT_SERVER')
   ON UPDATE RESTRICT
              #OF('CASCADE_SERVER')
   ON UPDATE CASCADE
              #OF('CLEAR_SERVER')
              #OROF('CLEAR')
   ON UPDATE SET NULL
              #OF('NONE')
              #OROF('NONE_SERVER')
              #ELSE
   ON UPDATE %RelationUpdate
              #ENDCASE
            #ENDIF
            #IF(%RelationDelete)
              #CASE(%RelationDelete)
              #OF('RESTRICT_SERVER')
   ON DELETE RESTRICT
              #OF('CASCADE_SERVER')
   ON DELETE CASCADE
              #OF('CLEAR_SERVER')
              #OROF('CLEAR')
   ON DELETE SET NULL
              #OF('NONE')
              #OROF('NONE_SERVER')
            #ELSE
   ON DELETE %RelationDelete
              #ENDCASE
            #ENDIF
            #IF(%SQLRelatDefer)
              #IF(SUB(%NRelationOpt3,1,1) = 'Y')
   DEFERRABLE
   INITIALLY DEFERRED
             #ENDIF
           #ENDIF
;
  #IF(%CommentsDB)                                                                                              #! RA.2008.08.13
#SET(%NComment, 'Relation from table (FK) ' & %NFileName & ' to table (PK) ' & %NRelateFile & ' contraint.')    #! RA.2008.08.13
#SET(%NComment, QUOTE(%NComment))                                                                               #! RA.2008.08.13
COMMENT ON CONSTRAINT rel_%NKeyField ON TABLE %NFileName IS
'%NComment'
;
  #ENDIF                                                                                                        #! RA.2008.08.13

          #ENDIF
        #ENDIF
      #ENDFOR
    #ENDIF
  #ENDFOR
--
-- EOF: %OutRelatName
--
  #CLOSE(%OutRelatName)
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLValid)
  #SET(%OutValidName,%SQLDirectory & %SQLValidName)
  #CREATE(%OutValidName)
  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLValidName,1)
--
-- BOF: %OutValidName
--
-- SQL script creator for POSTGRESQL database [VALIDATIONS]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, pg_catalog
;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
  #FOR(%Field)
    #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
    #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
    #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
    #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
    #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
    #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
    #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
    #!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
    #!--------------------------------------------------------------!
    #! The first option RASQL(NO) controls if a field is processed. !
    #!--------------------------------------------------------------!
    #IF(SUB(%NFieldOpt1,1,1)='N')
      #CYCLE
    #ENDIF
    #!------------------------------------------------!
    #! Begin removal of types that are not processed. !
    #!------------------------------------------------!
    #IF(%FieldType='GROUP')
      #CYCLE
    #ENDIF
    #IF(%FieldType='END')
      #CYCLE
    #ENDIF
    #!--------------------------------------------!
    #! RA.2007.10.03 - Simple name for functions. !
    #!--------------------------------------------!
    #SET(%NFieldName, %FieldID)                                     #! Field Name
    #!
    #SET(%ValTypeDCT        ,UPPER(%FieldType))                     #! Original type from dictionary
    #SET(%ValType           ,'')                                    #! Validation type for backend
    #SET(%ValLength         ,%FieldMemoSize)                        #! Length in characters
    #SET(%ValNumeric        ,%FieldFormatWidth)                     #! Numer of characters in entry control
    #SET(%ValDecimal        ,%FieldPlaces)                          #! Number of decimal places
    #SET(%ValTrue           ,%FieldTrueValue)                       #! TRUE Value
    #SET(%ValFalse          ,%FieldFalseValue)                      #! FALSE Value
    #FREE(%ValList)                                                 #! INLIST values
    #!------------------------------------------------------!
    #! RA.2007.10.04 - Figure type of variable for backend. !
    #!------------------------------------------------------!
    #CASE(%ValTypeDCT)
    #OF('BLOB')                                                     #! This should not make it thru
      #SET(%ValType,'bytea')                                        #! since it is binary data
    #OF('MEMO')
      #SET(%ValType,'text')
    #OF('CSTRING')
      #SET(%ValLength,%ValLength - 1)                               #! Adjust for null terminator
    #ENDCASE
    #!=============================================================!
    #! In some cases it is more accurate to check the display mask !
    #! to determine the web type. Dates can be a LONG or a DATE    !
    #! dictionary type, and the first part of the display mask is  !
    #! going to always be a '@D.                                   !
    #!=============================================================!
    #CASE(SUB(UPPER(%FieldDisplayPicture),1,2))
    #OF('@D')
      #SET(%ValType,'date')
    #OF('@T')
      #SET(%ValType,'time without time zone')
    #OF('@S')
      #SET(%ValType,'text')
      #IF(%ValLength > 255)
        #SET(%ValType,'text')
      #ENDIF
    #OF('@N')
      #SET(%ValType,'integer')
      #IF(%ValDecimal > 0)
        #SET(%ValType,'numeric')
      #ENDIF
    #ENDCASE
    #!================================!
    #!================================!
    #IF(ITEMS(%FieldValues) > 0)
      #FOR(%FieldValues)
        #CASE(%ValType)
        #OF('text')
          #ADD(%ValList,'''' & %FieldValues & '''')
        #ELSE
          #ADD(%ValList,%FieldValues)
        #ENDCASE
      #ENDFOR
    #ENDIF
    #!=================================!
    #! Description setup happens here. !
    #!=================================!
    #CASE(%FieldValidation)                                         #! PREFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
CREATE OR REPLACE FUNCTION %NFileName_%NFieldName_description (param %ValType)
  RETURNS text AS $$
DECLARE
BEGIN
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! LOGIC
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
-- INFILE
    #OF  ('BOOLEAN')
-- BOOLEAN
  RETURN CASE(LOWER(TRIM(param))
    WHEN 'y' THEN 'Yes'
    WHEN '1' THEN 'Yes'
    WHEN 't' THEN 'Yes'
    WHEN 'n' THEN 'No'
    WHEN '0' THEN 'No'
    WHEN 'f' THEN 'No'
    ELSE ''
  END;
    #OF  ('INRANGE')
-- INRANGE
    #OF  ('INLIST')
-- INLIST
      #CASE(%ValType)
      #OF('text')
  IF LENGTH(param) > %ValLength THEN
    RETURN '';
  END IF;
      #ENDCASE
      #LOOP,FOR(%ValI,1,ITEMS(%ValList))
        #SELECT(%FieldValues, %ValI)
        #SELECT(%FieldChoices, %ValI)
-- %FieldValues = %FieldChoices
      #ENDLOOP
      #IF(ITEMS(%ValList) > 0)
  RETURN CASE param
      #LOOP,FOR(%ValI,1,ITEMS(%ValList))
        #SELECT(%FieldValues, %ValI)
        #SELECT(%FieldChoices, %ValI)
        #CASE(%ValType)
        #OF('text')
    WHEN '%FieldValues' THEN '%FieldChoices'
        #ELSE
    WHEN %FieldValues THEN '%FieldChoices'
        #ENDCASE
      #ENDLOOP
    ELSE ''
  END;
      #ENDIF
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! POSTFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
  RETURN '';
END;
$$ LANGUAGE plpgsql
;
  #IF(%CommentsDB)                                                                  #! RA.2008.08.13
#SET(%NComment, 'TABLE ' & %NFileName & ' FIELD ' & %NFieldName & ' DESCRIPTION.')  #! RA.2008.08.12
#SET(%NComment, QUOTE(%NComment))                                                   #! RA.2008.08.12
COMMENT ON FUNCTION %NFileName_%NFieldName_description (param %ValType) IS
'%NComment'
;
  #ENDIF                                                                            #! RA.2008.08.13

    #ENDCASE
    #!================================!
    #! Validation setup happens here. !
    #!================================!
    #CASE(%FieldValidation)                                         #! PREFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
CREATE OR REPLACE FUNCTION %NFileName_%NFieldName_validate (param %ValType)
  RETURNS boolean AS $$
DECLARE
BEGIN
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! LOGIC
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
-- INFILE
    #OF  ('BOOLEAN')
-- BOOLEAN
      #CASE(%ValType)
      #OF('text')
        #SET(%ValTrue, '''' & %ValTrue & '''')
        #SET(%ValFalse, '''' & %ValFalse & '''')
  IF LENGTH(param) > %ValLength THEN
    RETURN FALSE;
  END IF;
      #ENDCASE
  IF    param = %ValTrue THEN RETURN TRUE;
  ELSIF param = %ValFalse THEN RETURN TRUE;
  END IF;
    #OF  ('INRANGE')
-- INRANGE
    #OF  ('INLIST')
-- INLIST
      #CASE(%ValType)
      #OF('text')
  IF LENGTH(param) > %ValLength THEN
    RETURN FALSE;
  END IF;
      #ENDCASE
      #LOOP,FOR(%ValI,1,ITEMS(%ValList))
        #SELECT(%FieldValues, %ValI)
        #SELECT(%FieldChoices, %ValI)
-- %FieldValues = %FieldChoices
      #ENDLOOP
      #IF(ITEMS(%ValList) > 0)
  RETURN CASE param
        #FOR(%ValList)
    WHEN %ValList THEN TRUE
        #ENDFOR
    ELSE FALSE
  END;
      #ENDIF
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! POSTFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql
;
  #IF(%CommentsDB)                                                                  #! RA.2008.08.13
#SET(%NComment, 'TABLE ' & %NFileName & ' FIELD ' & %NFieldName & ' VALIDATION.')   #! RA.2008.08.12
#SET(%NComment, QUOTE(%NComment))                                                   #! RA.2008.08.12
COMMENT ON FUNCTION %NFileName_%NFieldName_validate (param %ValType) IS
'%NComment'
;
  #ENDIF                                                                            #! RA.2008.08.13

      #IF(%SQLValidCheck)
ALTER TABLE %NFileName ADD CONSTRAINT bad_%NFileName_%NFieldName
  CHECK (%NFileName_%NFieldName_validate(%NFieldName))
;

      #ENDIF
    #ENDCASE
  #ENDFOR
#ENDFOR
--
-- EOF: %OutValidName
--
  #CLOSE(%OutValidName)
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLTrigr)
  #SET(%OutTrigrName,%SQLDirectory & %SQLTrigrName)
  #CREATE(%OutTrigrName)
  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLTrigrName,1)
--
-- BOF: %OutTrigrName
--
-- SQL script creator for POSTGRESQL database [TRIGGER]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, pg_catalog
;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
  #FREE(%TriggerList)                                           #! TRIGGER list
  #SET(%TriggerBefore       , 0)                                #! RA.2008.06.30
  #SET(%TriggerAfter        , 0)                                #! RA.2008.06.30
#!
  #FOR(%Field)
    #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
    #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
    #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
    #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
    #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
    #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
    #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
    #!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
    #!--------------------------------------------------------------!
    #! The first option RASQL(NO) controls if a field is processed. !
    #!--------------------------------------------------------------!
    #IF(SUB(%NFieldOpt1,1,1)='N')
      #CYCLE
    #ENDIF
    #!------------------------------------------------!
    #! Begin removal of types that are not processed. !
    #!------------------------------------------------!
    #IF(%FieldType='GROUP')
      #CYCLE
    #ENDIF
    #IF(%FieldType='END')
      #CYCLE
    #ENDIF
    #!--------------------------------------------!
    #! RA.2007.10.03 - Simple name for functions. !
    #!--------------------------------------------!
    #SET(%NFieldName, %FieldID)                                     #! Field Name
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLBEFOREINSERT'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLBEFOREINSERT',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'BEFORE')
      #SET(%TriggerOp       , 'INSERT')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerBefore   , %TriggerBefore + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLBEFOREUPDATE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLBEFOREUPDATE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'BEFORE')
      #SET(%TriggerOp       , 'UPDATE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerBefore   , %TriggerBefore + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLBEFOREDELETE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLBEFOREDELETE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'BEFORE')
      #SET(%TriggerOp       , 'DELETE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerBefore   , %TriggerBefore + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLAFTERINSERT'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLAFTERINSERT',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'AFTER')
      #SET(%TriggerOp       , 'INSERT')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerAfter    , %TriggerAfter + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLAFTERUPDATE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLAFTERUPDATE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'AFTER')
      #SET(%TriggerOp       , 'UPDATE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerAfter    , %TriggerAfter + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLAFTERDELETE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLAFTERDELETE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'AFTER')
      #SET(%TriggerOp       , 'DELETE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerAfter    , %TriggerAfter + 1)
    #ENDIF
  #ENDFOR
#!
  #IF(ITEMS(%TriggerList))
    #FOR(%TriggerList)
--        == %TriggerWhen == %TriggerOp == %TriggerStmt ==
    #ENDFOR
  #ENDIF
#!
  #IF(ITEMS(%TriggerList))
CREATE OR REPLACE FUNCTION %NFileName_trigger()
  RETURNS "trigger"
AS $$
BEGIN

IF    (TG_WHEN = 'BEFORE') THEN
  IF    (TG_OP = 'INSERT') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'BEFORE' AND %TriggerOp = 'INSERT')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'UPDATE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'BEFORE' AND %TriggerOp = 'UPDATE')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'DELETE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'BEFORE' AND %TriggerOp = 'DELETE')
    %TriggerStmt
    #ENDFOR
  END IF;
  RETURN NEW;
ELSIF (TG_WHEN = 'AFTER') THEN
  IF    (TG_OP = 'INSERT') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'AFTER' AND %TriggerOp = 'INSERT')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'UPDATE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'AFTER' AND %TriggerOp = 'UPDATE')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'DELETE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'AFTER' AND %TriggerOp = 'DELETE')
    %TriggerStmt
    #ENDFOR
  END IF;
  RETURN OLD;
END IF;

END $$
LANGUAGE plpgsql VOLATILE
;
    #IF(%SQLTrigrConnect)
      #IF(%TriggerBefore)
CREATE TRIGGER trigger_%NFileName
  BEFORE INSERT OR UPDATE OR DELETE ON %NFileName
  FOR EACH ROW EXECUTE PROCEDURE %NFileName_trigger()
;
      #ENDIF
      #IF(%TriggerAfter)
CREATE TRIGGER trigger_%NFileName
  AFTER INSERT OR UPDATE OR DELETE ON %NFileName
  FOR EACH ROW EXECUTE PROCEDURE %NFileName_trigger()
;
      #ENDIF
    #ENDIF

  #ENDIF
  #FREE(%TriggerList)                                               #! TRIGGER list
#ENDFOR
--
-- EOF: %OutTrigrName
--
  #CLOSE(%OutTrigrName)
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLViews)
  #SET(%OutViewsName,%SQLDirectory & %SQLViewsName)
  #CREATE(%OutViewsName)
  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLViewsName,1)
--
-- BOF: %OutViewsName
--
-- SQL script creator for POSTGRESQL database [VIEWS]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, pg_catalog
;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
  #!------------------------------------------------------------------------!
  #! IF it IS a primary key, AND it is an integer, AND NOT auto-increment,  !
  #! AND there is one item in the key (only thing I can be sure about),     !
  #! THEN assume that it IS an auto-increment handled by the SQL backend.   !
  #!------------------------------------------------------------------------!
  #SET(%NFNameAuto,'')
  #SET(%AutoIncrementCount,0)
  #IF(ITEMS(%Key))
    #FOR(%Key)
#!---- Key        = %Key
      #IF(%KeyPrimary <> 1)
        #CYCLE
      #ENDIF
#!---- KeyPrimary = %KeyPrimary
      #IF(%KeyAuto = 1)
        #CYCLE
      #ENDIF
#!---- KeyAuto    = %KeyAuto
#!
      #IF(ITEMS(%KeyField) > 1)
        #CYCLE
      #ENDIF
#!
      #FOR(%KeyField)
#!---- KeyField   = %KeyField
        #FIX(%Field,%KeyField)
#!---- Field      = %Field
#!---- FieldType  = %FieldType
        #CASE(%FieldType)
        #OF('LONG')
          #SET(%NFNameAuto, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
        #ENDCASE
      #ENDFOR
#!
      #IF(%NFNameAuto)
#!---- NFNameAuto = %NFNameAuto
        #SET(%AutoIncrementCount,%AutoIncrementCount + 1)
        #SET(%AutoCount, %AutoCount + 1)
#!        #SET(%NFNameAuto, SUB(%KeyAuto, INSTRING(':',%KeyAuto,1,1) + 1 , 50))
        #IF(%UsePrefix='All' OR %PrefixColumns)                                 #! RA.2008.08.11
          #SET(%NFNameAuto, %FilePrefix & '_' & %NFNameAuto)
        #ENDIF
        #!---------------------------------------------!
        #! RA.2007.10.10 - Behave according to option. !
        #!---------------------------------------------!
        #IF(NOT %IgnoreReserved)
          #SET(%SqlWordItem, UPPER(%NFNameAuto))
          #FIND(%SqlWordList, %SqlWordItem)
          #IF(%SqlWordList)
            #ADD(%ReservedFieldList, %FoundAIKeyName & %FilePrefix & ':' & %NFNameAuto)
            #SET(%NFNameAuto, %NFNameAuto & '_')
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDFOR
    #IF(%AutoIncrementCount = 0)
#!-- WARNING: %File(%FilePrefix) has no AUTO-INCREMENT KEY defined.
    #ENDIF
  #ENDIF
#!--
#!-- '%NFilePrefix' = '%NFileName' = '%NFNameAuto'
#!--
CREATE OR REPLACE VIEW list_%NFileName_00 AS
SELECT %NFilePrefix.*
FROM %NFileName AS %NFilePrefix
ORDER BY %NFilePrefix.%NFNameAuto
;
  #IF(%CommentsDB)                                                                              #! RA.2008.08.13
#SET(%NComment, 'LIST (' & %NFilePrefix & ') ' & %FileDescription & ' ORDER BY primary id.')    #! RA.2008.08.12
#SET(%NComment, QUOTE(%NComment))                                                               #! RA.2008.08.12
COMMENT ON VIEW list_%NFileName_00 IS
'%NComment'
;
  #ENDIF                                                                                        #! RA.2088.0813

#ENDFOR
--
-- EOF: %OutViewsName
--
  #CLOSE(%OutViewsName)
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA MARKER - SEARCH FOR ME
#!---------------------------------------------------------------------
#IF(%SQLTable)
  #RUN('NOTEPAD.EXE "' & %OutTableName & '"')
#ENDIF
#IF(%SQLGrant)
  #RUN('NOTEPAD.EXE "' & %OutGrantName & '"')
#ENDIF
#IF(%SQLIndex)
  #RUN('NOTEPAD.EXE "' & %OutIndexName & '"')
#ENDIF
#IF(%SQLRelat)
  #RUN('NOTEPAD.EXE "' & %OutRelatName & '"')
#ENDIF
#IF(%SQLValid)
  #RUN('NOTEPAD.EXE "' & %OutValidName & '"')
#ENDIF
#IF(%SQLTrigr)
  #RUN('NOTEPAD.EXE "' & %OutTrigrName & '"')
#ENDIF
#IF(%SQLViews)
  #RUN('NOTEPAD.EXE "' & %OutViewsName & '"')
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%PGSQLField)
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#! Dump the fields here for a PostgreSQL database back end.           !
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#SET(%InnerGroup, 0)
#SET(%FieldComma, ITEMS(%Field) - 1)
#!
#FOR(%Field)
#! FieldComma='%FieldComma'
  #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
  #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
  #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
  #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
  #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
  #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
#!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
  #!--------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a field is processed. !
  #!--------------------------------------------------------------!
  #! WARNING: The last field can NOT be an ommited field.         !
  #!--------------------------------------------------------------!
  #! And if the last field happens to be and 'END', you will need !
  #! to add a RASQL(END) to the last field before the 'END'. This !
  #! will suppress the last comma. Reality sometimes happens.     !
  #!--------------------------------------------------------------!
  #IF(SUB(%NFieldOpt1,1,1)='N')
    #SET(%FieldComma, %FieldComma - 1)
    #CYCLE
  #ENDIF
#!
  #!------------------------------------------------!
  #! Begin removal of types that are not processed. !
  #!------------------------------------------------!
  #IF(%FieldType='GROUP')
    #SET(%InnerGroup, %InnerGroup + 1)
    #IF(INSTRING('OVER(',%FieldStatement,1,1))
      #!SET(%FieldCount, %FieldCount + 1)                       #! RA.2001.01.15
      #!SET(%FieldComma, %FieldComma - 1)                       #! RA.2001.01.12
    #ENDIF
    #SET(%FieldComma, %FieldComma - 1)                          #! RA.2001.01.12
    #CYCLE
  #ENDIF
  #IF(%FieldType='END')
    #SET(%InnerGroup, %InnerGroup - 1)
    #SET(%FieldComma, %FieldComma - 1)
    #CYCLE
  #ENDIF
  #!------------------------------------------------!
  #! Ended removal of types that are not processed. !
  #!------------------------------------------------!
  #SET(%NFieldType,     '')                                     #! Field type
  #SET(%NFieldName,     '')                                     #! Field name
  #SET(%NFieldTSql,     '')                                     #! Field SQL type
  #SET(%NFieldTDef,     '')                                     #! Field SQL default
  #SET(%NFieldDef,      '')                                     #! Field default
  #SET(%NFieldAuto,     '')                                     #! Field AUTO_INCREMENT
  #SET(%NFieldNN,       '')                                     #! Field NOT NULL
  #SET(%NFieldSize,     0)                                      #! Field decimal size
  #SET(%NFieldDec,      0)                                      #! Field decimal places
  #!
  #!--------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL option identifying SERIAL field type (YES,NO). !
  #!--------------------------------------------------------------------!
  #SET(%nFieldOpt0,'')
  #SET(%nLoc1,INSTRING('ISIDENTITY(',UPPER(%FieldUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
  #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
  #SET(%nFieldOpt0,EXTRACT(%nFieldUser,'ISIDENTITY',1))
  #!
#INSERT(%PGModifyNameField)
  #!
  #SET(%FD1L,%FieldDimension1)                                  #! Name 1 made shorter
  #SET(%FD2L,%FieldDimension2)                                  #! Name 2 made shorter
  #SET(%FD3L,%FieldDimension3)                                  #! Name 3 made shorter
  #SET(%FD4L,%FieldDimension4)                                  #! Name 4 made shorter
  #IF(%FD1L>0)                                                  #! IF we got array field,
-- Found "%NFieldName" that is an ARRAY field --
    #IF(NOT %NoArrayOver)                                       #! AND we got groups,
      #SET(%FieldComma, %FieldComma - 1)                        #! THEN ignore the array
      #CYCLE                                                    #! field since the fields
    #ENDIF                                                      #! in the group are going
  #ENDIF                                                        #! to define the array.
#!
  #SET(%FieldCount, %FieldCount + 1)                            #! Add to field count
#!
  #!----------------------------------------------------------------!
  #! The second option RASQL(,<FieldType>) overrides the field type !
  #! in the dictionary. This allows conversion of data types that   !
  #! have no existance in the dictionary but exist in the SQL.      !
  #!----------------------------------------------------------------!
  #SET(%NFieldType, %FieldType)
  #IF(%NFieldOpt2)
    #SET(%NFieldType, %NFieldOpt2)
  #ENDIF
#!
  #!----------------------------------------------------!
  #! Calculate decimal size and places for some fields. !
  #! Only DECIMAL fields have characters and decimals.  !
  #! Everything else that needs it, is figured out from !
  #! the display mask used.                             !
  #!----------------------------------------------------!
  #! RAS.2001.01.12 - Added additional MySQL types.     !
  #!----------------------------------------------------!
  #SET(%NLeadZero, 0)                                           #! NO leading zero
  #SET(%NFieldSize, %FieldMemoSize)                             #! Field decimal size
  #SET(%NFieldDec, %FieldPlaces)                                #! Field decimal places
  #CASE(%NFieldType)
  #OF  ('DEC')                                                  #! NFieldOpt2: MySQL
  #OROF('NUMERIC')                                              #! NFieldOpt2: MySQL
  #OROF('SREAL')
  #OROF('BFLOAT4')
  #OROF('FLOAT')                                                #! NFieldOpt2: MySQL
  #OROF('FLOAT4')                                               #! NFieldOpt2: MySQL
  #OROF('REAL')
  #OROF('BFLOAT8')
  #OROF('DOUBLE')                                               #! NFieldOpt2: MySQL
  #OROF('FLOAT8')                                               #! NFieldOpt2: MySQL
    #SET(%nLoc1,INSTRING('-',%FieldDisplayPicture,1,1))
    #IF(NOT %nLoc1)
      #SET(%nLoc1,INSTRING('N',UPPER(%FieldDisplayPicture),1,1))
    #ENDIF
    #SET(%nLoc2,INSTRING('.',%FieldDisplayPicture,1,1))
    #SET(%NFieldSize,SUB(%FieldDisplayPicture,(%nLoc1+1),(%nLoc2-1)))
    #SET(%NFieldDec,SUB(%FieldDisplayPicture,(%nLoc2+1),LEN(%FieldDisplayPicture)))
  #!--------------------------------------------------------!
  #! RAS.2001.10.23 - Parse sizes for non-decimal numerics. !
  #! And set the leading zero flag if you find the need.    !
  #!--------------------------------------------------------!
  #OF  ('LONG')
  #OROF('ULONG')
  #OROF('SHORT')
  #OROF('USHORT')
  #OROF('BYTE')
    #SET(%nLoc1,INSTRING('-',%FieldDisplayPicture,1,1))
    #IF(NOT %nLoc1)
      #SET(%nLoc1,INSTRING('_',UPPER(%FieldDisplayPicture),1,1))
    #ENDIF
    #IF(NOT %nLoc1)
      #SET(%nLoc1,INSTRING('N',UPPER(%FieldDisplayPicture),1,1))
    #ENDIF
    #SET(%nLoc2,(LEN(%FieldDisplayPicture) - %nLoc1 + 1))
    #SET(%NFieldSize,SUB(%FieldDisplayPicture,(%nLoc1+1),(%nLoc2-1)))
    #SET(%NLeadZero,INSTRING('N0',UPPER(%FieldDisplayPicture),1,1))
  #ENDCASE
#!-- "%FieldDisplayPicture", %nLoc1, %nLoc2, (%NFieldSize, %NFieldDec), %NLeadZero
  #!------------------------------------------------------!
  #! Deal with the dictionary field type conversion here. !
  #!------------------------------------------------------!
  #CASE(%NFieldType)
  #OF  ('UUID')
    #SET(%NFieldTSQL, 'UUID')
    #SET(%NFieldTDef, 'UUID')                                   #! RA.2008.08.19
  #OF ('UUID1')
    #SET(%NFieldTSQL, 'UUID DEFAULT uuid_generate_v1()')
    #SET(%NFieldTDef, 'UUID')                                   #! RA.2008.08.19
  #OF ('UUID2')
    #SET(%NFieldTSQL, 'UUID DEFAULT uuid_generate_v1mc()')
    #SET(%NFieldTDef, 'UUID')                                   #! RA.2008.08.19
  #OF ('UUID3')
    #SET(%NFieldTSQL, 'UUID DEFAULT uuid_generate_v4()')
    #SET(%NFieldTDef, 'UUID')                                   #! RA.2008.08.19
  #OF  ('BLOB')
    #IF(%VarCharSpecial)                                        #! RA.2007.10.24
      #IF(%FieldMemoSize < %NVarcharLen)
        #SET(%NFieldTSql, 'CHAR(' & %FieldMemoSize & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ELSE
        #SET(%NFieldTSql, 'VARCHAR(' & %FieldMemoSize & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ENDIF
    #ELSE                                                       #! RA.2007.10.24
      #SET(%NFieldTSql, 'VARCHAR(' & %FieldMemoSize & ')' )     #! RA.2007.10.24
      #SET(%NFieldTDef, 'CHAR')                                 #! RA.2007.10.27
    #ENDIF                                                      #! RA.2007.10.24
#!
    #SET(%NFieldTSql, 'BYTEA')                                  #! RA.2008.08.06
    #SET(%NFieldTDef, 'BYTEA')                                  #! RA.2008.08.06
  #OF  ('MEMO')
    #SET(%NFieldTSql, 'TEXT')                                   #! RA.2008.08.06
    #SET(%NFieldTDef, 'TEXT')                                   #! RA.2008.08.06
  #OF  ('STRING')
    #IF(%VarCharSpecial)                                        #! RA.2007.10.24
      #IF(%FieldMemoSize < %NVarcharLen)
        #SET(%NFieldTSql, 'CHAR(' & %FieldMemoSize & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ELSE
        #SET(%NFieldTSql, 'VARCHAR(' & %FieldMemoSize & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ENDIF
    #ELSE                                                       #! RA.2007.10.24
      #SET(%NFieldTSql, 'CHAR(' & %FieldMemoSize & ')' )        #! RA.2007.10.24
      #SET(%NFieldTDef, 'CHAR')                                 #! RA.2007.10.27
    #ENDIF                                                      #! RA.2007.10.24
  #OF  ('CSTRING')
  #OROF('PSTRING')
    #SET(%CStringLen, %FieldMemoSize - 1)
    #IF(%VarCharSpecial)                                        #! RA.2007.10.24
      #IF(%CStringLen < %NVarcharLen)
        #SET(%NFieldTSql, 'CHAR(' & %CStringLen & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ELSE
        #SET(%NFieldTSql, 'VARCHAR(' & %CStringLen & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ENDIF
    #ELSE                                                       #! RA.2007.10.24
      #SET(%NFieldTSql, 'VARCHAR(' & %CStringLen & ')' )        #! RA.2007.10.24
      #SET(%NFieldTDef, 'CHAR')                                 #! RA.2007.10.27
    #ENDIF                                                      #! RA.2007.10.24
  #OF  ('PICTURE')
    #IF(%PicAsChar)
      #SET(%NFieldTSql, 'CHAR(' & %FieldMemoSize & ')' )
      #SET(%NFieldTDef, 'CHAR')                                 #! RA.2007.10.27
    #ELSE
      #SET(%NFieldTSql,'***' & %NFieldType & '***')
    #ENDIF
  #OF  ('LONG')
  #OROF('INT')
  #OROF('INT4')
  #OROF('INTEGER')
      #!------------------------------------------------------!
      #! RA.2008.03.22 - This will have to be further tested. !
      #! It might not be necessary since the SERIAL overide   !
      #! exists at the field level. There are complications.  !
      #!------------------------------------------------------!
      #!#IF(%nFieldOpt0)
      #!  #IF (NOT %UseSerial)
      #!    #SET(%NFieldTSqL, 'SERIAL')
      #!  #ELSE
      #!    #SET(%NFieldTSql, 'INT')
      #!  #ENDIF
      #!#ELSE
        #SET(%NFieldTSql, 'INT')
      #!#ENDIF
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
    #IF(INSTRING('@D',UPPER(%FieldRecordPicture),1,1))
      #SET(%NFieldTSql, 'DATE')
      #SET(%NFieldTDef, 'DATE')                                 #! RA.2007.10.27
    #ENDIF
    #IF(INSTRING('@D',UPPER(%FieldDisplayPicture),1,1))
      #SET(%NFieldTSql, 'DATE')
      #SET(%NFieldTDef, 'DATE')                                 #! RA.2007.10.27
    #ENDIF
    #IF(INSTRING('@T',UPPER(%FieldRecordPicture),1,1))
      #SET(%NFieldTSql, 'TIME')
      #SET(%NFieldTSql, 'TIME WITHOUT TIME ZONE')               #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTDef, 'TIME')                                 #! RA.2007.10.27
    #ENDIF
    #IF(INSTRING('@T',UPPER(%FieldDisplayPicture),1,1))
      #SET(%NFieldTSql, 'TIME')
      #SET(%NFieldTSql, 'TIME WITHOUT TIME ZONE')               #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTDef, 'TIME')                                 #! RA.2007.10.27
    #ENDIF
  #OF  ('BYTE')
  #OROF('UTINYINT')
  #OROF('UINT1')
      #SET(%NFieldTSql, 'SMALLINT: --BYTE-- NOT SUPPORTED CHANGE YOUR DICTIONARY')
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
  #OF  ('SHORT')
  #OROF('SMALLINT')
  #OROF('INT2')
      #SET(%NFieldTSql, 'SMALLINT')
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
  #OF  ('ULONG')
  #OROF('UINT')
  #OROF('UINT4')
      #SET(%NFieldTSql, 'INT')
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
  #OF  ('USHORT')
  #OROF('USMALLINT')
  #OROF('UINT2')
      #SET(%NFieldTSql, 'SMALLINT')
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
  #OF  ('DECIMAL')
  #OROF('PDECIMAL')
  #OROF('DEC')
  #OROF('NUMERIC')
  #!---------------------------------------------------------------------!
  #! RAS.2001.01.09 - IMPORTANT - READ THIS NOW.                         !
  #!---------------------------------------------------------------------!
  #! There is a very big assumption here that your doing a business type !
  #! application so you want to convert binary inaccurate formats to the !
  #! totally binary (financial) accurate format of DECIMAL.              !
  #!---------------------------------------------------------------------!
  #! I get tired of those hours of time spent on penny off errors on     !
  #! financial screens and reports with a calculator to finally come up  !
  #! with the solution of "It is a rounding error!" due to the binary    !
  #! inaccurate format representation of "floats" and "doubles" that     !
  #! are often used to represent money amounts with an actual fractional !
  #! point part for the cents. This happens often in older applications  !
  #! written in languages that did not have a decimal type and with      !
  #! people that did not have experience or knowledge enough to save     !
  #! those financial amounts as whole pennies and adjust their formulas. !
  #!---------------------------------------------------------------------!
  #! If you need the SREAL (4 bytes) and REAL (8 bytes) left alone then  !
  #! move them somewhere else.                                           !
  #!---------------------------------------------------------------------!
  #OROF('SREAL')
  #OROF('BFLOAT4')
  #OROF('FLOAT')
  #OROF('FLOAT4')
  #OROF('REAL')
  #OROF('BFLOAT8')
  #OROF('DOUBLE')
  #OROF('FLOAT8')
  #OROF('DOUBLE PRECISION')                                                     #! RA.2007.07.16 - PostgreSQL
      #SET(%NFieldTSql, 'DECIMAL(' & %NFieldSize & ',' & %NFieldDec & ')')
      #SET(%NFieldTDef, 'NUMBER')                                               #! RA.2007.10.27
  #OF  ('DATE')
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, 'DATE')                                                 #! RA.2007.10.27
  #OF  ('TIME')
      #SET(%NFieldTSql, 'TIME WITHOUT TIME ZONE')
      #SET(%NFieldTDef, 'TIME')                                                 #! RA.2007.10.27
  #OF  ('TIME WITHOUT TIME ZONE')                                               #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTSql, 'TIME WITHOUT TIME ZONE')                               #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTDef, 'TIME')                                                 #! RA.2007.10.27
  #OF  ('TIMETZ')                                                               #! RA.2007.07.16 - PostgreSQL
  #OROF('TIME WITH TIME ZONE')                                                  #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTSql, 'TIME WITH TIME ZONE')
      #SET(%NFieldTDef, 'TIMEZ')                                                #! RA.2007.10.27
  #OF  ('TIMESTAMP')                                                            #! RA.2007.07.16 - PostgreSQL
  #OROF('TIMESTAMP WITHOUT TIME ZONE')                                          #! RA.2007.09.28 - PostgreSQL
  #OROF('TIMESTAMPTZ')                                                          #! RA.2007.07.16 - PostgreSQL
  #OROF('TIMESTAMP WITH TIME ZONE')                                             #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, '')
  #OF  ('SERIAL')                                                               #! RA.2007.07.16 - PostgreSQL
  #OROF('SERIAL4')                                                              #! RA.2007.07.16 - PostgreSQL
  #OROF('BIGSERIAL')                                                            #! RA.2007.07.16 - PostgreSQL
  #OROF('SERIAL8')                                                              #! RA.2007.07.16 - PostgreSQL
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, 'NUMBER')                                               #! RA.2007.10.27
  #OF  ('BIGINT')                                                               #! RA.2007.07.16 - PostgreSQL
  #OROF('INT8')                                                                 #! RA.2007.07.16 - PostgreSQL
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, 'NUMBER')                                               #! RA.2007.10.27
  #OF  ('BOOLEAN')                                                              #! RA.2007.07.16 - PostgreSQL
  #OROF('BOOL')                                                                 #! RA.2007.07.16 - PostgreSQL
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, 'BOOL')                                                 #! RA.2007.10.27
#!
  #ELSE
      #!---------------------------------------------!
      #! This is a field type not currently handled. !
      #! Time to do some more template programming.  !
      #!---------------------------------------------!
      #SET(%NFieldTSql,'***' & %NFieldType & '***')
  #ENDCASE
  #!-----------------------------------------------------------------!
  #! RA.2007.10.27 - Deal with the initial values in the dictionary. !
  #! Basically for string and numerics only.                         !
  #!-----------------------------------------------------------------!
  #SET(%NFieldDef, '')
  #!
  #! RA.2007.10.27 - NOTHING HAS BEEN DONE FROM THE DICTIONARY YET.
  #!
  #!-----------------------------------------------------------------!
  #! RA.2007.10.27 - Override the initial values in the dictionary.  !
  #!-----------------------------------------------------------------!
  #! If the third field option has a 'YES', then we figure on the    !
  #! SQL type definition to default to something coherent.           !
  #! Otherwise, we just default to whatever in in the option.        !
  #!-----------------------------------------------------------------!
  #IF(%NFieldOpt3)
    #IF(SUB(%NFieldOpt3,1,3)='YES')
      #!------------------------------------------!
      #! We got a 'YES', figure out what we got.  !
      #!------------------------------------------!
      #! This is mostly used to default the date  !
      #! and time fields using backend functions. !
      #!------------------------------------------!
      #CASE(%nFieldTDef)
      #OF  ('DATE')
        #SET(%NFieldDef, 'DEFAULT current_date')
      #OF  ('TIMEZ')
        #SET(%NFieldDef, 'DEFAULT current_time')
      #OF  ('TIME')
        #SET(%NFieldDef, 'DEFAULT localtime')
      #OF  ('CHAR')
        #SET(%NFieldDef, 'DEFAULT ''''')
      #OF  ('NUMBER')
        #SET(%NFieldDef, 'DEFAULT 0')
      #OF  ('BOOL')
        #SET(%NFieldDef, 'DEFAULT false')
      #ENDCASE
    #ELSE
      #!--------------------------------------!
      #! We got something other than a 'YES'. !
      #! Default whatever we find there.      !
      #!--------------------------------------!
        #SET(%NFieldDef, 'DEFAULT ' & %NFieldOpt3)
    #ENDIF
  #ENDIF
  #!----------------------------------------------------------!
  #! Deal with field validation parameters in the dictionary. !
  #!----------------------------------------------------------!
#!
#!    #FOR(%FieldScreenControl)
#!-- %FieldID: FSC(%FieldValidation): %FieldScreenControl
#!    #ENDFOR
#!
  #!----------------------------------------------------------!
  #! RA.2007.10.03 - Now we check specifically for NONZERO.   !
  #! If you are validating something, that means it's going   !
  #! to have some value. Mark it as NOT NULL.                 !
  #!----------------------------------------------------------!
  #SET(%NFieldCheck,    '')                                     #! Field CHECK(...) constraint
  #SET(%NFieldCheckOver,'')                                     #! Field CHECK(...) constraint override
  #SET(%NFieldNN,       '')
  #CASE(%FieldValidation)
  #OF  ('NONZERO')
    #!------------------------------------------------------------!
    #! RA.2007.10.31 - Ignore NOT NULL on fields to avoid clarion !
    #! pre-insert of a blank record validation errors by backend. !
    #!------------------------------------------------------------!
    #IF(NOT %IgnoreNotNullFields)
      #SET(%NFieldNN,   'NOT NULL')                             #! RA.2007.10.03 - Specific check
    #ENDIF
  #OF  ('INFILE')
  #OF  ('BOOLEAN')
    #IF(NUMERIC(%FieldFalseValue) AND NUMERIC(%FieldTrueValue))
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' IN (' & %FieldFalseValue & ',' & %FieldTrueValue & '))')
    #ELSE
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' IN (''' & %FieldFalseValue & ''',''' & %FieldTrueValue & '''))')
    #ENDIF
  #OF  ('INRANGE')
    #IF(%FieldRangeLow AND %FieldRangeHigh)
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' BETWEEN ' & %FieldRangeLow & ' AND ' & %FieldRangeHigh & ')')
    #ELSIF(%FieldRangeLow)
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' > ' & %FieldRangeLow & ')')
    #ELSE
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' < ' & %FieldRangeHigh & ')')
    #ENDIF
  #OF  ('INLIST')
    #SET(%ChoiceLine, '')
    #IF(ITEMS(%FieldValues))
      #SET(%ChoiceComma,ITEMS(%FieldValues) - 1)
      #FOR(%FieldValues)
        #CASE(%NFieldTDef)
        #OF('NUMBER')
          #SET(%ChoiceLine,%ChoiceLine & %FieldValues)
        #ELSE
          #SET(%ChoiceLine,%ChoiceLine & '''' & %FieldValues & '''')
        #ENDCASE
        #IF(%ChoiceComma > 0)
          #SET(%ChoiceLine,%ChoiceLine & ',')
          #SET(%ChoiceComma,%ChoiceComma - 1)
        #ENDIF
      #ENDFOR
    #ELSIF(ITEMS(%FieldChoices))
      #SET(%ChoiceComma,ITEMS(%FieldChoices) - 1)
      #FOR(%FieldChoices)
        #CASE(%NFieldTDef)
        #OF('NUMBER')
          #SET(%ChoiceLine,%ChoiceLine & %FieldChoices)
        #ELSE
          #SET(%ChoiceLine,%ChoiceLine & '''' & %FieldChoices & '''')
        #ENDCASE
        #IF(%ChoiceComma > 0)
          #SET(%ChoiceLine,%ChoiceLine & ',')
          #SET(%ChoiceComma,%ChoiceComma - 1)
        #ENDIF
      #ENDFOR
    #ENDIF
    #IF(%ChoiceLine)
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' IN (' & %ChoiceLine & '))')
    #ENDIF
  #ENDCASE
  #!-------------------------------------------------------------------------!
  #! RA.2008.06.24 - Is used as an override even if you have something else. !
  #! RA.2008.06.20 - Fixed RASQLCHECK option to handle IN ('','','','').     !
  #! RA.2008.03.14 - Added RASQLCHECK option to template at the field level. !
  #!-------------------------------------------------------------------------!
  #!SET(%nLoc1,INSTRING('RASQLCHECK(',%FieldUserOptions,1,1))
  #!SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
  #!SET(%nFieldUser,SUB(%FieldUserOptions,%nLoc1,%nLoc2))
  #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLCHECK'))
  #SET(%NFieldCheckOver,EXTRACT(%NFieldUser,'RASQLCHECK',1))
  #IF(%NFieldCheckOver)
    #SET(%NFieldCheck, 'CHECK(' & %NFieldCheckOver & ')')
  #ENDIF
#!-- %NFieldUser, %NFieldCheck
#!-- %NFieldUser, %NFieldCheckOver
#!
  #ADD(%FieldTable,   %FieldID)
#!
  #!---------------------------------------------------------!
  #! RA.2007.10.27 - Ignore making NOT NULL every key field. !
  #!---------------------------------------------------------!
  #IF(NOT %IgnoreNotNullKeys)
    #SET(%IFieldInKey,%Field)                                   #! Field Name
    #FIND(%LFieldInKey,%IFieldInKey)                            #! Field In Key list lookup
    #IF(%LFieldInKey)                                           #! Found? Yes, part of key.
      #SET(%NFieldNN,   'NOT NULL')                             #! Primary keys fields can
    #ENDIF                                                      #! not be NULL. Make it so!
  #ENDIF
#!
  #!------------------------------------------------------------------!
  #! RA.2008.07.01 - Make the transition to BIGINT's easier when they !
  #! become part of the clarion dictionary. Test feasibility.         !
  #!------------------------------------------------------------------!
  #IF(%MakeIntBigint)
    #IF(%NFieldTSql='INT')
      #SET(%IFieldInKey,%Field)                                 #! Field Name
      #FIND(%LFieldInKey,%IFieldInKey)                          #! Field In Key list lookup
      #IF(%LFieldInKey)                                         #! Found? Yes, part of key.
        #SET(%NFieldTSql,'BIGINT')                              #! Chances are this is a relation field
      #ENDIF                                                    #! for a SERIAL. Make it a BIGINT.
    #ENDIF
  #ENDIF
#!
  #!----------------------------------------------------------------------------!
  #!----------------------------------------------------------------------------!
  #! This is the actual SQL field data line creation.                           !
  #!----------------------------------------------------------------------------!
  #!----------------------------------------------------------------------------!
#!
  #IF(%FD1L>0)                                                  #! We GOT array field
  #!----------------------------------------------------------------------------!
  #! If we got an array field at this point, we do not have arrays over groups. !
  #! We have simple array fields and must add additional fields to the table.   !
  #!----------------------------------------------------------------------------!
    #SET(%FldArray,'')                                          #! Clear created name
    #SET(%FD1S,'')                                              #! Number dimension 1
    #SET(%FD2S,'')                                              #! Number dimension 2
    #SET(%FD3S,'')                                              #! Number dimension 3
    #SET(%FD4S,'')                                              #! Number dimension 4
    #!
    #SET(%DimCount,1)                                           #! Got dimension 1
    #IF(%FD2L>0)                                                #! Dimension 2?
      #SET(%DimCount,%DimCount+1)                               #! Got dimension 2
      #IF(%FD3L>0)                                              #! Dimension 3?
        #SET(%DimCount,%DimCount+1)                             #! Got dimension 3
        #IF(%FD4L>0)                                            #! Dimension 4?
          #SET(%DimCount,%DimCount+1)                           #! Got dimension 4
        #ENDIF                                                  #! Dimension 4?
      #ENDIF                                                    #! Dimension 3?
    #ENDIF                                                      #! Dimension 2?
    #!
    #CASE(%DimCount)                                            #! Logic on dimension
    #OF(1)                                                      #! A 1 dimension array
      #LOOP,FOR(%FD1I,1,%FD1L)
        #SET(%FD1S,'_' & %FD1I)
        #SET(%FldArray,%NFieldName & %FD1S)
        #SET(%NFieldLine,   '')
        #SET(%NFieldLine,   %NFieldLine & ''  & %FldArray)
        #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)
        #IF(%NFieldAuto)
          #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)
        #ENDIF
        #IF(%NFieldNN)
          #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)
        #ENDIF
        #IF(%NFieldDef)
          #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)
        #ENDIF
        #IF(%NFieldCheck)
          #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)
        #ENDIF
        #IF(%FD1I=%FD1L)                                        #! Last field?
#!-- %FldArray
          #IF(%FieldComma > 0)
            #SET(%FieldComma, %FieldComma - 1)
            #IF(SUB(%NFieldOpt1,1,1)='E')                       #! RASQL(END)
  %NFieldLine
            #ELSE
  %NFieldLine ,
            #ENDIF
          #ELSE
  %NFieldLine
          #ENDIF
        #ELSE                                                   #! Not last field
  %NFieldLine ,
        #ENDIF                                                  #! Just dump stuff
      #ENDLOOP
    #OF(2)                                                      #! A 2 dimension array
      #LOOP,FOR(%FD1I,1,%FD1L)
        #SET(%FD1S,'_' & %FD1I)
        #LOOP,FOR(%FD2I,1,%FD2L)
          #SET(%FD2S,'_' & %FD2I)
          #SET(%FldArray,%NFieldName & %FD1S & %FD2S)
          #SET(%NFieldLine,   '')
          #SET(%NFieldLine,   %NFieldLine & ''  & %FldArray)
          #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)
          #IF(%NFieldAuto)
            #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)
          #ENDIF
          #IF(%NFieldNN)
            #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)
          #ENDIF
          #IF(%NFieldDef)
            #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)
          #ENDIF
          #IF(%NFieldCheck)
            #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)
          #ENDIF
          #IF((%FD1I=%FD1L)AND(%FD2I=%FD2L))                    #! Last field?
#!-- %FldArray
            #IF(%FieldComma > 0)
              #SET(%FieldComma, %FieldComma - 1)
              #IF(SUB(%NFieldOpt1,1,1)='E')                     #! RASQL(END)
  %NFieldLine
              #ELSE
  %NFieldLine ,
              #ENDIF
            #ELSE
  %NFieldLine
            #ENDIF
          #ELSE                                                 #! Not last field
  %NFieldLine ,
          #ENDIF                                                #! Just dump stuff
        #ENDLOOP
      #ENDLOOP
    #OF(3)                                                      #! A 3 dimension array
      #LOOP,FOR(%FD1I,1,%FD1L)
        #SET(%FD1S,'_' & %FD1I)
        #LOOP,FOR(%FD2I,1,%FD2L)
          #SET(%FD2S,'_' & %FD2I)
          #LOOP,FOR(%FD3I,1,%FD3L)
            #SET(%FD3S,'_' & %FD3I)
            #SET(%FldArray,%NFieldName & %FD1S & %FD2S & %FD3S)
            #SET(%NFieldLine,   '')
            #SET(%NFieldLine,   %NFieldLine & ''  & %FldArray)
            #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)
            #IF(%NFieldAuto)
              #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)
            #ENDIF
            #IF(%NFieldNN)
              #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)
            #ENDIF
            #IF(%NFieldDef)
              #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)
            #ENDIF
            #IF(%NFieldCheck)
              #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)
            #ENDIF
            #IF((%FD1I=%FD1L)AND(%FD2I=%FD2L)AND(%FD3I=%FD3L))  #! Last field?
#!-- %FldArray
              #IF(%FieldComma > 0)
                #SET(%FieldComma, %FieldComma - 1)
                #IF(SUB(%NFieldOpt1,1,1)='E')                   #! RASQL(END)
  %NFieldLine
                #ELSE
  %NFieldLine ,
                #ENDIF
              #ELSE
  %NFieldLine
              #ENDIF
            #ELSE                                               #! Not last field
  %NFieldLine ,
            #ENDIF                                              #! Just dump stuff
          #ENDLOOP
        #ENDLOOP
      #ENDLOOP
    #OF(4)                                                      #! A 4 dimension array
      #LOOP,FOR(%FD1I,1,%FD1L)
        #SET(%FD1S,'_' & %FD1I)
        #LOOP,FOR(%FD2I,1,%FD2L)
          #SET(%FD2S,'_' & %FD2I)
          #LOOP,FOR(%FD3I,1,%FD3L)
            #SET(%FD3S,'_' & %FD3I)
            #LOOP,FOR(%FD4I,1,%FD4L)
              #SET(%FD4S,'_' & %FD4I)
              #SET(%FldArray,%NFieldName & %FD1S & %FD2S & %FD3S & %FD4S)
              #SET(%NFieldLine,   '')
              #SET(%NFieldLine,   %NFieldLine & ''  & %FldArray)
              #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)
              #IF(%NFieldAuto)
                #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)
              #ENDIF
              #IF(%NFieldNN)
                #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)
              #ENDIF
              #IF(%NFieldDef)
                #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)
              #ENDIF
              #IF(%NFieldCheck)
                #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)
              #ENDIF
              #IF((%FD1I=%FD1L)AND(%FD2I=%FD2L)AND(%FD3I=%FD3L)AND(%FD4I=%FD4L)) #! Last field?
#!-- %FldArray
                #IF(%FieldComma > 0)
                  #SET(%FieldComma, %FieldComma - 1)
                  #IF(SUB(%NFieldOpt1,1,1)='E')                 #! RASQL(END)
  %NFieldLine
                  #ELSE
  %NFieldLine ,
                  #ENDIF
                #ELSE
  %NFieldLine
                #ENDIF
              #ELSE                                             #! Not last field
  %NFieldLine ,
              #ENDIF                                            #! Just dump stuff
            #ENDLOOP
          #ENDLOOP
        #ENDLOOP
      #ENDLOOP
    #ENDCASE
#!
  #ELSE                                                         #! We GOT normal field
  #!----------------------------------------------------------------------------!
  #! This processes the normal fields that are NOT an array.                    !
  #!----------------------------------------------------------------------------!
    #SET(%NFieldLine,   '')
    #SET(%NFieldLine,   %NFieldLine & ''  & %NFieldName)        #! Field Name
    #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)        #! SQL Type
    #IF(%NFieldAuto)
      #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)        #! AUTO_INCREMENT
    #ENDIF
    #IF(%NFieldNN)
      #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)          #! NOT NULL
    #ENDIF
    #IF(%NFieldDef)
      #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)         #! DEFAULT
    #ENDIF
    #IF(%NFieldCheck)
      #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)       #! CHECK(...)
    #ENDIF
    #!
    #IF(%FieldComma > 0)
      #SET(%FieldComma, %FieldComma - 1)
      #IF(SUB(%NFieldOpt1,1,1)='E')                             #! RASQL(END)
  %NFieldLine
      #ELSE
  %NFieldLine ,
      #ENDIF
    #ELSE
  %NFieldLine
    #ENDIF
  #ENDIF
#!
  #!----------------------------------------------------------------------------!
  #!----------------------------------------------------------------------------!
#!
#ENDFOR
#!---------------------------------------------------------------------
#GROUP(%PGSQLFieldEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%PGSQLFieldComment)
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#FOR(%Field)
  #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
  #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
  #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
  #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
  #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
  #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
#!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
  #!--------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a field is processed. !
  #!--------------------------------------------------------------!
  #IF(SUB(%NFieldOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #!------------------------------------------------!
  #! Begin removal of types that are not processed. !
  #!------------------------------------------------!
  #IF(%FieldType='GROUP')
    #CYCLE
  #ENDIF
  #IF(%FieldType='END')
     #CYCLE
  #ENDIF
#!
#INSERT(%PGModifyNameField)
#!
#SET(%NComment, QUOTE(%FieldDescription))                       #! RA.2008.08.12
COMMENT ON COLUMN %NFileName.%NFieldName IS
'%NComment'
;
#ENDFOR
  #ENDIF                                                        #! RA.2008.08.13
#!---------------------------------------------------------------------
#GROUP(%PGSQLFieldCommentEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2010.09.25 - Added the SET for %NRelateSchema1 which was missing.
#! RA.2010.09.25 - Enhanced to handle external names
#! RA.2008.07.19 - Added logic to handle %NFilePrefix (for %FilePrefix)
#! RA.2007.07.14 - The options to modify a column, table, and key name
#! became real complicated in postgreSQL so I group them into one place
#! and inserted them where needed.
#!---------------------------------------------------------------------
#GROUP(%PGModifyNameTable)
  #SET(%NFileName,%File)
  #SET(%NFilePrefix,LOWER(%FilePrefix))                         #! RA.2008.07.19
  #!
#!-- PGModifyNameTable (01): NFileName="%NFileName", NFilePrefix="%NFilePrefix"
  #!--------------------------------------!
  #! RA.2010.09.25 - EXTERNAL table name. !
  #!--------------------------------------!
  #IF(%UseExtTableName AND %NFileOpt2)                          #! RA.2010.09.25
    #SET(%NFileName,LOWER(%NFileOpt2))                          #! RA.2010.09.25
  #ENDIF                                                        #! RA.2010.09.25
  #!--------------------------------------!
  #!--------------------------------------!
#!-- PGModifyNameTable (02): NFileName="%NFileName", NFilePrefix="%NFilePrefix"
#!--
  #!
  #SET(%NRelateSchema1, EXTRACT(%FileUserOptions, 'SCHEMA', 2)) #! RA.2010.09.25
  #!
  #IF(%UsePrefix='All' OR %PrefixTables)                        #! RA.2008.08.11
    #SET(%NFileName,%NFilePrefix & '_' & %File)                 #! RA.2008.07.19
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NFileName))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundFileName & %NFileName)
      #SET(%NFileName, %NFileName & '_')
    #ENDIF
  #ENDIF
  #IF(%UseSchemaName)
    #SET(%NFileName, %SchemaName & '.' & %NFileName)
  #ENDIF
  #! Added check to see if lowercase wanted
  #IF(%UseLowerCase)                                            #! MAG 02.21.08
    #SET(%NFileName,Lower(%NFileName))                          #! MAG 02.21.08
    #SET(%NFilePrefix,LOWER(%NFilePrefix))                      #! RA.2008.07.19
    #SET(%NFNameAuto,LOWER(%NFNameAuto))                        #! RA.2008.07.19
  #ENDIF                                                        #! MAG 02.21.08
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%PGModifyNameField)
#!$$------------------------------------------------!
#!$$ DEJ.2007.05.08 - Use External Field Name
#!$$------------------------------------------------!
  #IF(%UseExtFieldName AND %FieldName)                                                  #!$$ Using External Field Names
    #IF(%UseExtFieldQuote)                                                              #!$$ Generate External Name w/ Quotes
      #SET(%NFieldName, %FieldName)                                                     #!$$
    #ELSE                                                                               #!$$
      #SET(%NFieldName, SUB(%FieldName,2,LEN(%FieldName)-2))                            #!$$ Remove Quotes in External Name
    #ENDIF                                                                              #!$$
  #ELSE                                                                                 #!$$
    #SET(%NFieldName, %FieldID)                                                         #!$$ Use Field Label
  #ENDIF                                                                                #!$$
#!$$  #SET(%NFieldName, %FieldID)                                                       #! Field Name
#!$$------------------------------------------------!
#!$$ End of Use External Field Name
#!$$------------------------------------------------!
  #IF(%UsePrefix='All' OR %PrefixColumns)                                               #! RA.2008.08.11
    #SET(%NFieldName, %FilePrefix & '_' & %FieldID)                                     #! RA.2001.10.24
  #ENDIF                                                                                #! RA.2001.12.01
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NFieldName))                                              #! Set up search of
    #FIND(%SqlWordList, %SqlWordItem)                                                   #! SQL reserved words
    #IF(%SqlWordList)                                                                   #! Found? Yes! We add
      #ADD(%ReservedFieldList, %FoundFileField & %FilePrefix & ':' & %NFieldName)
      #SET(%NFieldName, %NFieldName & '_')                                              #! trailing underscore
    #ENDIF                                                                              #! to get it through
  #ENDIF
  #! Added check to see if lowercase wanted
  #IF(%UseLowerCase)                                       #! MAG 02.21.08
    #Set(%NFieldName, Lower(%NFieldName))                  #! MAG 02.21.08
  #ENDIF                                                   #! MAG 02.21.08
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2010.09.25 - Enhanced to handle external names
#!---------------------------------------------------------------------
#GROUP(%PGModifyNameKey00)
  #SET(%NKeyName,%KeyID)
  #!------------------------------------!
  #! RA.2010.09.25 - EXTERNAL key name. !
  #!------------------------------------!
  #IF(%UseExtKeyName AND %KeyName)                                                      #! RA.2010.09.25
    #IF(%UseExtKeyQuote)                                                                #! RA.2010.09.25 - Generate External Name w/ Quotes
      #SET(%NKeyName, %KeyName)                                                         #! RA.2010.09.25
    #ELSE                                                                               #! RA.2010.09.25
      #SET(%NKeyName, SUB(%KeyName,2,LEN(%KeyName)-2))                                  #! RA.2010.09.25 - Remove Quotes in External Name
    #ENDIF                                                                              #! RA.2010.09.25
  #ENDIF                                                                                #! RA.2010.09.25
  #!------------------------------------!
  #!------------------------------------!
  #! #IF(%UsePrefix='All')                                                              #! dgh added additional test
  #IF(%UsePrefix='All' OR %PrefixKeys)                                                  #! dgh
    #SET(%NKeyName,%FilePrefix & '_' & %KeyID)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NKeyName))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundKeyName & %FilePrefix & ':' & %NKeyName)
      #SET(%NKeyName, %NKeyName & '_')
    #ENDIF
  #ENDIF
  #IF(%UseLowerCase)                                        #! MAG 02.21.08
    #SET(%NKeyName, Lower(%NKeyName))                       #! MAG 02.21.08
  #ENDIF                                                    #! MAG 02.21.08
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2010.09.25 - Enhanced to handle external names
#!---------------------------------------------------------------------
#GROUP(%PGModifyNameKey01)
  #SET(%NKeyField1, SUB(%FileKey, INSTRING(':',%FileKey,1,1) + 1 , 50))
#!-- PGModifyNameKey01 (01): NFileName="%NFileName" (%File), NKeyField1="%NKeyField1" (%FileKey)
  #!------------------------------------!
  #! RA.2010.09.25 - EXTERNAL key name. !
  #!------------------------------------!
  #FIX(%Key,%FileKey)                                                                   #! RA.2010.09.25
  #IF(%UseExtKeyName AND %KeyName)                                                      #! RA.2010.09.25
    #IF(%UseExtKeyQuote)                                                                #! RA.2010.09.25 - Generate External Name w/ Quotes
      #SET(%NKeyField1, %KeyName)                                                       #! RA.2010.09.25
    #ELSE                                                                               #! RA.2010.09.25
      #SET(%NKeyField1, SUB(%KeyName,2,LEN(%KeyName)-2))                                #! RA.2010.09.25 - Remove Quotes in External Name
    #ENDIF                                                                              #! RA.2010.09.25
  #ENDIF                                                                                #! RA.2010.09.25
  #!------------------------------------!
  #!------------------------------------!
#!-- PGModifyNameKey01 (02): NFileName="%NFileName" (%File), NKeyField1="%NKeyField1" (%FileKey)
  #IF(NOT %NKeyField1)
    #SET(%NKeyField1, SUB(%RelationKey, INSTRING(':',%RelationKey,1,1) + 1 , 50))
#!-- PGModifyNameKey01 (03): NRelateFile="%NRelateFile" (%Relation), NKeyField1="%NKeyField1" (%RelationKey)
    #!------------------------------------!
    #! RA.2010.09.25 - EXTERNAL key name. !
    #!------------------------------------!
    #FIND(%Key,%RelationKey)                                                            #! RA.2010.09.25
    #IF(%UseExtKeyName AND %KeyName)                                                    #! RA.2010.09.25
      #IF(%UseExtKeyQuote)                                                              #! RA.2010.09.25 - Generate External Name w/ Quotes
        #SET(%NKeyField1, %KeyName)                                                     #! RA.2010.09.25
      #ELSE                                                                             #! RA.2010.09.25
        #SET(%NKeyField1, SUB(%KeyName,2,LEN(%KeyName)-2))                              #! RA.2010.09.25 - Remove Quotes in External Name
      #ENDIF                                                                            #! RA.2010.09.25
    #ENDIF                                                                              #! RA.2010.09.25
    #FIX(%File,%ProcFile)                                                               #! RA.2010.09.25
    #FIND(%Relation,%NRelateSave)                                                       #! RA.2010.09.25
    #!------------------------------------!
    #!------------------------------------!
#!-- PGModifyNameKey01 (04): NRelateFile="%NRelateFile" (%Relation), NKeyField1="%NKeyField1" (%RelationKey)
  #ELSE
    #!----------------------------------------------------------!
    #! RA.2007.07.17 - Additional logic to give both key names. !
    #!----------------------------------------------------------!
    #SET(%NKeyField2, SUB(%RelationKey, INSTRING(':',%RelationKey,1,1) + 1 , 50))
#!-- PGModifyNameKey01 (05): NRelateFile="%NRelateFile" (%Relation), NKeyField2="%NKeyField2" (%RelationKey)
    #!------------------------------------!
    #! RA.2010.09.25 - EXTERNAL key name. !
    #!------------------------------------!
    #FIND(%Key,%RelationKey)                                                            #! RA.2010.09.25
    #IF(%UseExtKeyName AND %KeyName)                                                    #! RA.2010.09.25
      #IF(%UseExtKeyQuote)                                                              #! RA.2010.09.25 - Generate External Name w/ Quotes
        #SET(%NKeyField2, %KeyName)                                                     #! RA.2010.09.25
      #ELSE                                                                             #! RA.2010.09.25
        #SET(%NKeyField2, SUB(%KeyName,2,LEN(%KeyName)-2))                              #! RA.2010.09.25 - Remove Quotes in External Name
      #ENDIF                                                                            #! RA.2010.09.25
    #ENDIF                                                                              #! RA.2010.09.25
    #FIX(%File,%ProcFile)                                                               #! RA.2010.09.25
    #FIND(%Relation,%NRelateSave)                                                       #! RA.2010.09.25
    #!------------------------------------!
    #!------------------------------------!
#!-- PGModifyNameKey01 (06): NRelateFile="%NRelateFile" (%Relation), NKeyField2="%NKeyField2" (%RelationKey)
    #!
    #!----------------------------------------------------------------------!
    #! RA.2010.09.25 - The statement bellow makes the "%NKeyField" too big. !
    #! So I adjusted the item to become shorter and go through.             !
    #!----------------------------------------------------------------------!
    #SET(%NKeyField, %NKeyField1 & '_to_' & %NKeyField2)                                #! BECOMES TOO BIG
    #SET(%NKeyField, LOWER(%FilePrefix) & '_' & LOWER(SUB(%FileKey, INSTRING(':',%FileKey,1,1) + 1 , 50)) & '_to_' & LOWER(%RelationPrefix) & '_' & LOWER(SUB(%RelationKey, INSTRING(':',%RelationKey,1,1) + 1 , 50)))
    #!
#!--
#!-- PGModifyNameKey01 (11): NFileName="%NFileName" (%File), NKeyField1="%NKeyField1" (%FileKey)
#!-- PGModifyNameKey01 (12): NRelateFile="%NRelateFile" (%Relation), NKeyField2="%NKeyField2" (%RelationKey)
#!-- PGModifyNameKey01 (13): NKeyField="%NKeyField"
  #ENDIF
#!
  #IF(%UsePrefix='All' OR %PrefixRelations)                 #! RA.2008.08.11
    #SET(%NKeyField, %FilePrefix & '_' & %NKeyField1 & '_to_' & %RelationPrefix & '_' & %NKeyField2)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NKeyField))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundKeyField & %FilePrefix & ':' & %NKeyField)
      #SET(%NKeyField, %NKeyField & '_')
    #ENDIF
  #ENDIF
  #IF(%UseLowerCase)                                        #! MAG 02.21.08
    #SET(%NKeyField, Lower(%NKeyField))                     #! MAG 02.21.08
  #ENDIF                                                    #! MAG 02.21.08
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2010.09.25 - Get the "%NRelateSchema2" value, was missing before.
#! RA.2010.09.25 - Enhanced to handle external names
#!---------------------------------------------------------------------
#GROUP(%PGModifyNameRelTable)
  #SET(%NRelateFile, %Relation)
  #IF(%RelationAlias)                                               #! RA.2007.10.21 - Relation to ALIAS are
    #SET(%NRelateFile, %RelationAlias)                              #! RA.2007.10.21 - replaced with the real file name
  #ENDIF                                                            #! RA.2007.10.21 - Aliases do not exist in backend
  #!
#!-- PGModifyNameRelTable (00): NFileName="%NFileName", File="%File", NFilePrefix="%NFilePrefix"
#!-- PGModifyNameRelTable (01): NRelateFile="%NRelateFile", Relation="%Relation", RelationAlias="%RelationAlias", NRelateSave="%NRelateSave"
  #FIX(%File,%NRelateFile)                                                             #! RA.2010.09.25
  #SET(%NRelateSchema2, EXTRACT(%FileUserOptions, 'SCHEMA', 2))                        #! RA.2010.09.25
  #!--------------------------------------!
  #! RA.2010.09.25 - EXTERNAL table name. !
  #!--------------------------------------!
  #FIX(%File,%NRelateFile)                                                             #! RA.2010.09.25 - Need this to get the options...
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!--------------------------------------!
  #IF(%UseExtTableName AND %NFileOpt2)                                                 #! RA.2010.09.25
    #SET(%NRelateFile,LOWER(%NFileOpt2))                                               #! RA.2010.09.25
  #ENDIF                                                                               #! RA.2010.09.25
  #!--------------------------------------!
  #!--------------------------------------!
  #FIX(%File,%ProcFile)                                                                #! RA.2010.09.25
  #FIND(%Relation,%NRelateSave)                                                        #! RA.2010.09.25
#!-- PGModifyNameRelTable (02): NRelateFile="%NRelateFile", Relation="%Relation", RelationAlias="%RelationAlias", NRelateSave="%NRelateSave"
#!--
  #!
  #IF(%UsePrefix='All' OR %PrefixTables)                            #! RA.2008.08.11
    #SET(%NRelateFile, %RelationPrefix & '_' & %Relation)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NRelateFile))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundRelatedName & %NRelateFile)
      #SET(%NRelateFile, %NRelateFile & '_')
    #ENDIF
  #ENDIF
  #IF(%UseSchemaName)
    #SET(%NRelateFile, %SchemaName & '.' & %NRelateFile)
  #ENDIF
  #IF(%UseLowerCase)                                        #! MAG 02.21.08
    #SET(%NRelateFile, Lower(%NRelateFile))                 #! MAG 02.21.08
  #ENDIF                                                    #! MAG 02.21.08
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2010.09.25 - Modify logic to handle EXTERNAL names.
#!---------------------------------------------------------------------
#GROUP(%PGModifyNameRelField1)
  #!--------------------------------------!
  #! RA.2010.09.25 - EXTERNAL field name. !
  #!--------------------------------------!
#!-- PGModifyNameRelField1 (01): NRelateField1="%NRelateField1" (%FileKeyField)
  #FIX(%Field,%FileKeyField)                                                            #! RA.2010.09.25
  #IF(%UseExtFieldName AND %FieldName)                                                  #! RA.2010.09.25
    #IF(%UseExtFieldQuote)                                                              #! RA.2010.09.25 - Generate External Name w/ Quotes
      #SET(%NRelateField1, %FieldName)                                                  #! RA.2010.09.25
    #ELSE                                                                               #! RA.2010.09.25
      #SET(%NRelateField1, SUB(%FieldName,2,LEN(%FieldName)-2))                         #! RA.2010.09.25 - Remove Quotes in External Name
    #ENDIF                                                                              #! RA.2010.09.25
  #ENDIF                                                                                #! RA.2010.09.25
#!-- PGModifyNameRelField1 (02): NRelateField1="%NRelateField1" (%FileKeyField)
  #!------------------------------------!
  #!------------------------------------!
  #IF(%UsePrefix='All' OR %PrefixColumns)                   #! RA.2008.08.11
    #SET(%NRelateField1, %FilePrefix & '_' & %NRelateField1)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NRelateField1))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundRelatedField & %FilePrefix & ':' & %NRelateField1)
      #SET(%NRelateField1, %NRelateField1 & '_')
    #ENDIF
  #ENDIF
  #IF(%UseLowerCase)                                       #! MAG 02.21.08
    #SET(%NRelateField1, lower(%NRelateField1))            #! MAG 02.21.08
  #ENDIF                                                   #! MAG 02.21.08
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%PGModifyNameRelField2)
  #!--------------------------------------!
  #! RA.2010.09.25 - EXTERNAL field name. !
  #!--------------------------------------!
#!-- PGModifyNameRelField2 (01): NRelateField1="%NRelateField2" (%FileKeyFieldLink)
  #FIND(%Field,%FileKeyFieldLink)                                                       #! RA.2010.09.25
  #IF(%UseExtFieldName AND %FieldName)                                                  #! RA.2010.09.25
    #IF(%UseExtFieldQuote)                                                              #! RA.2010.09.25 - Generate External Name w/ Quotes
      #SET(%NRelateField2, %FieldName)                                                  #! RA.2010.09.25
    #ELSE                                                                               #! RA.2010.09.25
      #SET(%NRelateField2, SUB(%FieldName,2,LEN(%FieldName)-2))                         #! RA.2010.09.25 - Remove Quotes in External Name
    #ENDIF                                                                              #! RA.2010.09.25
  #ENDIF                                                                                #! RA.2010.09.25
  #!
  #FIX(%File,%ProcFile)                                                                 #! RA.2010.09.25
  #FIND(%Relation,%NRelateSave)                                                         #! RA.2010.09.25
  #FIND(%Field,%FileKeyFieldSave)                                                       #! RA.2010.09.25
#!-- PGModifyNameRelField2 (02): NRelateField1="%NRelateField2" (%FileKeyFieldLink)
  #!------------------------------------!
  #!------------------------------------!
  #IF(%UsePrefix='All' OR %PrefixColumns)               #! RA.2008.08.11
    #SET(%NRelateField2, %RelationPrefix & '_' & %NRelateField2)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NRelateField2))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundRelatedField & %RelationPrefix & ':' & %NRelateField2)
      #SET(%NRelateField2, %NRelateField2 & '_')
    #ENDIF
  #ENDIF
  #IF(%UseLowerCase)                                    #! MAG 02.21.08
    #SET(%NRelateField2, lower(%NRelateField2))         #! MAG 02.21.08
  #ENDIF                                                #! MAG 02.21.08
#!---------------------------------------------------------------------
#GROUP(%PGModifyNameEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2007.10.03 - DOES NOT WORK - DO NOT USE
#! RA.2007.10.03 - The file preprocess was the same in several places
#! So I made it into a group to make sure the code was consistant.
#! This DOES NOT work. I get ALIASES when I insert this group.
#!---------------------------------------------------------------------
#GROUP(%PGFilePreProcess)
  #!----------------------------------------------------------------!
  #! RAS.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.   !
  #!----------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RAS.2001.12.01
    #CYCLE                                                      #! RAS.2001.12.01
  #ENDIF                                                        #! RAS.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!---------------------------------------------------------------------
#GROUP(%PGFilePreProcessEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%Dct2POSTGRESQLEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
