#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! File Name:   D2UTIL.tpw
#! Purpose:     Utilites to deal with dictionaries
#! Author:      Copyright © 1999-2011 by Roberto Artigas Jr
#!              All rights reserved world wide.
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#UTILITY (UTIL_DictionaryFiles, '2002.06.02: [DCT2SQL-UTIL] Print Dictionary Files Overview'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2002.06.02   Roberto Artigas Jr
#!  *   Now the utility pops up a wordpad text file rather than printing
#!      directly to the printer. Much nicer to preview before you print.
#!--------------------------------------------------------------------
#SHEET
  #TAB ('Dictionary Print Wizard')
    #DISPLAY('The Dictionary Overview Print Utility.')
    #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will generate a report of the contents of your current dictionary.')
    #DISPLAY('To specify how you want the report constructed, click on the Next button.')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), FINISH(1)
    #DISPLAY('The dictionary report wizard creates a text file, which is then sent to your printer.')
    #DISPLAY('')
    #DISPLAY('You can, if you wish, have this wizard delete the file when it''s done, or you can keep the file')
    #DISPLAY('for later use.')
    #DISPLAY('')
    #PROMPT ('What do you want to do with the file?', OPTION), %RetainFile
    #PROMPT ('I don''t want it. Remove the file after printing.', RADIO)
    #PROMPT ('I might need it. Keep the file around.', RADIO)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), WHERE(%RetainFile = 'I might need it. Keep the file around.'), FINISH(1)
    #PROMPT ('What name do you want the text file to have?', OPTION), %WhatName
    #PROMPT ('Use the dictionary name, with a .TXT extension.', RADIO)
    #PROMPT ('Let me supply my own file name.', RADIO)
    #ENABLE (%WhatName = 'Let me supply my own file name.')
      #PROMPT ('Please enter the name of the text file to be generated.', @S100), %NewName
    #ENDENABLE
    #PROMPT ('Don''t print this report automatically. I''ll print it from the text file later.', CHECK), %DoNotPrint, AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Reported Files'), FINISH(1)
    #DISPLAY('You can report on each file in your dictionary, or you can select individual files to report on.')
    #DISPLAY('')
    #PROMPT ('Report on all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Reported Files'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('File Selection', FROM (%File)), %DictionaryReportFileSelection, INLINE, SELECTION('File Selection')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Finally...')
    #DISPLAY ('This concludes the dictionary report wizard.')
    #DISPLAY ('Click on the Finish button to generate the text file.')
  #ENDTAB
#ENDSHEET
#!#BOXED('Hide')
#!  #BUTTON('Processed Files'),MULTI(%DoTheseFiles, %DoFilePrefix & ' ' & %DoFileName & ' ' & %DoFile),INLINE
#!    #PROMPT('File Prefix: ',@s10),%DoFilePrefix,UNIQUE,REQ
#!    #PROMPT('Global Name Area: ',@s20),%DoFileName,REQ
#!    #PROMPT('File Name: ',@s30),%DoFile,REQ
#!  #ENDBUTTON
#!#ENDBOXED
#!--------------------------------------------------------------------
#DECLARE(%OutputFile)
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%WorkString)
#DECLARE(%CountFiles)
#DECLARE(%DoTheseFiles),UNIQUE
#DECLARE(%DoFilePrefix,%DoTheseFiles)
#DECLARE(%DoFileName,%DoTheseFiles)
#DECLARE(%DoFile,%DoTheseFiles)
#DECLARE(%DoFileDescription,%DoTheseFiles)          #! RAS.2003.07.22
#!--------------------------------------------------------------------
#IF (%WhatName = 'Use the dictionary name, with a .TXT extension.')
  #SET (%OutputFile, SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 3) & 'TXT')
#ELSE
  #SET (%OutputFile, %NewName)
#ENDIF
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%File)
    #ADD (%ReportedFiles, %File)
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR (%ReportedFiles)
  #FIX(%File,%ReportedFiles)
  #SET(%CountFiles,%CountFiles + 1)
  #ADD(%DoTheseFiles, %CountFiles)
  #SET(%DoFilePrefix, %FilePrefix)
  #SET(%DoFileName, %FileName)
  #SET(%DoFile, %File)
  #!SET(%DoFileDescription, '[' & %FileDriver & '] ' & %FileDescription)        #! RAS.2003.07.22
  #SET(%DoFileDescription, %FileDescription)                                    #! RAS.2019.07.14
#ENDFOR
#!--------------------------------------------------------------------
#EQUATE (%DoSort,1)
#EQUATE (%I,0)
#EQUATE (%W1FilePrefix,'')
#EQUATE (%W1FileName,'')
#EQUATE (%W1File,'')
#EQUATE (%W1FileDescription,'')                     #! RAS.2003.07.22
#EQUATE (%W2FilePrefix,'')
#EQUATE (%W2FileName,'')
#EQUATE (%W2File,'')
#EQUATE (%W2FileDescription,'')                     #! RAS.2003.07.22
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoTheseFiles))
    #SELECT(%DoTheseFiles,%I-1)
    #SET(%W1FilePrefix,%DoFilePrefix)
    #SET(%W1FileName,%DoFileName)
    #SET(%W1File,%DoFile)
    #SET(%W1FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #SELECT(%DoTheseFiles,%I)
    #SET(%W2FilePrefix,%DoFilePrefix)
    #SET(%W2FileName,%DoFileName)
    #SET(%W2File,%DoFile)
    #SET(%W2FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #IF(%W1FilePrefix > %W2FilePrefix)
      #SET(%DoSort,1)
      #SET(%DoFilePrefix,%W1FilePrefix)
      #SET(%DoFileName,%W1FileName)
      #SET(%DoFile,%W1File)
      #SET(%DoFileDescription,%W1FileDescription)   #! RAS.2003.07.22
      #SELECT(%DoTheseFiles,%I-1)
      #SET(%DoFilePrefix,%W2FilePrefix)
      #SET(%DoFileName,%W2FileName)
      #SET(%DoFile,%W2File)
      #SET(%DoFileDescription,%W2FileDescription)   #! RAS.2003.07.22
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#CREATE (%OutputFile)
#SET(%WorkString,'Dictionary Files Report')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!#INSERT(%DictionaryFilesHeader)
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoTheseFiles)
  #FIX(%File,%DoFileName)
  #IF((%CountFiles % 20) = 0)
#INSERT(%DictionaryFilesHeader)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N03@(%CountFiles)  %[8]DoFilePrefix %[50]DoFileName %[50]DoFile %DoFileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%DictionaryFilesHeader)
#CLOSE (%OutputFile)
#!--------------------------------------------------------------------
#IF (~%DoNotPrint)
  #RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#IF (%RetainFile = 'I don''t want it. Remove the file after printing.')
  #REMOVE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#GROUP(%DictionaryFilesHeader),AUTO
#EQUATE(%HFilePrefix,'PREFIX')
#EQUATE(%HFileName,'GLOBAL AREA')
#EQUATE(%HFile,'FILE NAME')
#EQUATE(%HFileDescription, 'DESCRIPTION')

 SEQ  %[8]HFilePrefix %[50]HFileName %[50]HFile %HFileDescription

#GROUP(%DictionaryFilesHeaderEnd)
#!--------------------------------------------------------------------
#GROUP(%UTILDictionaryFilesEnd)
#!--------------------------------------------------------------------

#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_FieldTableXref, '2002.10.27: [DCT2SQL-UTIL] Print Fields to Table XREF')
#!--------------------------------------------------------------------
#! Changes:
#! 2002.10.27   Roberto Artigas Jr
#!  *   Now outputing field picture and field type.
#!  *   Set in between divider between columns prompt now suported.
#! 2002.08.27   Roberto Artigas Jr
#!  *   Added the field picture to the field name to make it easier to deal
#!      with checking dictionary fields matching for types.
#!--------------------------------------------------------------------
#SHEET,HSCROLL
 #TAB('General')
  #BOXED('')
   #DISPLAY('The Field to Table XREF Utility.')
   #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
   #DISPLAY('All Rights Reserved World Wide.')
   #DISPLAY('')
   #PROMPT('Output: ',@S80),%OutputFile,AT(50,,130),DEFAULT(SUB(%DictionaryFile,1,LEN(%DictionaryFile)-4) & '.fxf')
   #DISPLAY('')
   #PROMPT('Set in between column divider at: ',@n4),%AtColPos,AT(150,,30),DEFAULT(40)
  #ENDBOXED
 #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#DECLARE(%FieldTableList),MULTI,UNIQUE
#!
#DECLARE(%CountFiles  ,LONG)            #! File Counter
#DECLARE(%nLoc1       ,LONG)            #! Location 1
#DECLARE(%nLoc2       ,LONG)            #! Location 2
#DECLARE(%WorkString)                   #! Working String
#DECLARE(%WorkLine)                     #! Formated String
#DECLARE(%NFieldName)                   #! Field name
#!
#DECLARE(%NFileUser)                    #! File user options [RASQL]
#DECLARE(%NFileOpt1)                    #! File option 1 [NO]
#DECLARE(%NFileOpt2)                    #! File option 2 [ISAM|MYISAM|HEAP|MERGE|DBD|GEMINI|INNODB|MRG_MYISAM]
#DECLARE(%NFileOpt3)                    #! File option 3 [DEFAULT|DYNAMIC|STATIC|COMPRESSED]
#DECLARE(%NFileOpt4)                    #! File option 4
#!
#DECLARE(%NFieldUser)                   #! Field user options [RASQL]
#DECLARE(%NFieldOpt1)                   #! Field option 1 [NO]
#DECLARE(%NFieldOpt2)                   #! Field option 2 [<Field Type>]
#DECLARE(%NFieldOpt3)                   #! Field option 3 [PKEYA+AUTO+NOTNULL]
#DECLARE(%NFieldOpt4)                   #! Field option 4
#!--------------------------------------------------------------------
#CREATE(%OutputFile)
#MESSAGE('The Field to Table XREF Utility',0)
#MESSAGE('Creating: ' & %OutputFile,1)
#!---------------------------------------------------------------------
#FOR(%File)
  #!----------------------------------------------------------------!
  #! RAS.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.   !
  #!----------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RAS.2001.12.01
    #CYCLE                                                      #! RAS.2001.12.01
  #ENDIF                                                        #! RAS.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
      #CYCLE
  #ENDCASE
#!
  #MESSAGE('Table of: ' & %File,2)                              #! RAS.2001.12.15
#!
  #FOR(%Field)
    #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
    #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
    #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
    #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
    #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
    #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
    #IF(SUB(%NFieldOpt1,1,1)='N')
      #CYCLE
    #ENDIF
#!
    #IF(%FieldType='GROUP')
      #CYCLE
    #ENDIF
    #!
    #IF(%FieldType='END')
      #CYCLE
    #ENDIF
#!
    #SET(%NFieldName, %FieldID)
    #SET(%NFieldName, %NFieldName & ' (' & %FieldPicture & ',' & %FieldType & ')')
    #SET(%WorkLine, %NFieldName & ALL(' ', %AtColPos - LEN(%NFieldName)) & ' ==> ' & %File)
    #ADD(%FieldTableList, %WorkLine)
  #ENDFOR
#ENDFOR
#!---------------------------------------------------------------------
#SET(%WorkString,'Field to Table Cross Reference')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())

#SET(%CountFiles,0)
#FOR(%FieldTableList)
  #IF((%CountFiles % 20) = 0)
#INSERT(%FieldTableXrefHeader)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
%@N4@(%CountFiles)  %FieldTableList
#ENDFOR
#INSERT(%FieldTableXrefHeader)

#!---------------------------------------------------------------------
#CLOSE(%OutputFile)
#RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#!--------------------------------------------------------------------
#GROUP(%FieldTableXrefHeader),AUTO
#EQUATE(%HKeyField,'FIELD NAME')
#EQUATE(%HFileName,'TABLE NAME')

ITEM  %[%AtColPos]HKeyField ==> %[30]HFileName

#GROUP(%FieldTableXrefHeaderEnd)
#!--------------------------------------------------------------------
#GROUP(%UTILFieldTableXrefEnd)
#!--------------------------------------------------------------------


#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_KeyFieldTableXref, '2002.10.27: [DCT2SQL-UTIL] Print Key Fields to Table XREF')
#!--------------------------------------------------------------------
#! Changes:
#! 2002.10.27   Roberto Artigas Jr
#!  *   Now outputing field picture and field type.
#!  *   Set in between divider between columns prompt now suported.
#! 2002.08.27   Roberto Artigas Jr
#!  *   Added the field picture to the field name to make it easier to deal
#!      with checking dictionary primary key and foreign keys being longs.
#!--------------------------------------------------------------------
#SHEET,HSCROLL
 #TAB('General')
  #BOXED('')
   #DISPLAY('The Key Field to Table XREF Utility.')
   #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
   #DISPLAY('All Rights Reserved World Wide.')
   #DISPLAY('')
   #PROMPT('Output: ',@S80),%OutputFile,AT(50,,130),DEFAULT(SUB(%DictionaryFile,1,LEN(%DictionaryFile)-4) & '.kxf')
   #DISPLAY('')
   #PROMPT('Set in between column divider at: ',@n4),%AtColPos,AT(150,,30),DEFAULT(40)
   #DISPLAY('')
  #ENDBOXED
 #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#DECLARE(%FieldTableList),MULTI,UNIQUE
#!
#DECLARE(%CountFiles  ,LONG)            #! File Counter
#DECLARE(%nLoc1       ,LONG)            #! Location 1
#DECLARE(%nLoc2       ,LONG)            #! Location 2
#DECLARE(%WorkString)                   #! Working String
#DECLARE(%WorkLine)                     #! Formated String
#DECLARE(%NKeyName)                     #! Key name
#DECLARE(%NKeyField)                    #! Key field current
#!
#DECLARE(%NFileUser)                    #! File user options [RASQL]
#DECLARE(%NFileOpt1)                    #! File option 1 [NO]
#DECLARE(%NFileOpt2)                    #! File option 2 [ISAM|MYISAM|HEAP|MERGE|DBD|GEMINI|INNODB|MRG_MYISAM]
#DECLARE(%NFileOpt3)                    #! File option 3 [DEFAULT|DYNAMIC|STATIC|COMPRESSED]
#DECLARE(%NFileOpt4)                    #! File option 4
#!
#DECLARE(%NKeyUser)                     #! Key user options [RASQL]
#DECLARE(%NKeyOpt1)                     #! Key option 1 [NO]
#DECLARE(%NKeyOpt2)                     #! Key option 2 [PKEYA|SKEYA]
#DECLARE(%NKeyOpt3)                     #! Key option 3
#DECLARE(%NKeyOpt4)                     #! Key option 4
#!--------------------------------------------------------------------
#CREATE(%OutputFile)
#MESSAGE('The Key Field to Table XREF Utility',0)
#MESSAGE('Creating: ' & %OutputFile,1)
#!---------------------------------------------------------------------
#FOR(%File)
  #!----------------------------------------------------------------!
  #! RAS.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.   !
  #!----------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RAS.2001.12.01
    #CYCLE                                                      #! RAS.2001.12.01
  #ENDIF                                                        #! RAS.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
      #CYCLE
  #ENDCASE
#!
  #MESSAGE('Table of: ' & %File,2)                              #! RAS.2001.12.15
#!
  #IF(ITEMS(%Key))
    #FOR(%Key)
      #IF(NOT ITEMS(%KeyField))                                 #! Key has fields? No!
        #CYCLE                                                  #! Then go to the next
      #ENDIF                                                    #! key to be processed
#!
      #SET(%nLoc1,INSTRING('RASQL(',%KeyUserOptions,1,1))
      #SET(%nLoc2,INSTRING(')',%KeyUserOptions,1,%nLoc1))
      #SET(%nKeyUser,UPPER(SUB(%KeyUserOptions,%nLoc1,%nLoc2)))
      #SET(%NKeyOpt1,EXTRACT(%NKeyUser,'RASQL',1))
      #SET(%NKeyOpt2,EXTRACT(%NKeyUser,'RASQL',2))
      #SET(%NKeyOpt3,EXTRACT(%NKeyUser,'RASQL',3))
      #SET(%NKeyOpt4,EXTRACT(%NKeyUser,'RASQL',4))
      #!------------------------------------------------------------!
      #! The first option RASQL(NO) controls if a key is processed. !
      #!------------------------------------------------------------!
      #IF(SUB(%NKeyOpt1,1,1)='N')
        #CYCLE
      #ENDIF
#!
      #SET(%NKeyName,%KeyID)
      #FOR(%KeyField)
        #SET(%NKeyField, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
        #FIX(%Field,%KeyField)
        #SET(%NKeyField, %NKeyField & ' (' & %FieldPicture & ',' & %FieldType & ')')
        #!ADD(%FieldTableList, %NKeyField & ' ==> ' & %File)
        #SET(%WorkLine, %NKeyField & ALL(' ', %AtColPos - LEN(%NKeyField)) & ' ==> ' & %File)
        #ADD(%FieldTableList, %WorkLine)
      #ENDFOR
    #ENDFOR
  #ENDIF
#ENDFOR
#!---------------------------------------------------------------------
#SET(%WorkString,'Key Field to Table Cross Reference')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())

#SET(%CountFiles,0)
#FOR(%FieldTableList)
  #IF((%CountFiles % 20) = 0)
#INSERT(%KeyFieldTableXrefHeader)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
%@N4@(%CountFiles)  %FieldTableList
#ENDFOR
#INSERT(%KeyFieldTableXrefHeader)

#!---------------------------------------------------------------------
#CLOSE(%OutputFile)
#RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#!--------------------------------------------------------------------
#GROUP(%KeyFieldTableXrefHeader),AUTO
#EQUATE(%HKeyField,'KEY FIELD')
#EQUATE(%HFileName,'TABLE NAME')

ITEM  %[%AtColPos]HKeyField ==> %[30]HFileName

#GROUP(%KeyFieldTableXrefHeaderEnd)
#!--------------------------------------------------------------------
#GROUP(%UTILKeyFieldTableXrefEnd)
#!--------------------------------------------------------------------


#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_PK_Auto_Exists, '2007.04.19: [DCT2SQL-UTIL] Does a Primary Key Auto-Increment exist? ')
#!--------------------------------------------------------------------
#! Changes:
#! RA.2007.04.19    Roberto Artigas
#!  * Added RAWEB(NO) option so certain files can be ignore by this utility.
#! RA.2007.04.04    Roberto Artigas
#!  *   Error message added if primary key has more than one field
#!--------------------------------------------------------------------
#SHEET,HSCROLL
 #TAB('General')
  #BOXED('')
   #DISPLAY('Auto-Increment Primary Key LONG checker.')
   #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
   #DISPLAY('All Rights Reserved World Wide.')
   #DISPLAY('')
   #PROMPT('Output: ',@S80),%OutputFile,AT(50,,130),DEFAULT(SUB(%DictionaryFile,1,LEN(%DictionaryFile)-4) & '.pkx')
   #DISPLAY('')
   #PROMPT('Set in between column divider at: ',@n4),%AtColPos,AT(150,,30),DEFAULT(30)
   #DISPLAY('')
  #ENDBOXED
 #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#DECLARE(%FieldTableList),MULTI,UNIQUE
#!
#DECLARE(%CountFiles  ,LONG)            #! File Counter
#DECLARE(%nLoc1       ,LONG)            #! Location 1
#DECLARE(%nLoc2       ,LONG)            #! Location 2
#DECLARE(%WorkString)                   #! Working String
#DECLARE(%WorkLine)                     #! Formated String
#DECLARE(%NKeyName)                     #! Key name
#DECLARE(%NKeyField)                    #! Key field current
#DECLARE(%NKeyAuto)                     #! Auto Increment field
#DECLARE(%nFindPK)                      #! Found a primary key
#DECLARE(%nCntFlds)                     #! Count fields in primary key
#!
#DECLARE(%NFileUser)                    #! File user options [RASQL]
#DECLARE(%NFileOpt1)                    #! File option 1 [NO]
#DECLARE(%NFileOpt2)                    #! File option 2 [ISAM|MYISAM|HEAP|MERGE|DBD|GEMINI|INNODB|MRG_MYISAM]
#DECLARE(%NFileOpt3)                    #! File option 3 [DEFAULT|DYNAMIC|STATIC|COMPRESSED]
#DECLARE(%NFileOpt4)                    #! File option 4
#!
#DECLARE(%NKeyUser)                     #! Key user options [RASQL]
#DECLARE(%NKeyOpt1)                     #! Key option 1 [NO]
#DECLARE(%NKeyOpt2)                     #! Key option 2 [PKEYA|SKEYA]
#DECLARE(%NKeyOpt3)                     #! Key option 3
#DECLARE(%NKeyOpt4)                     #! Key option 4
#!
#EQUATE (%ErrFileNoFields   ,'File has no fields')
#EQUATE (%ErrFileType       ,'File is of a file type = ')
#EQUATE (%ErrFileDriver     ,'File is of a driver type = ')
#EQUATE (%ErrFileNoKeys     ,'File has no keys')
#EQUATE (%ErrFileNoPK       ,'File has no primary key')
#EQUATE (%ErrKeyOnePlus     ,'Primary Key has more than one field')
#!--------------------------------------------------------------------
#CREATE(%OutputFile)
#MESSAGE('Does a Primary Key Auto-Increment exist?',0)
#MESSAGE('Creating: ' & %OutputFile,1)
#!---------------------------------------------------------------------
#FOR(%File)
  #MESSAGE('Table of: ' & %File,2)                              #! RAS.2001.12.15
#!  #ERROR(%File)
#!  #ERROR(LEN(%File))
#!
  #SET(%nLoc1,INSTRING('RAWEB(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RAWEB',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RAWEB',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RAWEB',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RAWEB',4))
  #!-------------------------------------------------------------!
  #! The first option RAWEB(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
    #! File has wrong file type
#!    #SET(%WorkLine, %File & ALL(' ', %AtColPos - LEN(%File)) & ' ==> ' & %ErrFileType & %FileType)
#!    #ADD(%FieldTableList, %WorkLine)
    #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
    #! File has wrong driver
#!    #SET(%WorkLine, %File & ALL(' ', %AtColPos - LEN(%File)) & ' ==> ' & %ErrFileDriver & %FileDriver)
#!    #ADD(%FieldTableList, %WorkLine)
    #CYCLE
  #ENDCASE
#!
  #!----------------------------------------------------------------!
  #! RAS.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.   !
  #!----------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RAS.2001.12.01
    #! File has no fields
    #SET(%WorkLine, %File & ALL(' ', %AtColPos - LEN(%File)) & ' ==> ' & %ErrFileNoFields)
    #ADD(%FieldTableList, %WorkLine)
    #CYCLE                                                      #! RAS.2001.12.01
  #ENDIF                                                        #! RAS.2001.12.01
#!
  #SET(%nFindPK,0)                                              #! No Primary Key Yet
  #IF(ITEMS(%Key))
    #FOR(%Key)
      #SET(%NKeyName,%KeyID)
      #SET(%nCntFlds,0)                                         #! Count fields
#!
      #FOR(%KeyField)
        #IF(%KeyPrimary)
          #SET(%nFindPk,1)                                      #! Found Primary Key (YES!)
          #SET(%nCntFlds,%nCntFlds+1)                           #! Increment field count
          #SET(%NKeyField, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 150))
          #SET(%NKeyAuto,  SUB(%KeyAuto,  INSTRING(':',%KeyAuto ,1,1) + 1 , 150))
          #FIX(%Field,%KeyField)
          #SET(%NKeyField, '[' & %NKeyAuto & ']' & %NKeyField & ' (' & %FieldPicture & ',' & %FieldType & ') ' & %NKeyName)
          #!ADD(%FieldTableList, %NKeyField & ' ==> ' & %File)
          #SET(%WorkLine, %File & ALL(' ', %AtColPos - LEN(%File)) & ' ==> ' & %NKeyField)
          #ADD(%FieldTableList, %WorkLine)
        #ENDIF
      #ENDFOR
    #ENDFOR
  #ELSE
    #! File has no keys
    #SET(%WorkLine, %File & ALL(' ', %AtColPos - LEN(%File)) & ' ==> ' & %ErrFileNoKeys)
    #ADD(%FieldTableList, %WorkLine)
    #CYCLE
  #ENDIF
  #IF(NOT %nFindPK)
    #! No primary key found
    #SET(%WorkLine, %File & ALL(' ', %AtColPos - LEN(%File)) & ' ==> ' & %ErrFileNoPK)
    #ADD(%FieldTableList, %WorkLine)
  #ENDIF
  #IF(%nCntFlds > 1)
    #! Primary Key has more than one field
    #SET(%WorkLine, %File & ALL(' ', %AtColPos - LEN(%File)) & ' ==> ' & %ErrKeyOnePlus)
    #ADD(%FieldTableList, %WorkLine)
  #ENDIF
#ENDFOR
#!---------------------------------------------------------------------
#SET(%WorkString,'Does a Primary Key Auto-Increment exist?')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())

#SET(%CountFiles,0)
#FOR(%FieldTableList)
  #IF((%CountFiles % 20) = 0)
#INSERT(%UTILPKAutoExistsHeader)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
%@N4@(%CountFiles)  %FieldTableList
#ENDFOR
#INSERT(%UTILPKAutoExistsHeader)

#!---------------------------------------------------------------------
#CLOSE(%OutputFile)
#RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#!--------------------------------------------------------------------
#GROUP(%UTILPKAutoExistsHeader),AUTO
#EQUATE(%HKeyField,'TABLE-NAME')
#EQUATE(%HFileName,'[AUTO-FIELD] KEY-FIELD (PICTURE,TYPE) KEY-NAME')

ITEM  %[%AtColPos]HKeyField ==> %[30]HFileName

#GROUP(%UTILPKAutoExistsHeaderEnd)
#!--------------------------------------------------------------------
#GROUP(%UTILPKAutoExistsEnd)
#!--------------------------------------------------------------------

#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#UTILITY (UTIL_DictionaryFiles2, '2010.11.11: [DCT2SQL-UTIL] Print Dictionary Files-Fields NetTalk-Checkover'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2010.11.11   Roberto Artigas
#!  * ADded check in BOOLEAN for empty TRUE/FALSE values.
#! 2007.04.19   Roberto Artigas
#!  * Added RAWEB(NO) option so certain files can be ignore by this utility.
#! 2007.04.04   Roberto Artigas
#!  * Check for single quotes in hell tooltip and help message
#!  * Do not process ALIAS'es
#! 2007.03.23   Roberto Artigas
#!  * Added checking for missing HELP stuff.
#!  * Make checking of HELP stuff optional.
#! 2007.03.20   Roberto Artigas
#!  * Make checking of TABs optional
#! 2007.03.10   Roberto Artigas
#!  *   Added #PREPARE section to sort the tables when being selected
#! 2002.06.02   Roberto Artigas
#!  *   Now the utility pops up a wordpad text file rather than printing
#!      directly to the printer. Much nicer to preview before you print.
#!--------------------------------------------------------------------
#PREPARE
  #DECLARE(%appTables),UNIQUE
  #!
  #DECLARE(%nLoc1       ,LONG)            #! Location 1
  #DECLARE(%nLoc2       ,LONG)            #! Location 2
  #DECLARE(%NFileUser)                    #! File user options [RAWEB]
  #DECLARE(%NFileOpt1)                    #! File option 1 [NO]
  #DECLARE(%NFileOpt2)                    #! File option 2
  #DECLARE(%NFileOpt3)                    #! File option 3
  #DECLARE(%NFileOpt4)                    #! File option 4
  #!
  #FOR(%File)
    #!----------------------------------------------------------------!
    #! RAS.2001.12.01 - Ignore file place marker definitions.         !
    #! These are files that are defined but that contain no fields.   !
    #!----------------------------------------------------------------!
    #IF(NOT ITEMS(%Field))                                        
      #CYCLE                                                     
    #ENDIF                                                       
    #SET(%nLoc1,INSTRING('RAWEB(',%FileUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
    #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
    #SET(%NFileOpt1,EXTRACT(%NFileUser,'RAWEB',1))
    #SET(%NFileOpt2,EXTRACT(%NFileUser,'RAWEB',2))
    #SET(%NFileOpt3,EXTRACT(%NFileUser,'RAWEB',3))
    #SET(%NFileOpt4,EXTRACT(%NFileUser,'RAWEB',4))
    #!-------------------------------------------------------------!
    #! The first option RAWEB(NO) controls if a file is processed. !
    #!-------------------------------------------------------------!
    #IF(SUB(%NFileOpt1,1,1)='N')
      #CYCLE
    #ENDIF
#!
    #CASE(%FileType)
    #OF  ('VIEW')
    #OROF('ALIAS')
        #CYCLE
    #ENDCASE
#!
    #CASE(%FileDriver)
      #OF('ASCII')
    #OROF('BASIC')
    #OROF('DOS')
        #CYCLE
    #ENDCASE
#!
    #ADD(%appTables, %File)
  #ENDFOR
#ENDPREPARE
#SHEET
  #TAB ('Dictionary Print Wizard')
    #DISPLAY('The Dictionary Overview Print Utility.')
    #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will generate a report of the contents of your current dictionary.')
    #DISPLAY('To specify how you want the report constructed, click on the Next button.')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), FINISH(1)
    #DISPLAY('The dictionary report wizard creates a text file, which is then sent to your printer.')
    #DISPLAY('')
    #DISPLAY('You can, if you wish, have this wizard delete the file when it''s done, or you can keep the file')
    #DISPLAY('for later use.')
    #DISPLAY('')
    #PROMPT ('What do you want to do with the file?', OPTION), %RetainFile
    #PROMPT ('I don''t want it. Remove the file after printing.', RADIO)
    #PROMPT ('I might need it. Keep the file around.', RADIO)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), WHERE(%RetainFile = 'I might need it. Keep the file around.'), FINISH(1)
    #PROMPT ('What name do you want the text file to have?', OPTION), %WhatName
    #PROMPT ('Use the dictionary name, with a .TXT extension.', RADIO)
    #PROMPT ('Let me supply my own file name.', RADIO)
    #ENABLE (%WhatName = 'Let me supply my own file name.')
      #PROMPT ('Please enter the name of the text file to be generated.', @S100), %NewName
    #ENDENABLE
    #PROMPT ('Don''t print this report automatically. I''ll print it from the text file later.', CHECK), %DoNotPrint, AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Reported Files'), FINISH(1)
    #DISPLAY('You can report on each file in your dictionary, or you can select individual files to report on.')
    #DISPLAY('')
    #PROMPT ('Report on all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Reported Files'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('File Selection', FROM (%appTables)), %DictionaryReportFileSelection, INLINE, SELECTION('File Selection')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Finally...')
    #DISPLAY ('This concludes the dictionary report wizard.')
    #DISPLAY
    #PROMPT ('Check TAB existence?', CHECK), %OptCheckTabs, DEFAULT(1), AT(10)
    #PROMPT ('Check HELP ID existence?', CHECK), %OptCheckHelpID, DEFAULT(1), AT(10)
    #PROMPT ('Check HELP TOOL TIP existence?', CHECK), %OptCheckHelpTip, DEFAULT(1), AT(10)
    #PROMPT ('Check HELP MESSAGE existence?', CHECK), %OptCheckHelpMsg, DEFAULT(1), AT(10)
    #DISPLAY
    #PROMPT ('Show Choices, Values, and Initial Values?', CHECK), %OptShowINLIST, DEFAULT(0), AT(10)
    #DISPLAY
    #DISPLAY
    #DISPLAY ('Click on the Finish button to generate the text file.')
  #ENDTAB
#ENDSHEET
#!#BOXED('Hide')
#!  #BUTTON('Processed Files'),MULTI(%DoTheseFiles, %DoFilePrefix & ' ' & %DoFileName & ' ' & %DoFile),INLINE
#!    #PROMPT('File Prefix: ',@s10),%DoFilePrefix,UNIQUE,REQ
#!    #PROMPT('Global Name Area: ',@s20),%DoFileName,REQ
#!    #PROMPT('File Name: ',@s30),%DoFile,REQ
#!  #ENDBUTTON
#!#ENDBOXED
#!--------------------------------------------------------------------
#DECLARE(%OutputFile)
#DECLARE(%TabName)
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%WorkString)
#DECLARE(%CountFiles)
#DECLARE(%DoTheseFiles),UNIQUE
#DECLARE(%DoFilePrefix,%DoTheseFiles)
#DECLARE(%DoFileName,%DoTheseFiles)
#DECLARE(%DoFile,%DoTheseFiles)
#DECLARE(%DoFileDescription,%DoTheseFiles)          #! RAS.2003.07.22
#DECLARE(%RasFieldType)
#DECLARE(%RasPrompt)
#DECLARE(%RasHeader)
#DECLARE(%RasHelp)
#DECLARE(%RasMessage)
#DECLARE(%RasTooltip)
#DECLARE(%ChoiceLine)
#DECLARE(%ChoiceComma)
#DECLARE(%ValueLine)
#DECLARE(%ValueComma)
#!
#DECLARE(%nLoc1       ,LONG)            #! Location 1
#DECLARE(%nLoc2       ,LONG)            #! Location 2
#DECLARE(%NFileUser)                    #! File user options [RAWEB]
#DECLARE(%NFileOpt1)                    #! File option 1 [NO]
#DECLARE(%NFileOpt2)                    #! File option 2
#DECLARE(%NFileOpt3)                    #! File option 3
#DECLARE(%NFileOpt4)                    #! File option 4
#!--------------------------------------------------------------------
#IF (%WhatName = 'Use the dictionary name, with a .TXT extension.')
  #SET (%OutputFile, SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 3) & 'TXT')
#ELSE
  #SET (%OutputFile, %NewName)
#ENDIF
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%File)
    #!----------------------------------------------------------------!
    #! RAS.2001.12.01 - Ignore file place marker definitions.         !
    #! These are files that are defined but that contain no fields.   !
    #!----------------------------------------------------------------!
    #IF(NOT ITEMS(%Field))                                        
      #CYCLE                                                     
    #ENDIF
    #!
    #SET(%nLoc1,INSTRING('RAWEB(',%FileUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
    #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
    #SET(%NFileOpt1,EXTRACT(%NFileUser,'RAWEB',1))
    #SET(%NFileOpt2,EXTRACT(%NFileUser,'RAWEB',2))
    #SET(%NFileOpt3,EXTRACT(%NFileUser,'RAWEB',3))
    #SET(%NFileOpt4,EXTRACT(%NFileUser,'RAWEB',4))
    #!-------------------------------------------------------------!
    #! The first option RAWEB(NO) controls if a file is processed. !
    #!-------------------------------------------------------------!
    #IF(SUB(%NFileOpt1,1,1)='N')
      #CYCLE
    #ENDIF
#!
    #CASE(%FileType)
    #OF  ('VIEW')
    #OROF('ALIAS')
        #CYCLE
    #ENDCASE
#!
    #CASE(%FileDriver)
      #OF('ASCII')
    #OROF('BASIC')
    #OROF('DOS')
        #CYCLE
    #ENDCASE
#!
    #ADD (%ReportedFiles, %File)
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR (%ReportedFiles)
  #FIX(%File,%ReportedFiles)
  #SET(%CountFiles,%CountFiles + 1)
  #ADD(%DoTheseFiles, %CountFiles)
  #SET(%DoFilePrefix, %FilePrefix)
  #SET(%DoFileName, %FileName)
  #SET(%DoFile, %File)
  #SET(%DoFileDescription, FORMAT(ITEMS(%Field),@n03) & ' - ' & %FileDescription)        #! RAS.2003.07.22
#ENDFOR
#!--------------------------------------------------------------------
#EQUATE (%DoSort,1)
#EQUATE (%I,0)
#EQUATE (%W1FilePrefix,'')
#EQUATE (%W1FileName,'')
#EQUATE (%W1File,'')
#EQUATE (%W1FileDescription,'')                     #! RAS.2003.07.22
#EQUATE (%W2FilePrefix,'')
#EQUATE (%W2FileName,'')
#EQUATE (%W2File,'')
#EQUATE (%W2FileDescription,'')                     #! RAS.2003.07.22
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoTheseFiles))
    #SELECT(%DoTheseFiles,%I-1)
    #SET(%W1FilePrefix,%DoFilePrefix)
    #SET(%W1FileName,%DoFileName)
    #SET(%W1File,%DoFile)
    #SET(%W1FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #SELECT(%DoTheseFiles,%I)
    #SET(%W2FilePrefix,%DoFilePrefix)
    #SET(%W2FileName,%DoFileName)
    #SET(%W2File,%DoFile)
    #SET(%W2FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #IF(%W1FilePrefix > %W2FilePrefix)
      #SET(%DoSort,1)
      #SET(%DoFilePrefix,%W1FilePrefix)
      #SET(%DoFileName,%W1FileName)
      #SET(%DoFile,%W1File)
      #SET(%DoFileDescription,%W1FileDescription)   #! RAS.2003.07.22
      #SELECT(%DoTheseFiles,%I-1)
      #SET(%DoFilePrefix,%W2FilePrefix)
      #SET(%DoFileName,%W2FileName)
      #SET(%DoFile,%W2File)
      #SET(%DoFileDescription,%W2FileDescription)   #! RAS.2003.07.22
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#CREATE (%OutputFile)
#SET(%WorkString,'Dictionary Files Report')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!#INSERT(%DictionaryFilesHeader)
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoTheseFiles)
  #IF((%CountFiles % 20) = 0)
#INSERT(%DictionaryFilesHeader2)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N3@(%CountFiles)  %[8]DoFilePrefix %[20]DoFileName %[30]DoFile %DoFileDescription
  #FIX(%File,%DoFile)
  #FOR(%Field)
    #IF(%FieldType='GROUP')
      #CYCLE
    #ENDIF
    #IF(%FieldType='END')
      #CYCLE
    #ENDIF
    #IF(%FieldDimension1 > 0)
      #CYCLE
    #ENDIF
    #IF(INSTRING('NOPOPULATE',%FieldQuickOptions,1,1)<>0)
      #CYCLE
    #ENDIF
    #IF(%OptCheckTabs)
      #SET(%TabName,EXTRACT(%FieldQuickOptions,'TAB',1))
      #IF(~%TabName)
      %[24]Field - Field has ---NO--- form tab description
      #ENDIF
    #ENDIF
    #CASE(%FieldValidation)
    #OF  ('NONZERO')
    #OF  ('INRANGE')
    #OF  ('BOOLEAN')
      #!------------------------------------------!
      #! RA.2010.11.11 - Check for blank choices. !
      #!------------------------------------------!
      #IF(%FieldTrueValue = '')
      %[24]Field - BOOLEAN choices exist, but there is no value for TRUE
      #ENDIF
      #IF(%FieldFalseValue = '')
      %[24]Field - BOOLEAN choices exist, but there is no value for FALSE
      #ENDIF
    #OF  ('INLIST')
      #IF(ITEMS(%FieldChoices) AND ~ITEMS(%FieldValues))
      %[24]Field - Validation field choices exist, but there are no field values
      #ENDIF
      #IF(ITEMS(%FieldChoices) AND ~%FieldInitial)
      %[24]Field - Validation field choices exist, but there is no initial default value
      #ENDIF
      #IF(ITEMS(%FieldChoices) AND %OptShowINLIST)
        #SET(%ChoiceLine, '')
        #SET(%ChoiceComma,ITEMS(%FieldChoices) - 1)
        #FOR(%FieldChoices)
          #SET(%ChoiceLine,%ChoiceLine & '' & %FieldChoices & '')
          #IF(%ChoiceComma > 0)
            #SET(%ChoiceLine,%ChoiceLine & '|')
            #SET(%ChoiceComma,%ChoiceComma - 1)
          #ENDIF
        #ENDFOR
        #SET(%ValueLine, '')
        #SET(%ValueComma,ITEMS(%FieldValues) - 1)
        #FOR(%FieldValues)
          #SET(%ValueLine,%ValueLine & '' & %FieldValues & '')
          #IF(%ValueComma > 0)
            #SET(%ValueLine,%ValueLine & '|')
            #SET(%ValueComma,%ValueComma - 1)
          #ENDIF
        #ENDFOR
      %[24]Field - CHOICES: %ChoiceLine
      %[24]Field - VALUES : %ValueLine
      %[24]Field - INITIAL: %FieldInitial
      #ENDIF
#!      #IF(ITEMS(%FieldChoices))
#!        #FOR(%FieldChoices)
#!          #IF(%FieldChoices='')
#!      %[24]Field - Field Choices incorrect (double vertical bar) structure
#!          #ENDIF
#!        #ENDFOR
#!      #ENDIF
    #OF  ('INFILE')
    #ENDCASE
    #!===============================================!
    #! RA.2007.03.23 - Check for missing help stuff. !
    #!===============================================!
    #SET(%RasPrompt,'')
    #SET(%RasMessage,'')
    #SET(%RasTooltip,'')
    #SET(%RasFieldType,UPPER(%FieldType))
#! FieldType='%RasFieldType'
    #FOR(%FieldScreenControl)
      #IF(INSTRING('CHECK',%FieldScreenControl,1,1))
        #SET(%RasFieldType,'CHECK')
#! FieldType='%RasFieldType'
      #ENDIF
      #IF(INSTRING('OPTION',%FieldScreenControl,1,1))
        #SET(%RasFieldType,'OPTION')
#! FieldType='%RasFieldType'
      #ENDIF
#! FieldScreenControl='%FieldScreenControl'
      #IF(NOT %RasPrompt)
        #CASE(%RasFieldType)
        #OF('CHECK')
          #SET(%RasPrompt,EXTRACT(%FieldScreenControl,'CHECK',1))
        #OF('OPTION')
          #SET(%RasPrompt,EXTRACT(%FieldScreenControl,'OPTION',1))
        #ELSE
          #SET(%RasPrompt,EXTRACT(%FieldScreenControl,'PROMPT',1))
        #END
      #ENDIF
      #IF(NOT %RasMessage)
        #SET(%RasMessage,EXTRACT(%FieldScreenControl,'MSG',1))
      #ENDIF
      #IF(NOT %RasTooltip)
        #SET(%RasTooltip,EXTRACT(%FieldScreenControl,'TIP',1))
      #ENDIF
    #ENDFOR
    #SET(%RasHeader,%FieldHeader)
    #SET(%RasHelp,%FieldHelpID)
#!    %[29]FieldID %FieldQuickOptions
#!        HELP ID: '%RasHelp'
#!         HEADER: '%RasHeader'
#!         PROMPT: %RasPrompt
#!        MESSAGE: %RasMessage
#!        TOOLTIP: %RasToolTip
    #IF(%OptCheckHelpID)
      #IF(NOT %RasHelp)
      %[24]Field - Field has ---NO HELP--- Identification
      #ENDIF
    #ENDIF
    #IF(%OptCheckHelpTip)
      #IF(NOT %RasToolTip)
      %[24]Field - Field has ---NO HELP--- Tool Tip Message
      #ENDIF
    #ENDIF
    #IF(%RasToolTip)
      #SET(%RasToolTip,SUB(%RasToolTip,2,LEN(%RasToolTip)-2))
#!%RasTooltip
      #IF(INSTRING('''',%RasToolTip,1,1)>0)
      %[24]Field - Please remove ---SINGLE QUOTES--- in Tool Tip Message
      #ENDIF
    #ENDIF
    #IF(%OptCheckHelpMsg)
      #IF(NOT %RasMessage)
      %[24]Field - Field has ---NO HELP--- Text Message
      #ENDIF
    #ENDIF
    #IF(%RasMessage)
      #SET(%RasMessage,SUB(%RasMessage,2,LEN(%RasMessage)-2))
#!%RasMessage
      #IF(INSTRING('''',%RasMessage,1,1)>0)
      %[24]Field - Please remove ---SINGLE QUOTES--- in Text Message
      #ENDIF
    #ENDIF
  #ENDFOR
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%DictionaryFilesHeader2)
#CLOSE (%OutputFile)
#!--------------------------------------------------------------------
#IF (~%DoNotPrint)
  #RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#IF (%RetainFile = 'I don''t want it. Remove the file after printing.')
  #REMOVE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#GROUP(%DictionaryFilesHeader2),AUTO
#EQUATE(%HFilePrefix,'PREFIX')
#EQUATE(%HFileName,'GLOBAL AREA')
#EQUATE(%HFile,'FILE NAME')
#EQUATE(%HFileDescription, 'DESCRIPTION')

 SEQ  %[8]HFilePrefix %[20]HFileName %[30]HFile %HFileDescription

#GROUP(%DictionaryFilesHeader2End)
#!--------------------------------------------------------------------
#GROUP(%UTILDictionaryFiles2End)
#!--------------------------------------------------------------------

#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#UTILITY (UTIL_DictionaryFiles3, '2007.11.21: [DCT2SQL-UTIL] Print Dictionary Files with specific properties'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2002.06.02   Roberto Artigas Jr
#!  *   Now the utility pops up a wordpad text file rather than printing
#!      directly to the printer. Much nicer to preview before you print.
#!--------------------------------------------------------------------
#PREPARE
#DECLARE(%AllProperties),UNIQUE
#DECLARE(%WorkProperty)
#DECLARE(%ShowProperty)
#DECLARE(%nLoc1       ,LONG)            #! Location 1
#DECLARE(%nLoc2       ,LONG)            #! Location 2
#DECLARE(%NFileUser)                    #! File user options [%TheProperty]
#DECLARE(%NFileOpt1)                    #! File option 1 [YES]
#DECLARE(%NFileOpt2)                    #! File option 2
#DECLARE(%NFileOpt3)                    #! File option 3
#DECLARE(%NFileOpt4)                    #! File option 4
#!
#ADD(%AllProperties,'DATAWAREHOUSE')
#ADD(%AllProperties,'STARSCHEMA')
#ADD(%AllProperties,'DESCRIPTION')
#ADD(%AllProperties,'SUBTYPE')
#ADD(%AllProperties,'PARTYROLETYPE')
#ADD(%AllProperties,'GEOBOUNDARYTYPE')
#ADD(%AllProperties,'DOCUMENTTYPE')
#ADD(%AllProperties,'WORKEFFORTTYPE')
#ADD(%AllProperties,'ROLETYPE')
#ADD(%AllProperties,'STATUSTYPE')
#ADD(%AllProperties,'PARTYTYPE')
#ADD(%AllProperties,'QUOTETYPE')
#ADD(%AllProperties,'TRANSACTIONTYPE')
#ADD(%AllProperties,'FINANCIALACCOUNTTYPE')
#ADD(%AllProperties,'PRICECOMPONENTTYPE')
#ADD(%AllProperties,'PRODUCTFEATURETYPE')
#ADD(%AllProperties,'FACILITYTYPE')
#ADD(%AllProperties,'CONTACTMECHANISMTYPE')
#ADD(%AllProperties,'UOMTYPE')
#ADD(%AllProperties,'REQUIREMENTTYPE')
#ADD(%AllProperties,'SHIPMENTTYPE')
#ADD(%AllProperties,'ORDERTYPE')
#ADD(%AllProperties,'INVOICETYPE')
#ADD(%AllProperties,'PRODUCTCATEGORYTYPE')
#ADD(%AllProperties,'PAYMENTTYPE')
#ADD(%AllProperties,'ORDERADJUSTMENTTYPE')
#ADD(%AllProperties,'COMMUNICATIONEVENTTYPE')
#ADD(%AllProperties,'AGREEMENTTYPE')
#ADD(%AllProperties,'FIXEDASSETTYPE')
#ADD(%AllProperties,'COSTCOMPONENTTYPE')
#ADD(%AllProperties,'PARTYTYPE')
#ADD(%AllProperties,'REQUESTTYPE')
#ADD(%AllProperties,'GLBALANCETYPE')
#ENDPREPARE
#!
#SHEET
  #TAB ('Dictionary Print Wizard')
    #DISPLAY('The Dictionary Overview Print Utility.')
    #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will generate a report of the contents of your current dictionary.')
    #DISPLAY('To specify how you want the report constructed, click on the Next button.')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), FINISH(1)
    #DISPLAY('The dictionary report wizard creates a text file, which is then sent to your printer.')
    #DISPLAY('')
    #DISPLAY('You can, if you wish, have this wizard delete the file when it''s done, or you can keep the file')
    #DISPLAY('for later use.')
    #DISPLAY('')
    #PROMPT ('What do you want to do with the file?', OPTION), %RetainFile
    #PROMPT ('I don''t want it. Remove the file after printing.', RADIO)
    #PROMPT ('I might need it. Keep the file around.', RADIO)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), WHERE(%RetainFile = 'I might need it. Keep the file around.'), FINISH(1)
    #PROMPT ('What name do you want the text file to have?', OPTION), %WhatName
    #PROMPT ('Use the dictionary name, with a .TXT extension.', RADIO)
    #PROMPT ('Let me supply my own file name.', RADIO)
    #ENABLE (%WhatName = 'Let me supply my own file name.')
      #PROMPT ('Please enter the name of the text file to be generated.', @S100), %NewName
    #ENDENABLE
    #PROMPT ('Don''t print this report automatically. I''ll print it from the text file later.', CHECK), %DoNotPrint, AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Reported Files'), FINISH(1)
    #DISPLAY('You can report on each file in your dictionary, or you can select individual files to report on.')
    #DISPLAY('')
    #PROMPT ('Report on all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Reported Files'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('File Selection', FROM (%File)), %DictionaryReportFileSelection, INLINE, SELECTION('File Selection')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Table Property'), FINISH(1)
    #DISPLAY('The property selection allows to select tables with special characteristics.')
    #DISPLAY('')
    #PROMPT ('Property Selection', FROM (%AllProperties)), %TheProperty, DEFAULT('')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Finally...')
    #DISPLAY ('This concludes the dictionary report wizard.')
    #DISPLAY ('Click on the Finish button to generate the text file.')
  #ENDTAB
#ENDSHEET
#!#BOXED('Hide')
#!  #BUTTON('Processed Files'),MULTI(%DoTheseFiles, %DoFilePrefix & ' ' & %DoFileName & ' ' & %DoFile),INLINE
#!    #PROMPT('File Prefix: ',@s10),%DoFilePrefix,UNIQUE,REQ
#!    #PROMPT('Global Name Area: ',@s20),%DoFileName,REQ
#!    #PROMPT('File Name: ',@s30),%DoFile,REQ
#!  #ENDBUTTON
#!#ENDBOXED
#!--------------------------------------------------------------------
#DECLARE(%OutputFile)
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%WorkString)
#DECLARE(%CountFiles)
#DECLARE(%DoTheseFiles),UNIQUE
#DECLARE(%DoFilePrefix,%DoTheseFiles)
#DECLARE(%DoFileName,%DoTheseFiles)
#DECLARE(%DoFile,%DoTheseFiles)
#DECLARE(%DoFileDescription,%DoTheseFiles)          #! RAS.2003.07.22
#!--------------------------------------------------------------------
#IF (%WhatName = 'Use the dictionary name, with a .TXT extension.')
  #SET (%OutputFile, SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 3) & 'TXT')
#ELSE
  #SET (%OutputFile, %NewName)
#ENDIF
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%File)
    #ADD (%ReportedFiles, %File)
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#IF (%TheProperty)
  #SET(%ShowProperty, UPPER(%TheProperty))
  #SET(%WorkProperty, ',' & %TheProperty & '(')
#ENDIF
#SET(%CountFiles,0)
#FOR (%ReportedFiles)
  #FIX(%File,%ReportedFiles)
  #!
  #IF (%TheProperty)
    #SET(%nLoc1,INSTRING(%WorkProperty,%FileUserOptions,1,1))
    #IF(NOT %nLoc1)
      #CYCLE
    #ENDIF
    #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
    #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
    #IF(%FALSE)
      #SET(%CountFiles,%CountFiles + 1)
      #ADD(%DoTheseFiles, %CountFiles)
      #SET(%DoFilePrefix, %FilePrefix)
      #SET(%DoFileName, %FileName)
      #SET(%DoFile, %File)
      #SET(%DoFileDescription, %WorkProperty & '  ==  ' & %nFileUser & '  ==  ' & SUB(%nFileUser, 1, LEN(%WorkProperty)))
    #ENDIF
    #IF(%WorkProperty <> SUB(%nFileUser, 1, LEN(%WorkProperty)))
      #CYCLE
    #ENDIF
    #SET(%NFileOpt1,EXTRACT(%NFileUser,%TheProperty,1))
    #IF(SUB(%NFileOpt1,1,1)<>'Y')
      #CYCLE
    #ENDIF
  #ENDIF
  #!
  #SET(%CountFiles,%CountFiles + 1)
  #ADD(%DoTheseFiles, %CountFiles)
  #SET(%DoFilePrefix, %FilePrefix)
  #SET(%DoFileName, %FileName)
  #SET(%DoFile, %File)
  #SET(%DoFileDescription, %FileDescription)        #! RAS.2003.07.22
#ENDFOR
#!--------------------------------------------------------------------
#EQUATE (%DoSort,1)
#EQUATE (%I,0)
#EQUATE (%W1FilePrefix,'')
#EQUATE (%W1FileName,'')
#EQUATE (%W1File,'')
#EQUATE (%W1FileDescription,'')                     #! RAS.2003.07.22
#EQUATE (%W2FilePrefix,'')
#EQUATE (%W2FileName,'')
#EQUATE (%W2File,'')
#EQUATE (%W2FileDescription,'')                     #! RAS.2003.07.22
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoTheseFiles))
    #SELECT(%DoTheseFiles,%I-1)
    #SET(%W1FilePrefix,%DoFilePrefix)
    #SET(%W1FileName,%DoFileName)
    #SET(%W1File,%DoFile)
    #SET(%W1FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #SELECT(%DoTheseFiles,%I)
    #SET(%W2FilePrefix,%DoFilePrefix)
    #SET(%W2FileName,%DoFileName)
    #SET(%W2File,%DoFile)
    #SET(%W2FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #IF(%W1FilePrefix > %W2FilePrefix)
      #SET(%DoSort,1)
      #SET(%DoFilePrefix,%W1FilePrefix)
      #SET(%DoFileName,%W1FileName)
      #SET(%DoFile,%W1File)
      #SET(%DoFileDescription,%W1FileDescription)   #! RAS.2003.07.22
      #SELECT(%DoTheseFiles,%I-1)
      #SET(%DoFilePrefix,%W2FilePrefix)
      #SET(%DoFileName,%W2FileName)
      #SET(%DoFile,%W2File)
      #SET(%DoFileDescription,%W2FileDescription)   #! RAS.2003.07.22
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#CREATE (%OutputFile)
#SET(%WorkString,'Dictionary Files Report')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!#INSERT(%DictionaryFilesHeader)
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoTheseFiles)
  #IF((%CountFiles % 20) = 0)
#INSERT(%DictionaryFilesHeader3)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N3@(%CountFiles)  %[8]DoFilePrefix %[20]DoFileName %[30]DoFile %DoFileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%DictionaryFilesHeader3)
#CLOSE (%OutputFile)
#!--------------------------------------------------------------------
#IF (~%DoNotPrint)
  #RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#IF (%RetainFile = 'I don''t want it. Remove the file after printing.')
  #REMOVE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#GROUP(%DictionaryFilesHeader3),AUTO
#EQUATE(%HFilePrefix,'PREFIX')
#EQUATE(%HFileName,'GLOBAL AREA')
#EQUATE(%HFile,'FILE NAME')
#EQUATE(%HFileDescription, 'DESCRIPTION')

 SEQ  %[8]HFilePrefix %[20]HFileName %[30]HFile %HFileDescription
#IF(%TheProperty)
 TABLES WITH PROPERTY: %ShowProperty
#ENDIF

#GROUP(%DictionaryFilesHeader3End)
#!--------------------------------------------------------------------
#GROUP(%UTILDictionaryFiles3End)
#!--------------------------------------------------------------------

#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_DictionaryFiles4, '2009.11.05: [DCT2SQL-UTIL] Print Dictionary Files [Parents-Children]'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2009.11.05   Roberto Artigas Jr
#!  *   Added a file property 'RYB_INIT(NO)' to exclude the creation of certain files
#!      that might not need initialization being already in the database (references).
#!      NOTE: You can choose NOT generate the initialization routines, or you CAN
#!      generated them and they will do nothing by just passing a return.
#! 2007.12.29   Roberto Artigas Jr
#!  *   Enhanced initialization code generation logic to allow re-importing
#!      of the caller procedure to reset the called procedure order programatically
#!      rather than to have to do reset the order by moving the procedures around.
#! 2007.12.17   Roberto Artigas Jr
#!  *   Changed and added to the template logic considerably allowing it to figure
#!      out the parent-child order. This allows to figure out the order to add sample
#!      data to the database in the order needed so as not to violate constraints.
#!      The utility also generates source code that you can import into your clarion
#!      program. A caller procedure is generated that calls a bunch of skeleton
#!      procedures to fill in the data in the correct order. You need to add the sample
#!      data by hand, but then everything else has been figured out for you.
#! 2002.06.02   Roberto Artigas Jr
#!  *   Now the utility pops up a wordpad text file rather than printing
#!      directly to the printer. Much nicer to preview before you print.
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.17 - The %BaseName determines what backend you are processing.
#! All the specific items related to a backend can be coded with a case statement.
#! This will make the code easier to maintain accross all the backends.
#PREPARE
#DECLARE(%BaseName)                                                             #! Define the BACKEND here
#SET(%BaseName, 'TPLUTILITY')                                                   #! TPLUTILITY: NOT A BACKEND
#ENDPREPARE
#!---------------------------------------------------------------------
#INSERT(%VariablesCommon)                                                       #! Need a few simple variables
#INSERT(%GetDictionaryPath)                                                     #! Get dictionary path and names
#INSERT(%VariablesDeclare)                                                      #! Option checks and output file names
#INSERT(%VariablesSetup)                                                        #! Setup output file names
#INSERT(%VariablesOptions)                                                      #! All option variables setup here
#INSERT(%DefineAreasOptions)                                                    #! File,Field,Keys,Relations
#INSERT(%ReserveWordDefines)                                                    #! Reserved Words Defines
#!INSERT(%PreambleUtility)                                                       #! Basic copyright message
#PREPARE
#SET(%UtilityChekTable                    , %TRUE)
#SET(%UtilityNameTable                    , %DictName & '_' & %BaseName & '_LOAD_DATA_ORDER.TXT')
#SET(%UtilityNameTableOut                 , %DictPath & %UtilityNameTable)
#ENDPREPARE
#!---------------------------------------------------------------------
#PREPARE
#DECLARE(%RYBfiles),UNIQUE
#DECLARE(%RYBinit)
#FOR (%File)
  #SET(%RYBinit,UPPER(EXTRACT(%FileUserOptions,'RYB_INIT',1)))
  #IF(SUB(%RYBinit,1,1) = 'N')
    #CYCLE
  #ENDIF
  #ADD (%RYBfiles, %File)
#ENDFOR
#ENDPREPARE
#!--------------------------------------------------------------------
#SHEET
  #TAB ('Dictionary Print Wizard')
    #DISPLAY('The Dictionary Overview Print Utility [Parent-Children].')
    #DISPLAY('Copyright 2001-2011 ?by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will generate a report of the contents of your current dictionary.')
    #DISPLAY('To specify how you want the report constructed, click on the Next button.')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), FINISH(1)
    #DISPLAY('The dictionary report wizard creates a text file, which is then sent to your printer.')
    #DISPLAY('')
    #DISPLAY('You can, if you wish, have this wizard delete the file when it''s done, or you can keep the file')
    #DISPLAY('for later use.')
    #DISPLAY('')
    #PROMPT ('What do you want to do with the file?', OPTION), %RetainFile
    #PROMPT ('I don''t want it. Remove the file after printing.', RADIO)
    #PROMPT ('I might need it. Keep the file around.', RADIO)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), WHERE(%RetainFile = 'I might need it. Keep the file around.'), FINISH(1)
    #PROMPT ('What name do you want the text file to have?', OPTION), %WhatName
    #PROMPT ('Use the dictionary name, with a .TXT extension.', RADIO)
    #PROMPT ('Let me supply my own file name.', RADIO)
    #ENABLE (%WhatName = 'Let me supply my own file name.')
      #PROMPT ('Please enter the name of the text file to be generated.', @S100), %NewName
    #ENDENABLE
    #PROMPT ('Don''t print this report automatically. I''ll print it from the text file later.', CHECK), %DoNotPrint, AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Reported Files'), FINISH(1)
    #DISPLAY('You can report on each file in your dictionary, or you can select individual files to report on.')
    #DISPLAY('')
    #PROMPT ('Report on all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Reported Files'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('File Selection', FROM (%RYBfiles)), %DictionaryReportFileSelection, INLINE, SELECTION('File Selection')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Generate Procedures'), FINISH(1)
    #DISPLAY('You can even choose to generate the initialization routines.')
    #DISPLAY('')
    #PROMPT ('Date of caller procedure is: ', @S8), %DateCaller, DEFAULT(FORMAT(TODAY(),@D012)), AT(,,60)
    #PROMPT ('Date of called procedures is: ', @S8), %DateCalled, DEFAULT(FORMAT(TODAY(),@D012)), AT(,,60)
    #DISPLAY('')
    #PROMPT ('Generate initialization procedures.', CHECK), %InitializeGenerate, DEFAULT(1), AT(10)
    #ENABLE(%InitializeGenerate)
      #PROMPT ('Generate caller procedure.', CHECK), %GenerateCaller, DEFAULT(1), AT(20)
      #PROMPT ('Generate called procedures.', CHECK), %GenerateCalled, DEFAULT(0), AT(20)
    #ENDENABLE
    #PROMPT ('Import initialization procedures.', CHECK), %InitializeImport, DEFAULT(0), AT(10)
    #DISPLAY('')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Finally...')
    #DISPLAY ('This concludes the dictionary report wizard.')
    #DISPLAY('')
    #DISPLAY('')
    #DISPLAY ('Click on the Finish button to generate the text file.')
  #ENDTAB
#ENDSHEET
#!#BOXED('Hide')
#!  #BUTTON('Processed Files'),MULTI(%DoTheseFiles, %DoFilePrefix & ' ' & %DoFileName & ' ' & %DoFile),INLINE
#!    #PROMPT('File Prefix: ',@s10),%DoFilePrefix,UNIQUE,REQ
#!    #PROMPT('Global Name Area: ',@s20),%DoFileName,REQ
#!    #PROMPT('File Name: ',@s30),%DoFile,REQ
#!  #ENDBUTTON
#!#ENDBOXED
#!--------------------------------------------------------------------
#DECLARE(%OutputFile)
#DECLARE(%GenerateFile)
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%WorkString)
#DECLARE(%CountFiles)
#DECLARE(%CountParChi)
#DECLARE(%CountParents)
#DECLARE(%CountChildren)
#DECLARE(%CountOrder)
#DECLARE(%IndexOrder)
#DECLARE(%DoingOrder)
#DECLARE(%FoundOrder)
#DECLARE(%SearchOrder)
#DECLARE(%CountFinal)
#DECLARE(%IndexFinal)
#DECLARE(%FoundFinal)
#DECLARE(%SearchFinal)
#!
#DECLARE(%DoTheseFiles),UNIQUE
#DECLARE(%DoFilePrefix      ,%DoTheseFiles)
#DECLARE(%DoFileName        ,%DoTheseFiles)
#DECLARE(%DoFile            ,%DoTheseFiles)
#DECLARE(%DoFileDescription ,%DoTheseFiles)
#!
#DECLARE(%DoParChi),UNIQUE                          #! Entry Sequence
#DECLARE(%DoParChiCount     ,%DoParChi)             #! Parent-Child Count
#DECLARE(%DoParChiToId      ,%DoParChi)             #! To Id (Child)
#DECLARE(%DoParChiToName    ,%DoParChi)             #! To Name (Child)
#DECLARE(%DoParChiFmId      ,%DoParChi)             #! From Id (Parent)
#DECLARE(%DoParChiFmName    ,%DoParChi)             #! From Name (Parent)
#!
#DECLARE(%DoOrder),UNIQUE                           #! Entry Sequence
#DECLARE(%DoOrderCount      ,%DoOrder)              #! Parent-Child Count
#DECLARE(%DoOrderToId       ,%DoOrder)              #! To Id (Child)
#DECLARE(%DoOrderToName     ,%DoOrder)              #! To Name (Child)
#DECLARE(%DoOrderFmId       ,%DoOrder)              #! From Id (Parent)
#DECLARE(%DoOrderFmName     ,%DoOrder)              #! From Name (Parent)
#!
#DECLARE(%DoFinal),UNIQUE                           #! Entry Sequence
#DECLARE(%DoFinalCount      ,%DoFinal)              #! Parent-Child Count
#DECLARE(%DoFinalFmName     ,%DoFinal)              #! From Name (Parent)
#!--------------------------------------------------------------------
#IF (%WhatName = 'Use the dictionary name, with a .TXT extension.')
  #SET (%OutputFile, SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 3) & 'TXT')
#ELSE
  #!SET (%OutputFile, %NewName)
  #SET (%OutputFile, %UtilityNameTableOut)          #! RA.2019.07.07.SUN: Give me something
#ENDIF
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%RYBfiles)
    #ADD (%ReportedFiles, %RYBfiles)
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#CREATE (%OutputFile)
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#SET(%CountParChi,0)
#FOR (%ReportedFiles)
  #FIX(%File,%ReportedFiles)
  #!
  #!                                        #! RA.2019.07.07: Added
  #!
#!  #CASE(%FileType)                          #! Only want files
#!  #OF  ('VIEW')                             #! ... no views
#!  #OROF('ALIAS')                            #! ... no alias
#!    #CYCLE                                  #! next item
#!  #ENDCASE                                  #! Only got files
  #!
  #!                                        #! RA.2019.07.07: Added
  #!
  #SET(%CountFiles,%CountFiles + 1)
  #ADD(%DoTheseFiles, %CountFiles)
  #SET(%DoFilePrefix, %FilePrefix)
  #SET(%DoFileName, %FileName)
  #SET(%DoFile, %File)
  #!
  #SET(%CountParents,0)
  #SET(%CountChildren,0)
  #FOR(%Relation)
#!-- %File %FileRelationType %Relation
    #IF(%FileRelationType = 'MANY:1')
      #SET(%CountParents, %CountParents + 1)
    #ELSE
      #SET(%CountChildren, %CountChildren + 1)
    #ENDIF
  #ENDFOR
  #!
  #SET(%DoFileDescription, '[' & FORMAT(%CountParents,@N03) & '-' & FORMAT(%CountChildren,@N03) & '] ' & %FileDescription)
  #!
  #IF(%CountParents)
    #FOR(%Relation)
      #!-- %File %FileRelationType %Relation
      #IF(%FileRelationType = 'MANY:1')
        #SET(%CountParChi, %CountParChi + 1)
        #ADD(%DoParChi,%CountParChi)
        #SET(%DoParChiCount, FORMAT((100 - %CountParents),@N03) & '-' & FORMAT(%CountChildren,@N03))
        #SET(%DoParChiToId, %DoTheseFiles)
        #SET(%DoParChiToName, %File)
        #SET(%DoParChiFmId, 0)
        #SET(%DoParChiFmName, %Relation)
      #ENDIF
    #ENDFOR
  #ELSE
        #SET(%CountParChi, %CountParChi + 1)
        #ADD(%DoParChi,%CountParChi)
        #SET(%DoParChiCount, FORMAT((100 - %CountParents),@N03) & '-' & FORMAT(%CountChildren,@N03))
        #SET(%DoParChiToId, %DoTheseFiles)
        #SET(%DoParChiToName, %File)
        #SET(%DoParChiFmId, 0)
        #SET(%DoParChiFmName, '')
  #ENDIF
#ENDFOR
#!--------------------------------------------------------------------
#FOR(%DoParChi),WHERE(%DoParChiFmName)
  #FOR(%DoTheseFiles)
    #IF(%DoFile = %DoParChiFmName)
      #SET(%DoParChiFmId, %DoTheseFiles)
    #ENDIF
  #ENDFOR
#ENDFOR
#!--------------------------------------------------------------------
#! RA.2007.12.14 - Sort decending parents and ascending children
#EQUATE (%DoSort,1)
#EQUATE (%I,0)
#EQUATE (%W1DoParChiCount,'')
#EQUATE (%W1DoParChiToId,'')
#EQUATE (%W1DoParChiToName,'')
#EQUATE (%W1DoParChiFmId,'')
#EQUATE (%W1DoParChiFmName,'')
#EQUATE (%W2DoParChiCount,'')
#EQUATE (%W2DoParChiToId,'')
#EQUATE (%W2DoParChiToName,'')
#EQUATE (%W2DoParChiFmId,'')
#EQUATE (%W2DoParChiFmName,'')
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoParChi))
    #SELECT(%DoParChi,%I-1)
    #SET(%W1DoParChiCount,%DoParChiCount)
    #SET(%W1DoParChiToId,%DoParChiToId)
    #SET(%W1DoParChiToName,%DoParChiToName)
    #SET(%W1DoParChiFmId,%DoParChiFmId)
    #SET(%W1DoParChiFmName,%DoParChiFmName)
    #SELECT(%DoParChi,%I)
    #SET(%W2DoParChiCount,%DoParChiCount)
    #SET(%W2DoParChiToId,%DoParChiToId)
    #SET(%W2DoParChiToName,%DoParChiToName)
    #SET(%W2DoParChiFmId,%DoParChiFmId)
    #SET(%W2DoParChiFmName,%DoParChiFmName)
    #IF(%W1DoParChiCount > %W2DoParChiCount)
      #SET(%DoSort,1)
      #SET(%DoParChiCount,%W1DoParChiCount)
      #SET(%DoParChiToId,%W1DoParChiToId)
      #SET(%DoParChiToName,%W1DoParChiToName)
      #SET(%DoParChiFmId,%W1DoParChiFmId)
      #SET(%DoParChiFmName,%W1DoParChiFmName)
      #SELECT(%DoParChi,%I-1)
      #SET(%DoParChiCount,%W2DoParChiCount)
      #SET(%DoParChiToId,%W2DoParChiToId)
      #SET(%DoParChiToName,%W2DoParChiToName)
      #SET(%DoParChiFmId,%W2DoParChiFmId)
      #SET(%DoParChiFmName,%W2DoParChiFmName)
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#! RA.2007.12.14 - Reset the bias for decending sort on the parents
#FOR(%DoParChi)
 #SET(%CountParents,INT(SUB(%DoParChiCount,1,3)))
 #SET(%CountChildren,INT(SUB(%DoParChiCount,5,3)))
 #SET(%DoParChiCount, FORMAT((100 - %CountParents),@N03) & '-' & FORMAT(%CountChildren,@N03))
#! %@N04@(%DoParChi) %[7]DoParChiCount %@N03@(%DoParChiToId) %[36]DoParChiToName %@N03@(%DoParChiFmId) %[36]DoParChiFmName
#ENDFOR
#!--------------------------------------------------------------------
#! RA.2007.12.15 - Process the queue that has been sorted from the end
#! to the front getting the items that have no parents first.
#! We delete the items from the ParChi queue when we add them to the
#! Order queue. We make sure the parent exists before we add it to the
#! Order queue. If the parent does not exist in the Order queue we skip
#! this item until the next pass to see if it has been added then.
#! Please note there are a total of 5 passes done. Might need more.
#SET(%CountOrder, 0)
#SET(%DoingOrder, 0)
#SET(%IndexOrder, 0)
#LOOP,WHILE(ITEMS(%DoParChi) AND (%DoingOrder < 5))
  #LOOP,FOR( %IndexOrder, ITEMS(%DoParChi), 1 ), BY( -1 )
    #SELECT(%DoParChi, %IndexOrder)
    #! Check for the items with no parents and
    #! just write them out to the destination.
    #IF(%DoParChiFmId = 0)
      #SET(%CountOrder, %CountOrder + 1)
      #ADD(%DoOrder,%CountOrder)
      #SET(%DoOrderCount,%DoParChiCount)
      #SET(%DoOrderToId,%DoParChiToId)
      #SET(%DoOrderToName,%DoParChiToName)
      #SET(%DoOrderFmId,%DoParChiFmId)
      #SET(%DoOrderFmName,%DoParChiFmName)
      #DELETE(%DoParChi)
      #CYCLE
    #ENDIF
    #! Search to see if parent is in destination
    #! and set the found flag accordingly.
    #SET(%FoundOrder,0)
    #LOOP,FOR(%SearchOrder, 1, ITEMS(%DoOrder) )
      #SELECT(%DoOrder, %SearchOrder)
      #IF(%DoOrderToId = %DoParChiFmId)
        #SET(%FoundOrder,1)
        #BREAK
      #ENDIF
    #ENDLOOP
    #! Found parent in destionation. Add this item.
    #! Otherwise wait on this item for later pass.
    #IF(%FoundOrder)
      #SET(%CountOrder, %CountOrder + 1)
      #ADD(%DoOrder,%CountOrder)
      #SET(%DoOrderCount,%DoParChiCount)
      #SET(%DoOrderToId,%DoParChiToId)
      #SET(%DoOrderToName,%DoParChiToName)
      #SET(%DoOrderFmId,%DoParChiFmId)
      #SET(%DoOrderFmName,%DoParChiFmName)
      #DELETE(%DoParChi)
      #CYCLE
    #ENDIF
  #ENDLOOP
  #! Set up for the next pass on the ParChi queue.
  #! There are 0 to 4 (total 5) passes done.
  #SET(%DoingOrder, %DoingOrder + 1)
#ENDLOOP
#!--------------------------------------------------------------------
#! RA.2007.12.15 - Report any posible errors that might be found.
#SET(%IndexOrder, ITEMS(%DoParChi))
#IF(ITEMS(%DoParChi))
PROBLEM SOMEWHERE - There are %IndexOrder items that are left without parents already set

#FOR(%DoParChi)
 %@N04@(%DoParChi) %[7]DoParChiCount %@N03@(%DoParChiToId) %[36]DoParChiToName %@N03@(%DoParChiFmId) %[36]DoParChiFmName
#ENDFOR



#ENDIF
#!--------------------------------------------------------------------
#! RA.2007.12.15 - This is for debug purposes
#IF(%TRUE)
#FOR(%DoOrder)
 %@N04@(%DoOrder) %[7]DoOrderCount %@N03@(%DoOrderToId) %[36]DoOrderToName %@N03@(%DoOrderFmId) %[36]DoOrderFmName
#ENDFOR



#ENDIF
#!--------------------------------------------------------------------
#! RA.2007.12.15 - We work backwards from the Order queue to add the
#! latest table item to the Final queue. When we finish we should have
#! only one entry for each table and we should match our original count.
#LOOP,FOR( %IndexOrder, ITEMS(%DoOrder), 1 ), BY( -1 )
  #SELECT(%DoOrder, %IndexOrder)
  #IF(ITEMS(%DoFinal))
    #SET(%FoundFinal, 0)
    #LOOP,FOR(%SearchFinal, 1, ITEMS(%DoFinal) )
      #SELECT(%DoFinal, %SearchFinal)
      #IF(%DoOrderToName = %DoFinalFmName)
        #SET(%FoundFinal,1)
        #BREAK
      #ENDIF
    #ENDLOOP
    #IF(%FoundFinal)
      #! This Order item ---is--- in the Final queue
      #DELETE(%DoOrder)
      #CYCLE
    #ELSE
      #! This Order item ---is not--- in the Final queue
      #ADD(%DoFinal,%DoOrder)
      #FIX(%DoFinal,%DoOrder)
      #SET(%DoFinalCount,%DoOrderCount)
      #SET(%DoFinalFmName,%DoOrderToName)
      #DELETE(%DoOrder)
      #CYCLE
    #ENDIF
  #ELSE
    #! First queue item in Final
    #ADD(%DoFinal,%DoOrder)
    #FIX(%DoFinal,%DoOrder)
    #SET(%DoFinalCount,%DoOrderCount)
    #SET(%DoFinalFmName,%DoOrderToName)
    #DELETE(%DoOrder)
    #CYCLE
  #ENDIF
#ENDLOOP
#!--------------------------------------------------------------------
#! RA.2007.12.15 - Debug list
#IF(%TRUE)
#SET(%CountFinal,ITEMS(%DoFinal))
There are %CountFinal items in the Final queue

#FOR(%DoFinal)
 %@N04@(%DoFinal) %[7]DoFinalCount  %[36]DoFinalFmName
#ENDFOR



#ENDIF
#!--------------------------------------------------------------------
#SET    (%DoSort,1)
#SET    (%I,0)
#EQUATE (%W1FilePrefix,'')
#EQUATE (%W1FileName,'')
#EQUATE (%W1File,'')
#EQUATE (%W1FileDescription,'')
#EQUATE (%W2FilePrefix,'')
#EQUATE (%W2FileName,'')
#EQUATE (%W2File,'')
#EQUATE (%W2FileDescription,'')
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoTheseFiles))
    #SELECT(%DoTheseFiles,%I-1)
    #SET(%W1FilePrefix,%DoFilePrefix)
    #SET(%W1FileName,%DoFileName)
    #SET(%W1File,%DoFile)
    #SET(%W1FileDescription,%DoFileDescription)
    #SELECT(%DoTheseFiles,%I)
    #SET(%W2FilePrefix,%DoFilePrefix)
    #SET(%W2FileName,%DoFileName)
    #SET(%W2File,%DoFile)
    #SET(%W2FileDescription,%DoFileDescription)
    #!#IF(%W1FilePrefix > %W2FilePrefix)            #! RA.2007.12.17
    #IF(%W1File > %W2File)                          #! RA.2007.12.17
      #SET(%DoSort,1)
      #SET(%DoFilePrefix,%W1FilePrefix)
      #SET(%DoFileName,%W1FileName)
      #SET(%DoFile,%W1File)
      #SET(%DoFileDescription,%W1FileDescription)
      #SELECT(%DoTheseFiles,%I-1)
      #SET(%DoFilePrefix,%W2FilePrefix)
      #SET(%DoFileName,%W2FileName)
      #SET(%DoFile,%W2File)
      #SET(%DoFileDescription,%W2FileDescription)
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!#CREATE (%OutputFile)
#!--------------------------------------------------------------------
#SET(%WorkString,'Dictionary Files Report [Parents-Children]')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoTheseFiles)
  #IF((%CountFiles % 20) = 0)
#INSERT(%DictionaryFilesHeader4)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N03@(%CountFiles) %[7]DoFilePrefix %[13]DoFileName %[36]DoFile %DoFileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%DictionaryFilesHeader4)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------



#SET(%WorkString,'Test Data Entry Table Sequence')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoFinal)
  #FIX(%File,%DoFinalFmName)
  #CASE(%FileType)                          #! Only want files
  #OF  ('VIEW')                             #! ... no views
  #OROF('ALIAS')                            #! ... no alias
    #CYCLE                                  #! next item
  #ENDCASE                                  #! Only got files
  #IF((%CountFiles % 20) = 0)
#INSERT(%DictionaryFilesHeader4a)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N03@(%CountFiles) [%DoFinalCount] %[8]FilePrefix %[36]DoFinalFmName %FileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%DictionaryFilesHeader4a)
#!--------------------------------------------------------------------
#CLOSE (%OutputFile)
#!--------------------------------------------------------------------
#IF (~%DoNotPrint)
  #RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#!--------------------------------------------------------------------
#! RA.2007.12.17 - I know what I need, let me just generate it so I do
#! not have to code it by hand.
#!--------------------------------------------------------------------
#IF(%InitializeGenerate)
#SET(%GenerateFile,UPPER(SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 4)) & '_INITIALIZE.TXA')
#CREATE(%GenerateFile)
#IF(%GenerateCaller)
#INSERT(%TxaCaller)
#ENDIF
#IF(%GenerateCalled)
#INSERT(%TxaCalled)
#ENDIF
#CLOSE (%GenerateFile)
#ENDIF
#!--------------------------------------------------------------------
#IF(%InitializeImport)
#IMPORT(%GenerateFile),REPLACE
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#IF (%RetainFile = 'I don''t want it. Remove the file after printing.')
  #REMOVE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%DictionaryFilesHeader4a),AUTO
#EQUATE(%HFileName,'[PAR-CHI]')
#EQUATE(%HFilePrefix,'PREFIX')
#EQUATE(%HFile,'FILE NAME')
#EQUATE(%HFileDescription, 'DESCRIPTION')

 SEQ %[7]HFileName %[8]HFilePrefix %[36]HFile %HFileDescription

#GROUP(%DictionaryFilesHeader4aEnd)
#!--------------------------------------------------------------------
#GROUP(%DictionaryFilesHeader4),AUTO
#EQUATE(%HFilePrefix,'PREFIX')
#EQUATE(%HFileName,'GLOBAL AREA')
#EQUATE(%HFile,'FILE NAME')
#EQUATE(%HFileDescription, '[PAR-CHI] DESCRIPTION')

 SEQ %[7]HFilePrefix %[13]HFileName %[36]HFile %HFileDescription

#GROUP(%DictionaryFilesHeader4End)
#!--------------------------------------------------------------------
#GROUP(%TxaCaller)
[PROCEDURE]
NAME init_%DateCaller_database
NOEXPORT
[COMMON]
DESCRIPTION 'Initialize all database tables.'
FROM ABC Source
CATEGORY 'initialize'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('')
%%GenerateOpenClose LONG  (0)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%DataSection
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
WAIT_WINDOW         EQUATE(1)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLOpenWindow WINDOW('Initializing Datatabase'),AT(,,247,26),FONT('MS Sans Serif',8,,FONT:regular),CENTER, |
         GRAY,DOUBLE
       STRING('Please wait while the program initializes the database tables.'),AT(29,3)
       STRING('This process could take several seconds.'),AT(61,12)
     END
[END]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
  SETCURSOR(Cursor:Wait)
  OPEN(SQLOpenWindow)
  ACCEPT
    IF EVENT() = Event:OpenWindow
  !***WAIT***
#SET(%CountFiles,0)
#FOR(%DoFinal)
  #FIX(%File,%DoFinalFmName)
  #CASE(%FileType)                          #! Only want files
  #OF  ('VIEW')                             #! ... no views
  #OROF('ALIAS')                            #! ... no alias
    #CYCLE                                  #! next item
  #ENDCASE                                  #! Only got files
  #SET(%CountFiles,%CountFiles + 1)
  #SET(%CountOrder,%CountFiles * 10)
[PROCEDURE]
#!init_%@D012@(TODAY())_%@N06@(%CountOrder)_%File
init_%DateCalled_%File
PRIORITY 5100
#ENDFOR
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5400
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
      POST(EVENT:CloseWindow)
    END
  END
  CLOSE(SQLOpenWindow)
  SETCURSOR()
  !***WAIT***
[END]
[END]
#GROUP(%TxaCallerEnd)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%TxaCalled)
#SET(%CountFiles,0)
#FOR(%DoFinal)
  #FIX(%File,%DoFinalFmName)
  #CASE(%FileType)                          #! Only want files
  #OF  ('VIEW')                             #! ... no views
  #OROF('ALIAS')                            #! ... no alias
    #CYCLE                                  #! next item
  #ENDCASE                                  #! Only got files
  #SET(%CountFiles,%CountFiles + 1)
  #SET(%CountOrder,%CountFiles * 10)
[PROCEDURE]
#!NAME init_%@D012@(TODAY())_%@N06@(%CountOrder)_%File
NAME init_%DateCalled_%File
NOEXPORT
[COMMON]
DESCRIPTION '[%DoFinalCount] %FileDescription'
FROM ABC Source
CATEGORY 'initialize'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[FILES]
[OTHERS]
%File
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('')
%%GenerateOpenClose LONG  (1)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  DO OpenFiles

!  CLEAR(%FilePrefix:record)
  #FOR(%Field)
    #CASE(%FieldType)
    #OF  ('MEMO')
    #OROF('BLOB')
    #OROF('STRING')
    #OROF('CSTRING')
    #OROF('PSTRING')
!  %Field = ''
    #ELSE
!  %Field = 0
    #ENDCASE
  #ENDFOR
!  Access:%File.Insert()

  DO CloseFiles
[END]
[END]
#ENDFOR
#GROUP(%TxaCalledEnd)
#!--------------------------------------------------------------------
#GROUP(%UTILDictionaryFiles4End)
#!--------------------------------------------------------------------

#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_DictionaryFiles4_Schema, '2011.04.28: [DCT2SQL-UTIL] Print Dictionary Files [Parents-Children]'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2011.04.28   Roberto Artigas
#!  *   Changed window that is shown during initialization.
#!  *   Creation of table window title messages to be shown.
#!  *   This is now a schema dictionary utility (add option?).
#!  *   Processes INTERNAL/EXTERNAL names.
#! 2009.11.05   Roberto Artigas
#!  *   Added a file property 'RYB_INIT(NO)' to exclude the creation of certain files
#!      that might not need initialization being already in the database (references).
#!      NOTE: You can choose NOT generate the initialization routines, or you CAN
#!      generated them and they will do nothing by just passing a return.
#! 2007.12.29   Roberto Artigas
#!  *   Enhanced initialization code generation logic to allow re-importing
#!      of the caller procedure to reset the called procedure order programatically
#!      rather than to have to do reset the order by moving the procedures around.
#! 2007.12.17   Roberto Artigas
#!  *   Changed and added to the template logic considerably allowing it to figure
#!      out the parent-child order. This allows to figure out the order to add sample
#!      data to the database in the order needed so as not to violate constraints.
#!      The utility also generates source code that you can import into your clarion
#!      program. A caller procedure is generated that calls a bunch of skeleton
#!      procedures to fill in the data in the correct order. You need to add the sample
#!      data by hand, but then everything else has been figured out for you.
#! 2002.06.02   Roberto Artigas
#!  *   Now the utility pops up a wordpad text file rather than printing
#!      directly to the printer. Much nicer to preview before you print.
#!--------------------------------------------------------------------
#PREPARE
#DECLARE(%RYBfiles),UNIQUE
#DECLARE(%RYBinit)
#FOR (%File)
  #SET(%RYBinit,UPPER(EXTRACT(%FileUserOptions,'RYB_INIT',1)))
  #IF(SUB(%RYBinit,1,1) = 'N')
    #CYCLE
  #ENDIF
  #ADD (%RYBfiles, %File)
#ENDFOR
#ENDPREPARE
#!--------------------------------------------------------------------
#SHEET
  #TAB ('Dictionary Print Wizard')
    #DISPLAY('The Dictionary Overview Print Utility [Parent-Children].')
    #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will generate a report of the contents of your current dictionary.')
    #DISPLAY('To specify how you want the report constructed, click on the Next button.')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), FINISH(1)
    #DISPLAY('The dictionary report wizard creates a text file, which is then sent to your printer.')
    #DISPLAY('')
    #DISPLAY('You can, if you wish, have this wizard delete the file when it''s done, or you can keep the file')
    #DISPLAY('for later use.')
    #DISPLAY('')
    #PROMPT ('What do you want to do with the file?', OPTION), %RetainFile
    #PROMPT ('I don''t want it. Remove the file after printing.', RADIO)
    #PROMPT ('I might need it. Keep the file around.', RADIO)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), WHERE(%RetainFile = 'I might need it. Keep the file around.'), FINISH(1)
    #PROMPT ('What name do you want the text file to have?', OPTION), %WhatName
    #PROMPT ('Use the dictionary name, with a .TXT extension.', RADIO)
    #PROMPT ('Let me supply my own file name.', RADIO)
    #ENABLE (%WhatName = 'Let me supply my own file name.')
      #PROMPT ('Please enter the name of the text file to be generated.', @S100), %NewName
    #ENDENABLE
    #PROMPT ('Don''t print this report automatically. I''ll print it from the text file later.', CHECK), %DoNotPrint, AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Reported Files'), FINISH(1)
    #DISPLAY('You can report on each file in your dictionary, or you can select individual files to report on.')
    #DISPLAY('')
    #PROMPT ('Report on all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Reported Files'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('File Selection', FROM (%RYBfiles)), %DictionaryReportFileSelection, INLINE, SELECTION('File Selection')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Generate Procedures'), FINISH(1)
    #DISPLAY('You can even choose to generate the initialization routines.')
    #DISPLAY('')
    #PROMPT ('Date of caller procedure is: ', @S8), %DateCaller, DEFAULT(FORMAT(TODAY(),@D012)), AT(,,60)
    #PROMPT ('Date of called procedures is: ', @S8), %DateCalled, DEFAULT(FORMAT(TODAY(),@D012)), AT(,,60)
    #DISPLAY('')
    #PROMPT ('Generate initialization procedures.', CHECK), %InitializeGenerate, DEFAULT(1), AT(10)
    #ENABLE(%InitializeGenerate)
      #PROMPT ('Generate caller procedure.', CHECK), %GenerateCaller, DEFAULT(1), AT(20)
      #PROMPT ('Generate called procedures.', CHECK), %GenerateCalled, DEFAULT(0), AT(20)
    #ENDENABLE
    #PROMPT ('Import initialization procedures.', CHECK), %InitializeImport, DEFAULT(0), AT(10)
    #DISPLAY('')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Finally...')
    #DISPLAY ('This concludes the dictionary report wizard.')
    #DISPLAY('')
    #DISPLAY('')
    #DISPLAY ('Click on the Finish button to generate the text file.')
  #ENDTAB
#ENDSHEET
#!#BOXED('Hide')
#!  #BUTTON('Processed Files'),MULTI(%DoTheseFiles, %DoFilePrefix & ' ' & %DoFileName & ' ' & %DoFile),INLINE
#!    #PROMPT('File Prefix: ',@s10),%DoFilePrefix,UNIQUE,REQ
#!    #PROMPT('Global Name Area: ',@s20),%DoFileName,REQ
#!    #PROMPT('File Name: ',@s30),%DoFile,REQ
#!  #ENDBUTTON
#!#ENDBOXED
#!--------------------------------------------------------------------
#DECLARE(%OutputFile)
#DECLARE(%GenerateFile)
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%WorkString)
#DECLARE(%CountFiles)
#DECLARE(%CountParChi)
#DECLARE(%CountParents)
#DECLARE(%CountChildren)
#DECLARE(%CountOrder)
#DECLARE(%IndexOrder)
#DECLARE(%DoingOrder)
#DECLARE(%FoundOrder)
#DECLARE(%SearchOrder)
#DECLARE(%CountFinal)
#DECLARE(%IndexFinal)
#DECLARE(%FoundFinal)
#DECLARE(%SearchFinal)
#!----------------------------------------------------------!
#! RA.2011.04. 28 - Variables added to create window titles !
#! as to what exactly is being intialized in the database.  !
#!----------------------------------------------------------!
#DECLARE(%nLoc1)                                    #! RA.2011.04.28
#DECLARE(%nLoc2)
#DECLARE(%aFileUser)
#DECLARE(%aFileOpt1)
#DECLARE(%aFileOpt2)
#DECLARE(%aFileOpt3)
#DECLARE(%aFileOpt4)
#DECLARE(%sFileNameInternal)                        #! RA.2011.04.28 - Table Name Internal
#DECLARE(%sFileNameExternal)                        #! RA.2011.04.28 - Table Name External
#DECLARE(%filDB)                                    #! RA.2011.04.28 - Database
#DECLARE(%filSC)                                    #! RA.2011.04.28 - Schema
#DECLARE(%sFileName)                                #! RA.2011.04.28 - Table
#!
#DECLARE(%DoTheseFiles),UNIQUE
#DECLARE(%DoFilePrefix      ,%DoTheseFiles)
#DECLARE(%DoFileName        ,%DoTheseFiles)
#DECLARE(%DoFile            ,%DoTheseFiles)
#DECLARE(%DoFileDescription ,%DoTheseFiles)
#!
#DECLARE(%DoParChi),UNIQUE                          #! Entry Sequence
#DECLARE(%DoParChiCount     ,%DoParChi)             #! Parent-Child Count
#DECLARE(%DoParChiToId      ,%DoParChi)             #! To Id (Child)
#DECLARE(%DoParChiToName    ,%DoParChi)             #! To Name (Child)
#DECLARE(%DoParChiFmId      ,%DoParChi)             #! From Id (Parent)
#DECLARE(%DoParChiFmName    ,%DoParChi)             #! From Name (Parent)
#!
#DECLARE(%DoOrder),UNIQUE                           #! Entry Sequence
#DECLARE(%DoOrderCount      ,%DoOrder)              #! Parent-Child Count
#DECLARE(%DoOrderToId       ,%DoOrder)              #! To Id (Child)
#DECLARE(%DoOrderToName     ,%DoOrder)              #! To Name (Child)
#DECLARE(%DoOrderFmId       ,%DoOrder)              #! From Id (Parent)
#DECLARE(%DoOrderFmName     ,%DoOrder)              #! From Name (Parent)
#!
#DECLARE(%DoFinal),UNIQUE                           #! Entry Sequence
#DECLARE(%DoFinalCount      ,%DoFinal)              #! Parent-Child Count
#DECLARE(%DoFinalFmName     ,%DoFinal)              #! From Name (Parent)
#!--------------------------------------------------------------------
#IF (%WhatName = 'Use the dictionary name, with a .TXT extension.')
  #SET (%OutputFile, SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 3) & 'TXT')
#ELSE
  #SET (%OutputFile, %NewName)
#ENDIF
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%RYBfiles)
    #ADD (%ReportedFiles, %RYBfiles)
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#CREATE (%OutputFile)
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#SET(%CountParChi,0)
#FOR (%ReportedFiles)
  #FIX(%File,%ReportedFiles)
  #SET(%CountFiles,%CountFiles + 1)
  #ADD(%DoTheseFiles, %CountFiles)
  #SET(%DoFilePrefix, %FilePrefix)
  #SET(%DoFileName, %FileName)
  #SET(%DoFile, %File)
  #!
  #SET(%CountParents,0)
  #SET(%CountChildren,0)
  #FOR(%Relation)
#!-- %File %FileRelationType %Relation
    #IF(%FileRelationType = 'MANY:1')
      #SET(%CountParents, %CountParents + 1)
    #ELSE
      #SET(%CountChildren, %CountChildren + 1)
    #ENDIF
  #ENDFOR
  #!
  #SET(%DoFileDescription, '[' & FORMAT(%CountParents,@N03) & '-' & FORMAT(%CountChildren,@N03) & '] ' & %FileDescription)
  #!
  #IF(%CountParents)
    #FOR(%Relation)
      #!-- %File %FileRelationType %Relation
      #IF(%FileRelationType = 'MANY:1')
        #SET(%CountParChi, %CountParChi + 1)
        #ADD(%DoParChi,%CountParChi)
        #SET(%DoParChiCount, FORMAT((100 - %CountParents),@N03) & '-' & FORMAT(%CountChildren,@N03))
        #SET(%DoParChiToId, %DoTheseFiles)
        #SET(%DoParChiToName, %File)
        #SET(%DoParChiFmId, 0)
        #SET(%DoParChiFmName, %Relation)
      #ENDIF
    #ENDFOR
  #ELSE
        #SET(%CountParChi, %CountParChi + 1)
        #ADD(%DoParChi,%CountParChi)
        #SET(%DoParChiCount, FORMAT((100 - %CountParents),@N03) & '-' & FORMAT(%CountChildren,@N03))
        #SET(%DoParChiToId, %DoTheseFiles)
        #SET(%DoParChiToName, %File)
        #SET(%DoParChiFmId, 0)
        #SET(%DoParChiFmName, '')
  #ENDIF
#ENDFOR
#!--------------------------------------------------------------------
#FOR(%DoParChi),WHERE(%DoParChiFmName)
  #FOR(%DoTheseFiles)
    #IF(%DoFile = %DoParChiFmName)
      #SET(%DoParChiFmId, %DoTheseFiles)
    #ENDIF
  #ENDFOR
#ENDFOR
#!--------------------------------------------------------------------
#! RA.2007.12.14 - Sort decending parents and ascending children
#EQUATE (%DoSort,1)
#EQUATE (%I,0)
#EQUATE (%W1DoParChiCount,'')
#EQUATE (%W1DoParChiToId,'')
#EQUATE (%W1DoParChiToName,'')
#EQUATE (%W1DoParChiFmId,'')
#EQUATE (%W1DoParChiFmName,'')
#EQUATE (%W2DoParChiCount,'')
#EQUATE (%W2DoParChiToId,'')
#EQUATE (%W2DoParChiToName,'')
#EQUATE (%W2DoParChiFmId,'')
#EQUATE (%W2DoParChiFmName,'')
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoParChi))
    #SELECT(%DoParChi,%I-1)
    #SET(%W1DoParChiCount,%DoParChiCount)
    #SET(%W1DoParChiToId,%DoParChiToId)
    #SET(%W1DoParChiToName,%DoParChiToName)
    #SET(%W1DoParChiFmId,%DoParChiFmId)
    #SET(%W1DoParChiFmName,%DoParChiFmName)
    #SELECT(%DoParChi,%I)
    #SET(%W2DoParChiCount,%DoParChiCount)
    #SET(%W2DoParChiToId,%DoParChiToId)
    #SET(%W2DoParChiToName,%DoParChiToName)
    #SET(%W2DoParChiFmId,%DoParChiFmId)
    #SET(%W2DoParChiFmName,%DoParChiFmName)
    #IF(%W1DoParChiCount > %W2DoParChiCount)
      #SET(%DoSort,1)
      #SET(%DoParChiCount,%W1DoParChiCount)
      #SET(%DoParChiToId,%W1DoParChiToId)
      #SET(%DoParChiToName,%W1DoParChiToName)
      #SET(%DoParChiFmId,%W1DoParChiFmId)
      #SET(%DoParChiFmName,%W1DoParChiFmName)
      #SELECT(%DoParChi,%I-1)
      #SET(%DoParChiCount,%W2DoParChiCount)
      #SET(%DoParChiToId,%W2DoParChiToId)
      #SET(%DoParChiToName,%W2DoParChiToName)
      #SET(%DoParChiFmId,%W2DoParChiFmId)
      #SET(%DoParChiFmName,%W2DoParChiFmName)
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#! RA.2007.12.14 - Reset the bias for decending sort on the parents
#FOR(%DoParChi)
 #SET(%CountParents,INT(SUB(%DoParChiCount,1,3)))
 #SET(%CountChildren,INT(SUB(%DoParChiCount,5,3)))
 #SET(%DoParChiCount, FORMAT((100 - %CountParents),@N03) & '-' & FORMAT(%CountChildren,@N03))
#! %@N04@(%DoParChi) %[7]DoParChiCount %@N03@(%DoParChiToId) %[36]DoParChiToName %@N03@(%DoParChiFmId) %[36]DoParChiFmName
#ENDFOR
#!--------------------------------------------------------------------
#! RA.2007.12.15 - Process the queue that has been sorted from the end
#! to the front getting the items that have no parents first.
#! We delete the items from the ParChi queue when we add them to the
#! Order queue. We make sure the parent exists before we add it to the
#! Order queue. If the parent does not exist in the Order queue we skip
#! this item until the next pass to see if it has been added then.
#! Please note there are a total of 5 passes done. Might need more.
#SET(%CountOrder, 0)
#SET(%DoingOrder, 0)
#SET(%IndexOrder, 0)
#LOOP,WHILE(ITEMS(%DoParChi) AND (%DoingOrder < 5))
  #LOOP,FOR( %IndexOrder, ITEMS(%DoParChi), 1 ), BY( -1 )
    #SELECT(%DoParChi, %IndexOrder)
    #! Check for the items with no parents and
    #! just write them out to the destination.
    #IF(%DoParChiFmId = 0)
      #SET(%CountOrder, %CountOrder + 1)
      #ADD(%DoOrder,%CountOrder)
      #SET(%DoOrderCount,%DoParChiCount)
      #SET(%DoOrderToId,%DoParChiToId)
      #SET(%DoOrderToName,%DoParChiToName)
      #SET(%DoOrderFmId,%DoParChiFmId)
      #SET(%DoOrderFmName,%DoParChiFmName)
      #DELETE(%DoParChi)
      #CYCLE
    #ENDIF
    #! Search to see if parent is in destination
    #! and set the found flag accordingly.
    #SET(%FoundOrder,0)
    #LOOP,FOR(%SearchOrder, 1, ITEMS(%DoOrder) )
      #SELECT(%DoOrder, %SearchOrder)
      #IF(%DoOrderToId = %DoParChiFmId)
        #SET(%FoundOrder,1)
        #BREAK
      #ENDIF
    #ENDLOOP
    #! Found parent in destionation. Add this item.
    #! Otherwise wait on this item for later pass.
    #IF(%FoundOrder)
      #SET(%CountOrder, %CountOrder + 1)
      #ADD(%DoOrder,%CountOrder)
      #SET(%DoOrderCount,%DoParChiCount)
      #SET(%DoOrderToId,%DoParChiToId)
      #SET(%DoOrderToName,%DoParChiToName)
      #SET(%DoOrderFmId,%DoParChiFmId)
      #SET(%DoOrderFmName,%DoParChiFmName)
      #DELETE(%DoParChi)
      #CYCLE
    #ENDIF
  #ENDLOOP
  #! Set up for the next pass on the ParChi queue.
  #! There are 0 to 4 (total 5) passes done.
  #SET(%DoingOrder, %DoingOrder + 1)
#ENDLOOP
#!--------------------------------------------------------------------
#! RA.2007.12.15 - Report any posible errors that might be found.
#SET(%IndexOrder, ITEMS(%DoParChi))
#IF(ITEMS(%DoParChi))
PROBLEM SOMEWHERE - There are %IndexOrder items that are left without parents already set

#FOR(%DoParChi)
 %@N04@(%DoParChi) %[7]DoParChiCount %@N03@(%DoParChiToId) %[36]DoParChiToName %@N03@(%DoParChiFmId) %[36]DoParChiFmName
#ENDFOR



#ENDIF
#!--------------------------------------------------------------------
#! RA.2007.12.15 - This is for debug purposes
#IF(%False)
#FOR(%DoOrder)
 %@N04@(%DoOrder) %[7]DoOrderCount %@N03@(%DoOrderToId) %[36]DoOrderToName %@N03@(%DoOrderFmId) %[36]DoOrderFmName
#ENDFOR



#ENDIF
#!--------------------------------------------------------------------
#! RA.2007.12.15 - We work backwards from the Order queue to add the
#! latest table item to the Final queue. When we finish we should have
#! only one entry for each table and we should match our original count.
#LOOP,FOR( %IndexOrder, ITEMS(%DoOrder), 1 ), BY( -1 )
  #SELECT(%DoOrder, %IndexOrder)
  #IF(ITEMS(%DoFinal))
    #SET(%FoundFinal, 0)
    #LOOP,FOR(%SearchFinal, 1, ITEMS(%DoFinal) )
      #SELECT(%DoFinal, %SearchFinal)
      #IF(%DoOrderToName = %DoFinalFmName)
        #SET(%FoundFinal,1)
        #BREAK
      #ENDIF
    #ENDLOOP
    #IF(%FoundFinal)
      #! This Order item ---is--- in the Final queue
      #DELETE(%DoOrder)
      #CYCLE
    #ELSE
      #! This Order item ---is not--- in the Final queue
      #ADD(%DoFinal,%DoOrder)
      #FIX(%DoFinal,%DoOrder)
      #SET(%DoFinalCount,%DoOrderCount)
      #SET(%DoFinalFmName,%DoOrderToName)
      #DELETE(%DoOrder)
      #CYCLE
    #ENDIF
  #ELSE
    #! First queue item in Final
    #ADD(%DoFinal,%DoOrder)
    #FIX(%DoFinal,%DoOrder)
    #SET(%DoFinalCount,%DoOrderCount)
    #SET(%DoFinalFmName,%DoOrderToName)
    #DELETE(%DoOrder)
    #CYCLE
  #ENDIF
#ENDLOOP
#!--------------------------------------------------------------------
#! RA.2007.12.15 - Debug list
#IF(%False)
#SET(%CountFinal,ITEMS(%DoFinal))
There are %CountFinal items in the Final queue

#FOR(%DoFinal)
 %@N04@(%DoFinal) %[7]DoFinalCount  %[36]DoFinalFmName
#ENDFOR



#ENDIF
#!--------------------------------------------------------------------
#SET    (%DoSort,1)
#SET    (%I,0)
#EQUATE (%W1FilePrefix,'')
#EQUATE (%W1FileName,'')
#EQUATE (%W1File,'')
#EQUATE (%W1FileDescription,'')
#EQUATE (%W2FilePrefix,'')
#EQUATE (%W2FileName,'')
#EQUATE (%W2File,'')
#EQUATE (%W2FileDescription,'')
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoTheseFiles))
    #SELECT(%DoTheseFiles,%I-1)
    #SET(%W1FilePrefix,%DoFilePrefix)
    #SET(%W1FileName,%DoFileName)
    #SET(%W1File,%DoFile)
    #SET(%W1FileDescription,%DoFileDescription)
    #SELECT(%DoTheseFiles,%I)
    #SET(%W2FilePrefix,%DoFilePrefix)
    #SET(%W2FileName,%DoFileName)
    #SET(%W2File,%DoFile)
    #SET(%W2FileDescription,%DoFileDescription)
    #!#IF(%W1FilePrefix > %W2FilePrefix)            #! RA.2007.12.17
    #IF(%W1File > %W2File)                          #! RA.2007.12.17
      #SET(%DoSort,1)
      #SET(%DoFilePrefix,%W1FilePrefix)
      #SET(%DoFileName,%W1FileName)
      #SET(%DoFile,%W1File)
      #SET(%DoFileDescription,%W1FileDescription)
      #SELECT(%DoTheseFiles,%I-1)
      #SET(%DoFilePrefix,%W2FilePrefix)
      #SET(%DoFileName,%W2FileName)
      #SET(%DoFile,%W2File)
      #SET(%DoFileDescription,%W2FileDescription)
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!#CREATE (%OutputFile)
#!--------------------------------------------------------------------
#SET(%WorkString,'Dictionary Files Report [Parents-Children]')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoTheseFiles)
  #IF((%CountFiles % 20) = 0)
#INSERT(%DictionaryFilesHeader4)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N03@(%CountFiles) %[7]DoFilePrefix %[13]DoFileName %[36]DoFile %DoFileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%DictionaryFilesHeader4)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------



#SET(%WorkString,'Test Data Entry Table Sequence')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoFinal)
  #FIX(%File,%DoFinalFmName)
  #CASE(%FileType)                          #! Only want files
  #OF  ('VIEW')                             #! ... no views
  #OROF('ALIAS')                            #! ... no alias
    #CYCLE                                  #! next item
  #ENDCASE                                  #! Only got files
  #IF((%CountFiles % 20) = 0)
#INSERT(%DictionaryFilesHeader4a)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N03@(%CountFiles) [%DoFinalCount] %[8]FilePrefix %[36]DoFinalFmName %FileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%DictionaryFilesHeader4a)
#!--------------------------------------------------------------------
#CLOSE (%OutputFile)
#!--------------------------------------------------------------------
#IF (~%DoNotPrint)
  #RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#!--------------------------------------------------------------------
#! RA.2007.12.17 - I know what I need, let me just generate it so I do
#! not have to code it by hand.
#!--------------------------------------------------------------------
#IF(%InitializeGenerate)
#SET(%GenerateFile,UPPER(SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 4)) & '_INITIALIZE_SCHEMA.TXA')
#CREATE(%GenerateFile)
#IF(%GenerateCaller)
#INSERT(%TxaCaller2)
#ENDIF
#IF(%GenerateCalled)
#INSERT(%TxaCalled2)
#ENDIF
#CLOSE (%GenerateFile)
#ENDIF
#!--------------------------------------------------------------------
#IF(%InitializeImport)
#IMPORT(%GenerateFile),REPLACE
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#IF (%RetainFile = 'I don''t want it. Remove the file after printing.')
  #REMOVE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!#GROUP(%DictionaryFilesHeader4a),AUTO
#!#EQUATE(%HFileName,'[PAR-CHI]')
#!#EQUATE(%HFilePrefix,'PREFIX')
#!#EQUATE(%HFile,'FILE NAME')
#!#EQUATE(%HFileDescription, 'DESCRIPTION')
#!
#! SEQ %[7]HFileName %[8]HFilePrefix %[36]HFile %HFileDescription
#!
#!#GROUP(%DictionaryFilesHeader4aEnd)
#!#!--------------------------------------------------------------------
#!#GROUP(%DictionaryFilesHeader4),AUTO
#!#EQUATE(%HFilePrefix,'PREFIX')
#!#EQUATE(%HFileName,'GLOBAL AREA')
#!#EQUATE(%HFile,'FILE NAME')
#!#EQUATE(%HFileDescription, '[PAR-CHI] DESCRIPTION')
#!
#! SEQ %[7]HFilePrefix %[13]HFileName %[36]HFile %HFileDescription
#!
#!#GROUP(%DictionaryFilesHeader4End)
#!--------------------------------------------------------------------
#GROUP(%TxaCaller2)
[PROCEDURE]
NAME init_%DateCaller_database
NOEXPORT
[COMMON]
DESCRIPTION 'Initialize all database tables.'
FROM ABC Source
CATEGORY 'initialize'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('')
%%GenerateOpenClose LONG  (0)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%DataSection
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
WAIT_WINDOW         EQUATE(1)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLOpenWindow WINDOW('Initialize Datatabase'),AT(,,347,26),FONT('Verdana',10,,FONT:regular),CENTER, |
         WALLPAPER('parchment-light-01.gif'),GRAY,DOUBLE
       STRING('Please wait while the program initializes the database tables.'),AT(72,3),TRN
       STRING('This process could take several seconds.'),AT(104,12),TRN
     END
[END]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
  SETCURSOR(Cursor:Wait)
  OPEN(SQLOpenWindow)
  ACCEPT
    IF EVENT() = Event:OpenWindow
  !***WAIT***
#SET(%CountFiles,0)
#FOR(%DoFinal)
  #FIX(%File,%DoFinalFmName)
  #CASE(%FileType)                          #! Only want files
  #OF  ('VIEW')                             #! ... no views
  #OROF('ALIAS')                            #! ... no alias
    #CYCLE                                  #! next item
  #ENDCASE                                  #! Only got files
  #SET(%CountFiles,%CountFiles + 1)
  #SET(%CountOrder,%CountFiles * 10)
  #!----------------------------------------!
  #!----------------------------------------!
  #! RA.2011.04.28 - Get the EXTERNAL name. !
  #!----------------------------------------!
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,LOWER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%aFileUser,LOWER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
  #!
  #SET(%sFileNameInternal, %File)                           #! Internal File Name
  #SET(%sFileNameExternal, %aFileOpt2)                      #! External File Name
  #SET(%sFileName, %sFileNameInternal)
  #IF(%sFileNameExternal <> '')
    #SET(%sFileName, %sFileNameExternal)
  #ENDIF
#!!! %FilePrefix , %File [ %sFileNameInternal , %sFileNameExternal ] %sFileName
  #!----------------------------------------!
  #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
  #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #!----------------------------------------!
  #IF(NOT %filSC)                                           #! RA.2009.02.25
    #SET(%filSC, 'public')                                  #! RA.2009.02.25
  #ENDIF                                                    #! RA.2009.02.25
  #!----------------------------------------!
  #!----------------------------------------!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
  SQLOpenWindow{PROP:TEXT} = 'Initialize Datatabase (%filDB.%filSC.%sFileName)'
[PROCEDURE]
init_%DateCalled_%File
PRIORITY 5200
#ENDFOR
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5300
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
      POST(EVENT:CloseWindow)
    END
  END
  CLOSE(SQLOpenWindow)
  SETCURSOR()
  !***WAIT***
[END]
[END]
#GROUP(%TxaCaller2End)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%TxaCalled2)
#SET(%CountFiles,0)
#FOR(%DoFinal)
  #FIX(%File,%DoFinalFmName)
  #CASE(%FileType)                          #! Only want files
  #OF  ('VIEW')                             #! ... no views
  #OROF('ALIAS')                            #! ... no alias
    #CYCLE                                  #! next item
  #ENDCASE                                  #! Only got files
  #SET(%CountFiles,%CountFiles + 1)
  #SET(%CountOrder,%CountFiles * 10)
[PROCEDURE]
#!NAME init_%@D012@(TODAY())_%@N06@(%CountOrder)_%File
NAME init_%DateCalled_%File
NOEXPORT
[COMMON]
DESCRIPTION '[%DoFinalCount] %FileDescription'
FROM ABC Source
CATEGORY 'initialize'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[FILES]
[OTHERS]
%File
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('')
%%GenerateOpenClose LONG  (1)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  DO OpenFiles

!  CLEAR(%FilePrefix:record)
  #FOR(%Field)
    #CASE(%FieldType)
    #OF  ('MEMO')
    #OROF('BLOB')
    #OROF('STRING')
    #OROF('CSTRING')
    #OROF('PSTRING')
!  %Field = ''
    #ELSE
!  %Field = 0
    #ENDCASE
  #ENDFOR
!  Access:%File.Insert()

  DO CloseFiles
[END]
[END]
#ENDFOR
#GROUP(%TxaCalled2End)
#!--------------------------------------------------------------------
#GROUP(%UTILDictionaryFiles4SchemaEnd)
#!--------------------------------------------------------------------

#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_PostgreSQL_Reset_Schema, '2011.02.11: [DCT2SQL-UTIL] PostgreSQL reset tables procedure'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2011.02.11   Roberto Artigas
#!  *   Added date to routine description.
#! 2010.12.21   Roberto Artigas
#!  *   Added changing window title to file that is currently being processed.
#!  *   Added logic to bypass files with RYB_INIT(NO) - X??? files.
#!  *   Added additional compile / execute option when you want no action.
#!  *   Improve logic to handle files that are not opened correcly.
#!  *   Added NOTEPAD option.
#! 2010.09.27   Roberto Artigas
#!  *   Removed ABC classes references and substituded simple OPEN/CLOSE.
#!  *   Changes to handle 'databases_and_schemas.txt' from the DCT directory.
#!  *   Handle EXTERNAL Table Names (and output accordingly).
#! 2009.02.22    Roberto Artigas Jr
#!  *   Changed to generate schema prefix for tables.
#! 2007.12.29    Roberto Artigas Jr
#!  *   Creates a procedure to reset the PostgreSQL database tables
#!--------------------------------------------------------------------
#PREPARE
#!
#DECLARE(%DictName)                                             #! RA.2010.09.27
#DECLARE(%DictPath)                                             #! RA.2010.09.27
#DECLARE(%nLoc1)                                                #! RA.2010.09.27
#DECLARE(%nLoc2)                                                #! RA.2010.09.27
#DECLARE(%aFileUser)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt1)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt2)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt3)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt4)                                            #! RA.2010.09.27
#!
#SET(%nLoc1,INSTRING('\',%DictionaryFile,1,1))
#LOOP,WHILE(%nLoc1)
  #SET(%nLoc2,%nLoc1)
  #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,%nLoc1+1))
#ENDLOOP
#SET(%DictName,UPPER(SUB(%DictionaryFile,%nLoc2+1,LEN(%DictionaryFile)-%nLoc2-4)))
#SET(%DictPath,UPPER(SUB(%DictionaryFile,1,%nLoc2)))
#!
#DECLARE(%appTables),UNIQUE
#!
#FOR(%File)
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%aFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
  #!------------------------------------------------------------------!
  #! The first option RYB_INIT(NO) controls if a file is initialized. !
  #!------------------------------------------------------------------!
  #SET(%nLoc1,INSTRING('RYB_INIT(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RYB_INIT',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RYB_INIT',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RYB_INIT',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RYB_INIT',4))
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
    #CYCLE
  #ENDCASE
  #!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
    #CYCLE
  #ENDCASE
  #!
  #ADD(%appTables, %File)
#ENDFOR
#ENDPREPARE
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#PREPARE
#EQUATE(%dctsch,'databases_and_schemas.txt')                    #! RA.2009.04.11
#SET(%dctsch, %DictPath & 'databases_and_schemas.txt')          #! RA.2010.09.27
#EQUATE(%dctschRec,'')                                          #! RA.2009.04.11
#DECLARE(%A1,LONG)                                              #! RA.2009.04.11
#DECLARE(%A2,LONG)                                              #! RA.2009.04.11
#DECLARE(%A3,LONG)                                              #! RA.2009.04.11
#!
#DECLARE(%dctUserOptions)
#DECLARE(%dctDatabaseID)
#DECLARE(%dctDatabase)
#DECLARE(%dctSchemaID)
#DECLARE(%dctSchema)
#!
#DECLARE(%dctOptions)
#DECLARE(%dctOpt01)
#DECLARE(%dctOpt02)
#DECLARE(%dctOpt03)
#DECLARE(%dctOpt04)
#!
#DECLARE(%dctDB),MULTI,UNIQUE
#DECLARE(%DBid,%dctDB)
#DECLARE(%DBname,%dctDB)
#DECLARE(%DBtext,%dctDB)
#!
#DECLARE(%dctSC),MULTI,UNIQUE
#DECLARE(%SCid,%dctSC)
#DECLARE(%SCname,%dctSC)
#DECLARE(%SCtext,%dctSC)
#!
#DECLARE(%P,LONG)
#DECLARE(%L,LONG)
#SET(%dctUserOptions,%DictionaryUserOptions)
#!-----------------------------------------------------------------------------------!
#SET(%dctDatabaseID, 1)
#SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctDatabase))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctDatabase, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctDatabase, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctDatabase, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctDB,  %dctOpt02)
    #SET(%DBid,   %dctDatabaseID)
    #SET(%DBname, %dctOpt02)
    #SET(%DBtext, %dctOpt03)
  #ENDIF
  #SET(%dctDatabaseID, %dctDatabaseID + 1)
  #SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#ENDLOOP
#!-----------------------------------------------------------------------------------!
#SET(%dctSchemaID, 1)
#SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctSchema))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctSchema, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctSchema, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctSchema, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctSC,    %dctOpt02)
    #SET(%SCid,     %dctSchemaID)
    #SET(%SCname,   %dctOpt02)
    #SET(%SCtext,   %dctOpt03)
  #ENDIF
  #SET(%dctSchemaID, %dctSchemaID + 1)
  #SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#ENDLOOP
#ENDPREPARE
#!-----------------------------------------------------------------------------------!
#! RA.2009.04.11 - This is procedure that loads the options from a file.             !
#!-----------------------------------------------------------------------------------!
#IF(FILEEXISTS(%dctsch))                                        #! RA.2009.04.11
#!                                                              #! RA.2009.04.11
#OPEN(%dctsch),READ
#LOOP
  #READ(%dctschRec)
  #IF(%dctschRec = %EOF)
    #BREAK
  #ELSE
#!
    #SET(%dctOpt01, '')
    #SET(%A1, 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (01) %A1, %A2, %A3
    #SET(%dctOpt01, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt02, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (02) %A1, %A2, %A3
    #SET(%dctOpt02, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt03, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, LEN(%dctschRec) + 1)
    #SET(%A3, %A2 - %A1)
#!! (03) %A1, %A2, %A3
    #SET(%dctOpt03, SUB(%dctschRec, %A1, %A3))
#!
    #CASE(UPPER(%dctOpt01))
    #OF('DATABASE')
      #FIND(%DBname,%dctOpt02)
      #IF(%DBName = '')
        #SET(%dctDatabaseID, ITEMS(%dctDB) + 1)
        #ADD(%dctDB,  %dctOpt02)
        #SET(%DBid,   %dctDatabaseID)
        #SET(%DBname, %dctOpt02)
        #SET(%DBtext, %dctOpt03)
      #ENDIF
    #OF('SCHEMA')
      #FIND(%SCname,%dctOpt02)
      #IF(%SCName = '')
        #SET(%dctSchemaID, ITEMS(%dctSC) + 1)
        #ADD(%dctSC,  %dctOpt02)
        #SET(%SCid,   %dctSchemaID)
        #SET(%SCname, %dctOpt02)
        #SET(%SCtext, %dctOpt03)
      #ENDIF
    #ENDCASE
  #ENDIF
#ENDLOOP
#CLOSE(%dctsch),READ
#!                                                              #! RA.2009.04.11
#ENDIF                                                          #! RA.2009.04.11
#!-----------------------------------------------------------------------------------!
#!-----------------------------------------------------------------------------------!
#SHEET
  #TAB ('PostgreSQL Reset Tables Procedure Wizard')
    #DISPLAY('The PostgreSQL Reset Tables Procedure Utility.')
    #DISPLAY('Copyright 2007-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will create a procedure to reset all your PostgreSQL tables.')
    #DISPLAY('To specify how you want the procedure constructed, click on the Next button.')
  #ENDTAB
  #TAB ('PostgreSQL Reset Tables Procedure Wizard - Reset Tables'), FINISH(1)
    #DISPLAY('You can reset all file in your dictionary, or you can select individual files to reset.')
    #DISPLAY('')
    #PROMPT ('Reset all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('PostgreSQL Reset Tables Procedure Wizard - Select Reset Tables'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('Table Selection', FROM (%appTables)), %DictionaryReportFileSelection, INLINE, SELECTION('Table Selection')
  #ENDTAB
  #TAB ('PostgreSQL Reset Tables Procedure Wizard - Prefix or File'), FINISH(1)
    #DISPLAY('Use File Prefix or File Name.')
    #DISPLAY('')
    #PROMPT ('Use File Prefix or File Name?', OPTION), %PrefixFile, DEFAULT('File Prefix')
    #PROMPT ('File Prefix', RADIO)
    #PROMPT ('File Name', RADIO)
    #DISPLAY('')
    #DISPLAY('Automatically handles EXTERNAL names.')
    #DISPLAY('')
#!    #PROMPT('Generate EXTERNAL Column Name',CHECK),%UseExtFieldName,AT(10),DEFAULT(0)
#!    #ENABLE(%UseExtFieldName)
#!      #PROMPT('Generate Column in Quotes',CHECK),%UseExtFieldQuote,AT(25),DEFAULT(0)
#!    #ENDENABLE
  #ENDTAB
  #TAB ('PostgreSQL Reset Tables Procedure Wizard - Generate Procedure'), FINISH(1)
    #DISPLAY('Generate the PostgreSQL reset procedure.')
    #DISPLAY('')
    #PROMPT ('Generate reset procedure.', CHECK), %InitializeGenerate, DEFAULT(1), AT(10)
    #PROMPT ('Import reset procedure.', CHECK), %InitializeImport, DEFAULT(0), AT(10)
    #DISPLAY('')
  #ENDTAB
  #TAB ('PostgreSQL Reset Tables Procedure Wizard - Finally...')
    #DISPLAY ('This concludes the PostgreSQL reset table wizard.')
    #DISPLAY ('Click on the Finish button to generate the procedure file.')
  #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%filName,%ReportedFiles)
#DECLARE(%filDB,%ReportedFiles)
#DECLARE(%filSC,%ReportedFiles)
#!
#DECLARE(%sFileName)                                                    #! RA.2010.09.27
#DECLARE(%sFileNameInternal)                                            #! RA.2010.09.27
#DECLARE(%sFileNameExternal)                                            #! RA.2010.09.27
#!
#DECLARE(%OutputFile)
#DECLARE(%CountFiles)
#DECLARE(%txaLine)
#EQUATE (%AtColPos, 19)
#!
#EQUATE (%AtColPos1, 35)                                                #! RA.2010.09.27
#EQUATE (%AtColPos2, 91)                                                #! RA.2010.09.27
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%appTables)
    #FIX (%File, %appTables)
    #ADD (%ReportedFiles, %appTables)
    #SET (%filName, %appTables)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #FIX (%File, %DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
    #SET (%filName, %DictionaryReportFileSelection)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#! RA.2007.12.29 - Generate so I do not have to code it by hand.
#!--------------------------------------------------------------------
#IF(%InitializeGenerate)
#SET(%OutputFile, UPPER(SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 4)) & '_POSTGRESQL_RESET.TXA')
#CREATE (%OutputFile)
#INSERT(%TxaPostgreSqlResetSchema)
#CLOSE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#IF(%InitializeImport)
#IMPORT(%OutputFile),REPLACE
#ELSE
#RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%TxaPostgreSqlResetSchema)
[PROCEDURE]
NAME PostgreSQL_Tables_Reset
NOEXPORT
[COMMON]
DESCRIPTION '%@D010.@(TODAY()): Reset all database tables.'
FROM ABC Source
CATEGORY 'PostgreSQL'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[FILES]
[OTHERS]
  #FOR(%ReportedFiles)                                      #! Generate all selected list
    #FIX(%File,%ReportedFiles)                              #! Just in case you need something
%ReportedFiles
  #ENDFOR
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('')
%%GenerateOpenClose LONG  (0)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%DataSection
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
WAIT_WINDOW         EQUATE(1)
RESET_SEQUENCE      EQUATE(0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLOpenWindow WINDOW('Reseting Datatabase'),AT(,,347,26),FONT('Verdana',10,,FONT:regular),CENTER,WALLPAPER('parchment-light-01.gif'), |
         TILED,GRAY,DOUBLE
       STRING('Please wait while the program resets the database tables.'),AT(83,3),TRN
       STRING('This process could take several seconds.'),AT(108,12),TRN
     END
[END]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
  SETCURSOR(Cursor:Wait)
  OPEN(SQLOpenWindow)
  ACCEPT
    IF EVENT() = Event:OpenWindow
  !***WAIT***

  COMPILE('!***RESET-SEQUENCE-NEEDED***', RESET_SEQUENCE)
#!
#!
  #SET(%CountFiles,0)
  #FOR(%ReportedFiles)                                      #! Generate all selected list
    #FIX(%File,%ReportedFiles)                              #! Just in case you need something
    #!----------------------------------------!
    #! RA.2010.09.27 - Get the EXTERNAL name. !
    #!----------------------------------------!
    #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
    #SET(%aFileUser,LOWER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
    #!SET(%aFileUser,LOWER(EXTRACT(%FileUserOptions,'RASQL')))
    #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
    #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
    #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
    #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
     #!
    #SET(%sFileNameInternal, %File)                         #! Internal File Name
    #SET(%sFileNameExternal, %aFileOpt2)                    #! External File Name
    #SET(%sFileName, %sFileNameInternal)
    #IF(%sFileNameExternal <> '')
      #SET(%sFileName, %sFileNameExternal)
    #ENDIF
#!!! %FilePrefix , %File [ %sFileNameInternal , %sFileNameExternal ] %sFileName
    #!----------------------------------------!
    #!----------------------------------------!
    #IF(NOT %filSC)                                         #! RA.2009.02.25
      #SET(%filSC, 'public')                                #! RA.2009.02.25
    #ENDIF                                                  #! RA.2009.02.25
    #!
    #IF((%CountFiles % 10) = 0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
    #ENDIF
  SQLOpenWindow{PROP:TEXT} = 'Reset Tables and Sequences (%filDB.%filSC.%sFileName)'
  OPEN(%ReportedFiles) #<! [%FilePrefix:%ReportedFiles] %filDB.%filSC.%sFileName
  IF(ERRORCODE()) THEN
    STOP('OPEN(%ReportedFiles): %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
  ELSE
    %ReportedFiles{PROP:SQL} = 'DELETE FROM %filSC.%sFileName;'
    IF(ERRORCODE()) THEN
      STOP('DELETE: %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
    END
    #IF(%PrefixFile = 'File Prefix')
    %ReportedFiles{PROP:SQL} = 'ALTER SEQUENCE %filSC.%FilePrefix_id_seq RESTART WITH 1;'
    #ELSE
    %ReportedFiles{PROP:SQL} = 'ALTER SEQUENCE %filSC.%sFileName_id_seq RESTART WITH 1;'
    #ENDIF
    IF(ERRORCODE()) THEN
      STOP('SEQUENCE: %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
    END
    CLOSE(%ReportedFiles)
  END
  !
  #SET(%CountFiles,%CountFiles + 1)
  #ENDFOR
  #SET(%CountFiles,ITEMS(%ReportedFiles))
  ! There are %CountFiles tables cleared with sequences reset.
#!
#!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5300
PROPERTY:END
  !***RESET-SEQUENCE-NEEDED***

  COMPILE('!***WAIT***', WAIT_WINDOW)
      POST(EVENT:CloseWindow)
    END
  END
  CLOSE(SQLOpenWindow)
  SETCURSOR()
  !***WAIT***
[END]
[END]
#GROUP(%TxaPostgreSqlResetSchemaEnd)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%UTILPostgreSQLResetSchemaEnd)
#!--------------------------------------------------------------------

#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_PostgreSQL_Vacuum_Schema, '2011.02.11: [DCT2SQL-UTIL] PostgreSQL vacuum tables procedure'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2011.02.11   Roberto Artigas
#!  *   Added date to routine description.
#! 2010.12.21 - Roberto Artigas
#!  *   Added compile / execute options to prevent accidents when not needed.
#!  *   Added NOTEPAD option to show generated file.
#!  *   Added logic to bypass files with RYB_INIT(NO) - X??? files.
#!  *   Improved open long and report open errors when necessary.
#!  *   Added file name on title of processing window to tell you something is going on.
#! 2010.09.27   Roberto Artigas
#!  *   Removed ABC classes references and substituded simple OPEN/CLOSE.
#!  *   Changes to handle 'databases_and_schemas.txt' from the DCT directory.
#!  *   Handle EXTERNAL Table Names (and output accordingly).
#! 2009.02.22    Roberto Artigas Jr
#!  *   Changed to schema generation.
#! 2007.12.29    Roberto Artigas Jr
#!  *   Creates a procedure to vacuum the PostgreSQL database tables
#!--------------------------------------------------------------------
#PREPARE
#!
#DECLARE(%DictName)                                             #! RA.2010.09.27
#DECLARE(%DictPath)                                             #! RA.2010.09.27
#DECLARE(%nLoc1)                                                #! RA.2010.09.27
#DECLARE(%nLoc2)                                                #! RA.2010.09.27
#DECLARE(%aFileUser)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt1)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt2)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt3)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt4)                                            #! RA.2010.09.27
#!
#SET(%nLoc1,INSTRING('\',%DictionaryFile,1,1))
#LOOP,WHILE(%nLoc1)
  #SET(%nLoc2,%nLoc1)
  #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,%nLoc1+1))
#ENDLOOP
#SET(%DictName,UPPER(SUB(%DictionaryFile,%nLoc2+1,LEN(%DictionaryFile)-%nLoc2-4)))
#SET(%DictPath,UPPER(SUB(%DictionaryFile,1,%nLoc2)))
#!
#DECLARE(%appTables),UNIQUE
#!
#FOR(%File)
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%aFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
  #!------------------------------------------------------------------!
  #! The first option RYB_INIT(NO) controls if a file is initialized. !
  #!------------------------------------------------------------------!
  #SET(%nLoc1,INSTRING('RYB_INIT(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RYB_INIT',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RYB_INIT',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RYB_INIT',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RYB_INIT',4))
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
    #CYCLE
  #ENDCASE
  #!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
    #CYCLE
  #ENDCASE
  #!
  #ADD(%appTables, %File)
#ENDFOR
#ENDPREPARE
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#PREPARE
#EQUATE(%dctsch,'databases_and_schemas.txt')                    #! RA.2009.04.11
#SET(%dctsch, %DictPath & 'databases_and_schemas.txt')          #! RA.2010.09.27
#EQUATE(%dctschRec,'')                                          #! RA.2009.04.11
#DECLARE(%A1,LONG)                                              #! RA.2009.04.11
#DECLARE(%A2,LONG)                                              #! RA.2009.04.11
#DECLARE(%A3,LONG)                                              #! RA.2009.04.11
#!
#DECLARE(%dctUserOptions)
#DECLARE(%dctDatabaseID)
#DECLARE(%dctDatabase)
#DECLARE(%dctSchemaID)
#DECLARE(%dctSchema)
#!
#DECLARE(%dctOptions)
#DECLARE(%dctOpt01)
#DECLARE(%dctOpt02)
#DECLARE(%dctOpt03)
#DECLARE(%dctOpt04)
#!
#DECLARE(%dctDB),MULTI,UNIQUE
#DECLARE(%DBid,%dctDB)
#DECLARE(%DBname,%dctDB)
#DECLARE(%DBtext,%dctDB)
#!
#DECLARE(%dctSC),MULTI,UNIQUE
#DECLARE(%SCid,%dctSC)
#DECLARE(%SCname,%dctSC)
#DECLARE(%SCtext,%dctSC)
#!
#DECLARE(%P,LONG)
#DECLARE(%L,LONG)
#SET(%dctUserOptions,%DictionaryUserOptions)
#!-----------------------------------------------------------------------------------!
#SET(%dctDatabaseID, 1)
#SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctDatabase))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctDatabase, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctDatabase, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctDatabase, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctDB,  %dctOpt02)
    #SET(%DBid,   %dctDatabaseID)
    #SET(%DBname, %dctOpt02)
    #SET(%DBtext, %dctOpt03)
  #ENDIF
  #SET(%dctDatabaseID, %dctDatabaseID + 1)
  #SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#ENDLOOP
#!-----------------------------------------------------------------------------------!
#SET(%dctSchemaID, 1)
#SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctSchema))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctSchema, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctSchema, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctSchema, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctSC,    %dctOpt02)
    #SET(%SCid,     %dctSchemaID)
    #SET(%SCname,   %dctOpt02)
    #SET(%SCtext,   %dctOpt03)
  #ENDIF
  #SET(%dctSchemaID, %dctSchemaID + 1)
  #SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#ENDLOOP
#ENDPREPARE
#!-----------------------------------------------------------------------------------!
#! RA.2009.04.11 - This is procedure that loads the options from a file.             !
#!-----------------------------------------------------------------------------------!
#IF(FILEEXISTS(%dctsch))                                        #! RA.2009.04.11
#!                                                              #! RA.2009.04.11
#OPEN(%dctsch),READ
#LOOP
  #READ(%dctschRec)
  #IF(%dctschRec = %EOF)
    #BREAK
  #ELSE
#!
    #SET(%dctOpt01, '')
    #SET(%A1, 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (01) %A1, %A2, %A3
    #SET(%dctOpt01, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt02, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (02) %A1, %A2, %A3
    #SET(%dctOpt02, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt03, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, LEN(%dctschRec) + 1)
    #SET(%A3, %A2 - %A1)
#!! (03) %A1, %A2, %A3
    #SET(%dctOpt03, SUB(%dctschRec, %A1, %A3))
#!
    #CASE(UPPER(%dctOpt01))
    #OF('DATABASE')
      #FIND(%DBname,%dctOpt02)
      #IF(%DBName = '')
        #SET(%dctDatabaseID, ITEMS(%dctDB) + 1)
        #ADD(%dctDB,  %dctOpt02)
        #SET(%DBid,   %dctDatabaseID)
        #SET(%DBname, %dctOpt02)
        #SET(%DBtext, %dctOpt03)
      #ENDIF
    #OF('SCHEMA')
      #FIND(%SCname,%dctOpt02)
      #IF(%SCName = '')
        #SET(%dctSchemaID, ITEMS(%dctSC) + 1)
        #ADD(%dctSC,  %dctOpt02)
        #SET(%SCid,   %dctSchemaID)
        #SET(%SCname, %dctOpt02)
        #SET(%SCtext, %dctOpt03)
      #ENDIF
    #ENDCASE
  #ENDIF
#ENDLOOP
#CLOSE(%dctsch),READ
#!                                                              #! RA.2009.04.11
#ENDIF                                                          #! RA.2009.04.11
#!-----------------------------------------------------------------------------------!
#!-----------------------------------------------------------------------------------!
#SHEET
  #TAB ('PostgreSQL Vacuum Tables Procedure Wizard')
    #DISPLAY('The PostgreSQL Vacuum Tables Procedure Utility.')
    #DISPLAY('Copyright 2007-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will create a procedure to vacuum all your PostgreSQL tables.')
    #DISPLAY('To specify how you want the procedure constructed, click on the Next button.')
  #ENDTAB
  #TAB ('PostgreSQL Vacuum Tables Procedure Wizard - Vacuum Tables'), FINISH(1)
    #DISPLAY('You can vacuum all file in your dictionary, or you can select individual files to vacuum.')
    #DISPLAY('')
    #PROMPT ('Vacuum all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('PostgreSQL Vacuum Tables Procedure Wizard - Select Vacuum Tables'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('Table Selection', FROM (%appTables)), %DictionaryReportFileSelection, INLINE, SELECTION('Table Selection')
  #ENDTAB
  #TAB ('PostgreSQL Vacuum Tables Procedure Wizard - Generate Procedure'), FINISH(1)
    #DISPLAY('Generate the PostgreSQL vacuum procedure.')
    #DISPLAY('')
    #PROMPT ('Generate vacuum procedure.', CHECK), %InitializeGenerate, DEFAULT(1), AT(10)
    #PROMPT ('Import vacuum procedure.', CHECK), %InitializeImport, DEFAULT(0), AT(10)
    #DISPLAY('')
  #ENDTAB
  #TAB ('PostgreSQL Vacuum Tables Procedure Wizard - Finally...')
    #DISPLAY ('This concludes the PostgreSQL vacuum table wizard.')
    #DISPLAY ('Click on the Finish button to generate the procedure file.')
  #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%filName,%ReportedFiles)
#DECLARE(%filDB,%ReportedFiles)
#DECLARE(%filSC,%ReportedFiles)
#!
#DECLARE(%sFileName)                                                    #! RA.2010.09.27
#DECLARE(%sFileNameInternal)                                            #! RA.2010.09.27
#DECLARE(%sFileNameExternal)                                            #! RA.2010.09.27
#!
#DECLARE(%OutputFile)
#DECLARE(%CountFiles)
#DECLARE(%txaLine)
#EQUATE (%AtColPos, 19)
#!
#EQUATE (%AtColPos1, 35)                                                #! RA.2010.09.27
#EQUATE (%AtColPos2, 91)                                                #! RA.2010.09.27
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%appTables)
    #FIX (%File, %appTables)
    #ADD (%ReportedFiles, %appTables)
    #SET (%filName, %appTables)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #FIX (%File, %DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
    #SET (%filName, %DictionaryReportFileSelection)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#! RA.2007.12.29 - Generate so I do not have to code it by hand.
#!--------------------------------------------------------------------
#IF(%InitializeGenerate)
#SET(%OutputFile, UPPER(SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 4)) & '_POSTGRESQL_VACUUM.TXA')
#CREATE (%OutputFile)
#INSERT(%TxaPostgreSqlVacuumSchema)
#CLOSE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#IF(%InitializeImport)
#IMPORT(%OutputFile),REPLACE
#ELSE
#RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%TxaPostgreSqlVacuumSchema)
[PROCEDURE]
NAME PostgreSQL_Tables_Vacuum
NOEXPORT
[COMMON]
DESCRIPTION '%@D010.@(TODAY()): Vacuum all database tables.'
FROM ABC Source
CATEGORY 'PostgreSQL'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[FILES]
[OTHERS]
  #FOR(%ReportedFiles)                                      #! Generate all selected list
    #FIX(%File,%ReportedFiles)                              #! Just in case you need something
%ReportedFiles
  #ENDFOR
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('')
%%GenerateOpenClose LONG  (0)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%DataSection
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
WAIT_WINDOW         EQUATE(1)
VACUUM_TABLES       EQUATE(0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLOpenWindow WINDOW('Vacuuming Datatabase'),AT(,,347,26),FONT('Verdana',10,,FONT:regular),CENTER,WALLPAPER('parchment-light-01.gif'), |
         TILED,GRAY,DOUBLE
       STRING('Please wait while the program vacuums the database tables.'),AT(79,3),TRN
       STRING('This process could take several seconds.'),AT(107,12),TRN
     END
[END]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
  SETCURSOR(Cursor:Wait)
  OPEN(SQLOpenWindow)
  ACCEPT
    IF EVENT() = Event:OpenWindow
  !***WAIT***

  COMPILE('!***VACUUM-TABLES-NEEDED***', VACUUM_TABLES)
#!
#!
  #SET(%CountFiles,0)
  #FOR(%ReportedFiles)                                      #! Generate all selected list
    #FIX(%File,%ReportedFiles)                              #! Just in case you need something
    #!----------------------------------------!
    #! RA.2010.09.27 - Get the EXTERNAL name. !
    #!----------------------------------------!
    #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
    #SET(%aFileUser,LOWER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
    #!SET(%aFileUser,LOWER(EXTRACT(%FileUserOptions,'RASQL')))
    #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
    #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
    #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
    #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
    #!
    #SET(%sFileNameInternal, %File)                         #! Internal File Name
    #SET(%sFileNameExternal, %aFileOpt2)                    #! External File Name
    #SET(%sFileName, %sFileNameInternal)
    #IF(%sFileNameExternal <> '')
      #SET(%sFileName, %sFileNameExternal)
    #ENDIF
#!!! %FilePrefix , %File [ %sFileNameInternal , %sFileNameExternal ] %sFileName
    #!----------------------------------------!
    #!----------------------------------------!
    #IF(NOT %filSC)                                         #! RA.2009.02.25
      #SET(%filSC, 'public')                                #! RA.2009.02.25
    #ENDIF                                                  #! RA.2009.02.25
    #!
    #IF((%CountFiles % 10) = 0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
    #ENDIF
  SQLOpenWindow{PROP:TEXT} = 'Vacuum Tables (%filDB.%filSC.%sFileName)'
  OPEN(%ReportedFiles) #<! [%FilePrefix:%ReportedFiles] %filDB.%filSC.%sFileName
  IF(ERRORCODE()) THEN
    STOP('OPEN(%ReportedFiles): %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
  ELSE
    %ReportedFiles{PROP:SQL} = 'VACUUM FULL ANALYZE %filSC.%sFileName;'
    IF(ERRORCODE()) THEN
      STOP('VACUUM: %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
    END
    CLOSE(%ReportedFiles)
  END
  !
  #SET(%CountFiles,%CountFiles + 1)
  #ENDFOR
  #SET(%CountFiles,ITEMS(%ReportedFiles))
  ! There are %CountFiles tables vacuumed.
#!
#!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5300
PROPERTY:END
  !***VACUUM-TABLES-NEEDED***

  COMPILE('!***WAIT***', WAIT_WINDOW)
      POST(EVENT:CloseWindow)
    END
  END
  CLOSE(SQLOpenWindow)
  SETCURSOR()
  !***WAIT***
[END]
[END]
#GROUP(%TxaPostgreSqlVacuumSchemaEnd)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%UTILPostgreSQLVacuumSchemaEnd)
#!--------------------------------------------------------------------

#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#UTILITY (UTIL_DictionaryFiles5, '2008.06.02: [DCT2SQL-UTIL] Print Dictionary Driver Options'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2002.06.02   Roberto Artigas Jr
#!  *   Now the utility pops up a wordpad text file rather than printing
#!      directly to the printer. Much nicer to preview before you print.
#!--------------------------------------------------------------------
#SHEET
  #TAB ('Dictionary Print Wizard')
    #DISPLAY('The Dictionary Overview Print Utility.')
    #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will generate a report of the contents of your current dictionary.')
    #DISPLAY('To specify how you want the report constructed, click on the Next button.')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), FINISH(1)
    #DISPLAY('The dictionary report wizard creates a text file, which is then sent to your printer.')
    #DISPLAY('')
    #DISPLAY('You can, if you wish, have this wizard delete the file when it''s done, or you can keep the file')
    #DISPLAY('for later use.')
    #DISPLAY('')
    #PROMPT ('What do you want to do with the file?', OPTION), %RetainFile
    #PROMPT ('I don''t want it. Remove the file after printing.', RADIO)
    #PROMPT ('I might need it. Keep the file around.', RADIO)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), WHERE(%RetainFile = 'I might need it. Keep the file around.'), FINISH(1)
    #PROMPT ('What name do you want the text file to have?', OPTION), %WhatName
    #PROMPT ('Use the dictionary name, with a .TXT extension.', RADIO)
    #PROMPT ('Let me supply my own file name.', RADIO)
    #ENABLE (%WhatName = 'Let me supply my own file name.')
      #PROMPT ('Please enter the name of the text file to be generated.', @S100), %NewName
    #ENDENABLE
    #PROMPT ('Don''t print this report automatically. I''ll print it from the text file later.', CHECK), %DoNotPrint, AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Reported Files'), FINISH(1)
    #DISPLAY('You can report on each file in your dictionary, or you can select individual files to report on.')
    #DISPLAY('')
    #PROMPT ('Report on all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Reported Files'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('File Selection', FROM (%File)), %DictionaryReportFileSelection, INLINE, SELECTION('File Selection')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Finally...')
    #DISPLAY ('This concludes the dictionary report wizard.')
    #DISPLAY ('Click on the Finish button to generate the text file.')
  #ENDTAB
#ENDSHEET
#!#BOXED('Hide')
#!  #BUTTON('Processed Files'),MULTI(%DoTheseFiles, %DoFilePrefix & ' ' & %DoFileName & ' ' & %DoFile),INLINE
#!    #PROMPT('File Prefix: ',@s10),%DoFilePrefix,UNIQUE,REQ
#!    #PROMPT('Global Name Area: ',@s20),%DoFileName,REQ
#!    #PROMPT('File Name: ',@s30),%DoFile,REQ
#!  #ENDBUTTON
#!#ENDBOXED
#!--------------------------------------------------------------------
#DECLARE(%OutputFile)
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%WorkString)
#DECLARE(%CountFiles)
#DECLARE(%DoTheseFiles),UNIQUE
#DECLARE(%DoFilePrefix,%DoTheseFiles)
#DECLARE(%DoFileName,%DoTheseFiles)
#DECLARE(%DoFile,%DoTheseFiles)
#DECLARE(%DoFileDescription,%DoTheseFiles)          #! RAS.2003.07.22
#!--------------------------------------------------------------------
#IF (%WhatName = 'Use the dictionary name, with a .TXT extension.')
  #SET (%OutputFile, SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 3) & 'TXT')
#ELSE
  #SET (%OutputFile, %NewName)
#ENDIF
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%File)
    #ADD (%ReportedFiles, %File)
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR (%ReportedFiles)
  #FIX(%File,%ReportedFiles)
  #SET(%CountFiles,%CountFiles + 1)
  #ADD(%DoTheseFiles, %CountFiles)
  #SET(%DoFilePrefix, %FilePrefix)
  #SET(%DoFileName, %FileName)
  #SET(%DoFile, %File)
  #SET(%DoFileDescription, '[' & %FileDriver & '] ' & %FileDriverParameter)        #! RAS.2008.08.22
#ENDFOR
#!--------------------------------------------------------------------
#EQUATE (%DoSort,1)
#EQUATE (%I,0)
#EQUATE (%W1FilePrefix,'')
#EQUATE (%W1FileName,'')
#EQUATE (%W1File,'')
#EQUATE (%W1FileDescription,'')                     #! RAS.2003.07.22
#EQUATE (%W2FilePrefix,'')
#EQUATE (%W2FileName,'')
#EQUATE (%W2File,'')
#EQUATE (%W2FileDescription,'')                     #! RAS.2003.07.22
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoTheseFiles))
    #SELECT(%DoTheseFiles,%I-1)
    #SET(%W1FilePrefix,%DoFilePrefix)
    #SET(%W1FileName,%DoFileName)
    #SET(%W1File,%DoFile)
    #SET(%W1FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #SELECT(%DoTheseFiles,%I)
    #SET(%W2FilePrefix,%DoFilePrefix)
    #SET(%W2FileName,%DoFileName)
    #SET(%W2File,%DoFile)
    #SET(%W2FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #IF(%W1FilePrefix > %W2FilePrefix)
      #SET(%DoSort,1)
      #SET(%DoFilePrefix,%W1FilePrefix)
      #SET(%DoFileName,%W1FileName)
      #SET(%DoFile,%W1File)
      #SET(%DoFileDescription,%W1FileDescription)   #! RAS.2003.07.22
      #SELECT(%DoTheseFiles,%I-1)
      #SET(%DoFilePrefix,%W2FilePrefix)
      #SET(%DoFileName,%W2FileName)
      #SET(%DoFile,%W2File)
      #SET(%DoFileDescription,%W2FileDescription)   #! RAS.2003.07.22
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#CREATE (%OutputFile)
#SET(%WorkString,'Dictionary Files Report')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!#INSERT(%DictionaryFilesHeader)
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoTheseFiles)
  #IF((%CountFiles % 20) = 0)
#INSERT(%DictionaryFilesHeader5)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N3@(%CountFiles)  %[8]DoFilePrefix %[20]DoFileName %[30]DoFile %DoFileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%DictionaryFilesHeader5)
#CLOSE (%OutputFile)
#!--------------------------------------------------------------------
#IF (~%DoNotPrint)
  #RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#IF (%RetainFile = 'I don''t want it. Remove the file after printing.')
  #REMOVE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#GROUP(%DictionaryFilesHeader5),AUTO
#EQUATE(%HFilePrefix,'PREFIX')
#EQUATE(%HFileName,'GLOBAL AREA')
#EQUATE(%HFile,'FILE NAME')
#EQUATE(%HFileDescription, 'DESCRIPTION')

 SEQ  %[8]HFilePrefix %[20]HFileName %[30]HFile %HFileDescription

#GROUP(%DictionaryFilesHeader5End)
#!--------------------------------------------------------------------
#GROUP(%UTILDictionaryFiles5End)
#!---------------------------------------------------------------------

#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#UTILITY (UTIL_DictionaryFiles6, '2009.04.11: [DCT2SQL-UTIL] Print Dictionary Database File Options'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2009.04.11   Roberto Artigas
#!  *   Now uses the dictionary options or the 'databases_and_schemas.txt' file
#!      for the database names and schema names.
#! 2002.06.02   Roberto Artigas
#!  *   Now the utility pops up a wordpad text file rather than printing
#!      directly to the printer. Much nicer to preview before you print.
#!--------------------------------------------------------------------
#SHEET
  #TAB ('Dictionary Print Wizard')
    #DISPLAY('The Dictionary Overview Print Utility.')
    #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will generate a report of the contents of your current dictionary.')
    #DISPLAY('To specify how you want the report constructed, click on the Next button.')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), FINISH(1)
    #DISPLAY('The dictionary report wizard creates a text file, which is then sent to your printer.')
    #DISPLAY('')
    #DISPLAY('You can, if you wish, have this wizard delete the file when it''s done, or you can keep the file')
    #DISPLAY('for later use.')
    #DISPLAY('')
    #PROMPT ('What do you want to do with the file?', OPTION), %RetainFile
    #PROMPT ('I don''t want it. Remove the file after printing.', RADIO)
    #PROMPT ('I might need it. Keep the file around.', RADIO)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), WHERE(%RetainFile = 'I might need it. Keep the file around.'), FINISH(1)
    #PROMPT ('What name do you want the text file to have?', OPTION), %WhatName
    #PROMPT ('Use the dictionary name, with a .TXT extension.', RADIO)
    #PROMPT ('Let me supply my own file name.', RADIO)
    #ENABLE (%WhatName = 'Let me supply my own file name.')
      #PROMPT ('Please enter the name of the text file to be generated.', @S100), %NewName
    #ENDENABLE
    #PROMPT ('Don''t print this report automatically. I''ll print it from the text file later.', CHECK), %DoNotPrint, AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Reported Files'), FINISH(1)
    #DISPLAY('You can report on each file in your dictionary, or you can select individual files to report on.')
    #DISPLAY('')
    #PROMPT ('Report on all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Reported Files'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('File Selection', FROM (%File)), %DictionaryReportFileSelection, INLINE, SELECTION('File Selection')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Finally...')
    #DISPLAY ('This concludes the dictionary report wizard.')
    #DISPLAY ('Click on the Finish button to generate the text file.')
  #ENDTAB
#ENDSHEET
#!#BOXED('Hide')
#!  #BUTTON('Processed Files'),MULTI(%DoTheseFiles, %DoFilePrefix & ' ' & %DoFileName & ' ' & %DoFile),INLINE
#!    #PROMPT('File Prefix: ',@s10),%DoFilePrefix,UNIQUE,REQ
#!    #PROMPT('Global Name Area: ',@s20),%DoFileName,REQ
#!    #PROMPT('File Name: ',@s30),%DoFile,REQ
#!  #ENDBUTTON
#!#ENDBOXED
#!--------------------------------------------------------------------
#DECLARE(%OutputFile)
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%WorkString)
#DECLARE(%CountFiles)
#DECLARE(%DoTheseFiles),UNIQUE
#DECLARE(%DoFilePrefix,%DoTheseFiles)
#DECLARE(%DoFileName,%DoTheseFiles)
#DECLARE(%DoFile,%DoTheseFiles)
#DECLARE(%DoFileDescription,%DoTheseFiles)          #! RAS.2003.07.22
#!--------------------------------------------------------------------
#DECLARE(%dctUserOptions)
#DECLARE(%dctDatabaseID)
#DECLARE(%dctDatabase)
#DECLARE(%dctSchemaID)
#DECLARE(%dctSchema)
#!
#DECLARE(%dctOptions)
#DECLARE(%dctOpt01)
#DECLARE(%dctOpt02)
#DECLARE(%dctOpt03)
#DECLARE(%dctOpt04)
#!
#EQUATE(%dctsch,'databases_and_schemas.txt')                    #! RA.2009.04.11
#EQUATE(%dctschRec,'')                                          #! RA.2009.04.11
#DECLARE(%A1,LONG)                                              #! RA.2009.04.11
#DECLARE(%A2,LONG)                                              #! RA.2009.04.11
#DECLARE(%A3,LONG)                                              #! RA.2009.04.11
#!
#DECLARE(%dctDB),MULTI,UNIQUE
#DECLARE(%DBid,%dctDB)
#DECLARE(%DBname,%dctDB)
#DECLARE(%DBtext,%dctDB)
#!
#DECLARE(%dctSC),MULTI,UNIQUE
#DECLARE(%SCid,%dctSC)
#DECLARE(%SCname,%dctSC)
#DECLARE(%SCtext,%dctSC)
#!
#DECLARE(%P,LONG)
#DECLARE(%L,LONG)
#SET(%dctUserOptions,%DictionaryUserOptions)
#!--------------------------------------------------------------------
#IF (%WhatName = 'Use the dictionary name, with a .TXT extension.')
  #SET (%OutputFile, SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 3) & 'TXT')
#ELSE
  #SET (%OutputFile, %NewName)
#ENDIF
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%File)
    #ADD (%ReportedFiles, %File)
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#SET(%dctDatabaseID, 1)
#SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctDatabase))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctDatabase, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctDatabase, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctDatabase, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctDB,  %dctOpt02)
    #SET(%DBid,   %dctDatabaseID)
    #SET(%DBname, %dctOpt02)
    #SET(%DBtext, %dctOpt03)
  #ENDIF
  #SET(%dctDatabaseID, %dctDatabaseID + 1)
  #SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#ENDLOOP
#!--------------------------------------------------------------------
#SET(%dctSchemaID, 1)
#SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctSchema))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctSchema, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctSchema, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctSchema, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctSC,  %dctOpt02)
    #SET(%SCid,   %dctSchemaID)
    #SET(%SCname, %dctOpt02)
    #SET(%SCtext, %dctOpt03)
  #ENDIF
  #SET(%dctSchemaID, %dctSchemaID + 1)
  #SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#ENDLOOP
#!--------------------------------------------------------------------
#IF(FILEEXISTS(%dctsch))
#!
#OPEN(%dctsch),READ
#LOOP
  #READ(%dctschRec)
  #IF(%dctschRec = %EOF)
    #BREAK
  #ELSE
#!
    #SET(%dctOpt01, '')
    #SET(%A1, 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (01) %A1, %A2, %A3
    #SET(%dctOpt01, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt02, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (02) %A1, %A2, %A3
    #SET(%dctOpt02, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt03, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, LEN(%dctschRec) + 1)
    #SET(%A3, %A2 - %A1)
#!! (03) %A1, %A2, %A3
    #SET(%dctOpt03, SUB(%dctschRec, %A1, %A3))
#!
    #CASE(UPPER(%dctOpt01))
    #OF('DATABASE')
      #FIND(%DBname,%dctOpt02)
      #IF(%DBName = '')
        #SET(%dctDatabaseID, ITEMS(%dctDB) + 1)
        #ADD(%dctDB,  %dctOpt02)
        #SET(%DBid,   %dctDatabaseID)
        #SET(%DBname, %dctOpt02)
        #SET(%DBtext, %dctOpt03)
      #ENDIF
    #OF('SCHEMA')
      #FIND(%SCname,%dctOpt02)
      #IF(%SCName = '')
        #SET(%dctSchemaID, ITEMS(%dctSC) + 1)
        #ADD(%dctSC,  %dctOpt02)
        #SET(%SCid,   %dctSchemaID)
        #SET(%SCname, %dctOpt02)
        #SET(%SCtext, %dctOpt03)
      #ENDIF
    #ENDCASE
  #ENDIF
#ENDLOOP
#CLOSE(%dctsch),READ
#!
#ENDIF
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR (%ReportedFiles)
  #FIX(%File,%ReportedFiles)
  #SET(%CountFiles,%CountFiles + 1)
  #ADD(%DoTheseFiles, %CountFiles)
  #SET(%DoFilePrefix, %FilePrefix)
  #SET(%DoFileName, %FileName)
  #SET(%DoFile, %File)
  #!
  #SET(%dctOpt01, '')
  #SET(%dctOpt02, '')
  #SET(%dctOpt03, '')
  #SET(%dctOpt04, '')
  #SET(%dctOpt01, EXTRACT(%FileUserOptions, 'DATABASE', 1))
  #SET(%dctOpt02, EXTRACT(%FileUserOptions, 'DATABASE', 2))
  #SET(%dctOpt03, EXTRACT(%FileUserOptions, 'SCHEMA'  , 1))
  #SET(%dctOpt04, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #!
  #IF(NOT %dctOpt02)
    #SET(%dctOpt02, '?')
  #ELSE
    #FIND(%DBname, %dctOpt02)
    #IF(NOT %DBname)
      #SET(%dctOpt02, '*BAD*')
    #ENDIF
  #ENDIF
  #IF(NOT %dctOpt04)
    #SET(%dctOpt04, 'public')
  #ELSE
    #IF(%dctOpt04 <> 'public')
      #FIND(%SCname, %dctOpt04)
      #IF(NOT %SCname)
        #SET(%dctOpt04, '*BAD*')
      #ENDIF
    #ENDIF
  #ENDIF
  #!
#!  #SET(%DoFileDescription, '[' & %dctOpt01 & '] ' & %dctOpt02 & '  [' & %dctOpt03 & '] ' & %dctOpt04)
  #SET(%DoFileDescription, '[')
  #IF(NOT %dctOpt01)
    #SET(%DoFileDescription, %DoFileDescription & ' ]')
  #ELSE
    #SET(%DoFileDescription, %DoFileDescription & UPPER(SUB(%dctOpt01,1,1))  & ']')
  #ENDIF
  #SET(%DoFileDescription, %DoFileDescription & ' ' & %dctOpt02)
  #SET(%DoFileDescription, %DoFileDescription & SUB('             [', (LEN(%dctOpt02)), (20 - LEN(%dctOpt02))))
  #IF(NOT %dctOpt03)
    #SET(%DoFileDescription, %DoFileDescription & ' ]')
  #ELSE
    #SET(%DoFileDescription, %DoFileDescription & UPPER(SUB(%dctOpt03,1,1))  & ']')
  #ENDIF
  #SET(%DoFileDescription, %DoFileDescription & ' ' & %dctOpt04)
#!  #SET(%P, (LEN(%dctOpt02)) )
#!  #SET(%L, (20 - LEN(%dctOpt02)) )
#!  #SET(%DoFileDescription, %DoFileDescription & '   =' & %P & '=' & %L & '=')
#ENDFOR
#!--------------------------------------------------------------------
#EQUATE (%DoSort,1)
#EQUATE (%I,0)
#EQUATE (%W1FilePrefix,'')
#EQUATE (%W1FileName,'')
#EQUATE (%W1File,'')
#EQUATE (%W1FileDescription,'')                     #! RAS.2003.07.22
#EQUATE (%W2FilePrefix,'')
#EQUATE (%W2FileName,'')
#EQUATE (%W2File,'')
#EQUATE (%W2FileDescription,'')                     #! RAS.2003.07.22
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoTheseFiles))
    #SELECT(%DoTheseFiles,%I-1)
    #SET(%W1FilePrefix,%DoFilePrefix)
    #SET(%W1FileName,%DoFileName)
    #SET(%W1File,%DoFile)
    #SET(%W1FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #SELECT(%DoTheseFiles,%I)
    #SET(%W2FilePrefix,%DoFilePrefix)
    #SET(%W2FileName,%DoFileName)
    #SET(%W2File,%DoFile)
    #SET(%W2FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #IF(%W1FilePrefix > %W2FilePrefix)
      #SET(%DoSort,1)
      #SET(%DoFilePrefix,%W1FilePrefix)
      #SET(%DoFileName,%W1FileName)
      #SET(%DoFile,%W1File)
      #SET(%DoFileDescription,%W1FileDescription)   #! RAS.2003.07.22
      #SELECT(%DoTheseFiles,%I-1)
      #SET(%DoFilePrefix,%W2FilePrefix)
      #SET(%DoFileName,%W2FileName)
      #SET(%DoFile,%W2File)
      #SET(%DoFileDescription,%W2FileDescription)   #! RAS.2003.07.22
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#CREATE (%OutputFile)
#SET(%WorkString,'Dictionary Files Report - Database Options')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!#INSERT(%DictionaryFilesHeader)
#!--------------------------------------------------------------------

      DATABASE       DESCRIPTION

#FOR(%dctDB)
      %[14]DBname %DBtext
#ENDFOR

      SCHEMA         DESCRIPTION

#FOR(%dctSC)
      %[14]SCname %SCtext
#ENDFOR

#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoTheseFiles)
  #IF((%CountFiles % 20) = 0)
#INSERT(%DictionaryFilesHeader6)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N3@(%CountFiles)  %[8]DoFilePrefix %[20]DoFileName %[40]DoFile %DoFileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%DictionaryFilesHeader6)
#CLOSE (%OutputFile)
#!--------------------------------------------------------------------
#IF (~%DoNotPrint)
  #RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#IF (%RetainFile = 'I don''t want it. Remove the file after printing.')
  #REMOVE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#GROUP(%DictionaryFilesHeader6),AUTO
#EQUATE(%HFilePrefix,'PREFIX')
#EQUATE(%HFileName,'GLOBAL AREA')
#EQUATE(%HFile,'FILE NAME')
#EQUATE(%HFileDescription, 'DATABASE          SCHEMA')

 SEQ  %[8]HFilePrefix %[20]HFileName %[40]HFile %HFileDescription

#GROUP(%DictionaryFilesHeader6End)
#!--------------------------------------------------------------------
#GROUP(%UTILDictionaryFiles6End)
#!---------------------------------------------------------------------

#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_PostgreSQL_Connect_Schema, '2011.02.11: [DCT2SQL-UTIL] PostgreSQL database connect procedure'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2011.02.11   Roberto Artigas
#!  *   Added date to routine description.
#! 2010.09.27   Roberto Artigas
#!  *   Changes to handle 'databases_and_schemas.txt' from the DCT directory.
#!  *   Handle EXTERNAL Table Names (and output accordingly).
#! 2009.04.11   Roberto Artigas
#!  *   Now uses the dictionary options or the 'databases_and_schemas.txt' file
#!      for the database names and schema names.
#! 2009.02.20    Roberto Artigas Jr
#!  *   Creates a procedure to connect into the PostgreSQL database
#!--------------------------------------------------------------------
#PREPARE
#!
#DECLARE(%DictName)                                             #! RA.2010.09.27
#DECLARE(%DictPath)                                             #! RA.2010.09.27
#DECLARE(%nLoc1)                                                #! RA.2010.09.27
#DECLARE(%nLoc2)                                                #! RA.2010.09.27
#DECLARE(%aFileUser)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt1)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt2)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt3)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt4)                                            #! RA.2010.09.27
#!
#SET(%nLoc1,INSTRING('\',%DictionaryFile,1,1))
#LOOP,WHILE(%nLoc1)
  #SET(%nLoc2,%nLoc1)
  #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,%nLoc1+1))
#ENDLOOP
#SET(%DictName,UPPER(SUB(%DictionaryFile,%nLoc2+1,LEN(%DictionaryFile)-%nLoc2-4)))
#SET(%DictPath,UPPER(SUB(%DictionaryFile,1,%nLoc2)))
#!
#DECLARE(%appTables),UNIQUE
#!
#FOR(%File)
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%aFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
    #CYCLE
  #ENDCASE
  #!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
    #CYCLE
  #ENDCASE
  #!
  #ADD(%appTables, %File)
#ENDFOR
#ENDPREPARE
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#PREPARE
#EQUATE(%dctsch,'databases_and_schemas.txt')                    #! RA.2009.04.11
#SET(%dctsch, %DictPath & 'databases_and_schemas.txt')          #! RA.2010.09.27
#EQUATE(%dctschRec,'')                                          #! RA.2009.04.11
#DECLARE(%A1,LONG)                                              #! RA.2009.04.11
#DECLARE(%A2,LONG)                                              #! RA.2009.04.11
#DECLARE(%A3,LONG)                                              #! RA.2009.04.11
#!
#DECLARE(%dctUserOptions)
#DECLARE(%dctDatabaseID)
#DECLARE(%dctDatabase)
#DECLARE(%dctSchemaID)
#DECLARE(%dctSchema)
#!
#DECLARE(%dctOptions)
#DECLARE(%dctOpt01)
#DECLARE(%dctOpt02)
#DECLARE(%dctOpt03)
#DECLARE(%dctOpt04)
#!
#DECLARE(%dctDB),MULTI,UNIQUE
#DECLARE(%DBid,%dctDB)
#DECLARE(%DBname,%dctDB)
#DECLARE(%DBtext,%dctDB)
#!
#DECLARE(%dctSC),MULTI,UNIQUE
#DECLARE(%SCid,%dctSC)
#DECLARE(%SCname,%dctSC)
#DECLARE(%SCtext,%dctSC)
#!
#DECLARE(%P,LONG)
#DECLARE(%L,LONG)
#SET(%dctUserOptions,%DictionaryUserOptions)
#!-----------------------------------------------------------------------------------!
#SET(%dctDatabaseID, 1)
#SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctDatabase))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctDatabase, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctDatabase, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctDatabase, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctDB,  %dctOpt02)
    #SET(%DBid,   %dctDatabaseID)
    #SET(%DBname, %dctOpt02)
    #SET(%DBtext, %dctOpt03)
  #ENDIF
  #SET(%dctDatabaseID, %dctDatabaseID + 1)
  #SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#ENDLOOP
#!-----------------------------------------------------------------------------------!
#SET(%dctSchemaID, 1)
#SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctSchema))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctSchema, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctSchema, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctSchema, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctSC,    %dctOpt02)
    #SET(%SCid,     %dctSchemaID)
    #SET(%SCname,   %dctOpt02)
    #SET(%SCtext,   %dctOpt03)
  #ENDIF
  #SET(%dctSchemaID, %dctSchemaID + 1)
  #SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#ENDLOOP
#ENDPREPARE
#!-----------------------------------------------------------------------------------!
#! RA.2009.04.11 - This is procedure that loads the options from a file.             !
#!-----------------------------------------------------------------------------------!
#IF(FILEEXISTS(%dctsch))                                        #! RA.2009.04.11
#!                                                              #! RA.2009.04.11
#OPEN(%dctsch),READ
#LOOP
  #READ(%dctschRec)
  #IF(%dctschRec = %EOF)
    #BREAK
  #ELSE
#!
    #SET(%dctOpt01, '')
    #SET(%A1, 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (01) %A1, %A2, %A3
    #SET(%dctOpt01, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt02, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (02) %A1, %A2, %A3
    #SET(%dctOpt02, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt03, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, LEN(%dctschRec) + 1)
    #SET(%A3, %A2 - %A1)
#!! (03) %A1, %A2, %A3
    #SET(%dctOpt03, SUB(%dctschRec, %A1, %A3))
#!
    #CASE(UPPER(%dctOpt01))
    #OF('DATABASE')
      #FIND(%DBname,%dctOpt02)
      #IF(%DBName = '')
        #SET(%dctDatabaseID, ITEMS(%dctDB) + 1)
        #ADD(%dctDB,  %dctOpt02)
        #SET(%DBid,   %dctDatabaseID)
        #SET(%DBname, %dctOpt02)
        #SET(%DBtext, %dctOpt03)
      #ENDIF
    #OF('SCHEMA')
      #FIND(%SCname,%dctOpt02)
      #IF(%SCName = '')
        #SET(%dctSchemaID, ITEMS(%dctSC) + 1)
        #ADD(%dctSC,  %dctOpt02)
        #SET(%SCid,   %dctSchemaID)
        #SET(%SCname, %dctOpt02)
        #SET(%SCtext, %dctOpt03)
      #ENDIF
    #ENDCASE
  #ENDIF
#ENDLOOP
#CLOSE(%dctsch),READ
#!                                                              #! RA.2009.04.11
#ENDIF                                                          #! RA.2009.04.11
#!-----------------------------------------------------------------------------------!
#!-----------------------------------------------------------------------------------!
#SHEET
  #TAB ('PostgreSQL Connect Database Procedure Wizard')
    #DISPLAY('The PostgreSQL Connect Database Procedure Utility.')
    #DISPLAY('Copyright 2009-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will create a procedure to connect to the PostgreSQL database.')
    #DISPLAY('To specify how you want the procedure constructed, click on the Next button.')
  #ENDTAB
  #TAB ('PostgreSQL Database Connect Procedure Wizard - Connect ALL'), FINISH(1)
    #DISPLAY('You can connect to all files in your dictionary, or you can select individual files to connect.')
    #DISPLAY('')
    #PROMPT ('Connect to all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('PostgreSQL Database Connect Procedure Wizard - Connect SOME'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('Table Selection', FROM (%appTables)), %DictionaryReportFileSelection, INLINE, SELECTION('Table Selection')
  #ENDTAB
  #TAB ('PostgreSQL Database Connect Procedure Wizard - Generate Procedure'), FINISH(1)
    #DISPLAY('Generate the PostgreSQL database connect procedure.')
    #DISPLAY('')
    #PROMPT ('Generate database connect procedure.', CHECK), %InitializeGenerate, DEFAULT(1), AT(10)
    #PROMPT ('Import database connect procedure.', CHECK), %InitializeImport, DEFAULT(0), AT(10)
    #DISPLAY('')
  #ENDTAB
  #TAB ('PostgreSQL Database Connect Procedure Wizard - Finally...')
    #DISPLAY ('This concludes the PostgreSQL database connect wizard.')
    #DISPLAY ('Click on the Finish button to generate the procedure file.')
  #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%filName,%ReportedFiles)
#DECLARE(%filDB,%ReportedFiles)
#DECLARE(%filSC,%ReportedFiles)
#!
#DECLARE(%sFileName)                                                    #! RA.2010.09.27
#DECLARE(%sFileNameInternal)                                            #! RA.2010.09.27
#DECLARE(%sFileNameExternal)                                            #! RA.2010.09.27
#DECLARE(%OutputFile)
#DECLARE(%CountFiles)
#DECLARE(%txaLine)
#EQUATE (%AtColPos, 19)
#!
#EQUATE (%AtColPos1, 35)                                                #! RA.2010.09.27
#EQUATE (%AtColPos2, 91)                                                #! RA.2010.09.27
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%appTables)
    #FIX (%File, %appTables)
    #ADD (%ReportedFiles, %appTables)
    #SET (%filName, %appTables)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #FIX (%File, %DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
    #SET (%filName, %DictionaryReportFileSelection)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#! RA.2007.12.29 - Generate so I do not have to code it by hand.
#!--------------------------------------------------------------------
#IF(%InitializeGenerate)
#SET(%OutputFile, UPPER(SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 4)) & '_POSTGRESQL_CONNECT.TXA')
#CREATE (%OutputFile)
#INSERT(%TxaPostgreSqlConnect)
#CLOSE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#IF(%InitializeImport)
#IMPORT(%OutputFile),REPLACE
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%TxaPostgreSqlConnect)
[PROCEDURE]
NAME PostgreSQL_Database_Connect
NOEXPORT
[COMMON]
DESCRIPTION '%@D010.@(TODAY()): Connect to PostgreSQL database.'
FROM ABC Source
CATEGORY 'PostgreSQL'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[FILES]
[OTHERS]
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('')
%%GenerateOpenClose LONG  (0)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%DataSection
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3400
PROPERTY:END
!=====================================================!
! 2009.02.20 - Roberto Artigas                        !
! This procedure is used to set any global variables, !
! file varibles, and database connections you need to !
! make happen before any files open.                  !
!=====================================================!
! Please NOTE that this procedure is specific for the !
! use of multi-database and multi-schema databases.   !
!=====================================================!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
#FOR(%dctDB)
  #SET(%txaLine, 'C_LOGIN_' & UPPER(%DBname) & ALL(' ', %AtColPos - (LEN(%DBname) + LEN('C_LOGIN_'))) & ' EQUATE(''SERVER=127.0.0.1;PORT=5432;DRIVER=PostgreSQL UNICODE;DATABASE=')
  #SET(%txaLine, %txaLine & %DBname & ';UID=root;PWD=root;Unicode=true;charset=utf8'')')
%txaLine
#ENDFOR

#FOR(%dctDB)
  #SET(%txaLine, 'C_DATABASE_' & UPPER(%DBname) & ALL(' ', %AtColPos - (LEN(%DBname) + LEN('C_DATABASE_'))) & ' EQUATE(''' & %DBname & '.'')')
%txaLine #<! %DBtext
#ENDFOR

#FOR(%dctSC)
  #SET(%txaLine, 'C_SCHEMA_' & UPPER(%SCname) & ALL(' ', %AtColPos - (LEN(%SCname) + LEN('C_SCHEMA_'))) & ' EQUATE(''' & %SCname & '.'')')
%txaLine #<! %SCtext
#ENDFOR
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
  #SET(%txaLine, 'WAIT_WINDOW' & ALL(' ', %AtColPos - LEN('WAIT_WINDOW')) & ' EQUATE(1)')
%txaLine #<! Show 'Please Wait...' message
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLOpenWindow WINDOW('Datatabase Connect'),AT(,,247,26),FONT('MS Sans Serif',8,,FONT:regular),CENTER, |
         GRAY,DOUBLE
       STRING('Please wait while the program connects to the database.'),AT(35,3)
       STRING('This process could take several seconds.'),AT(58,12)
     END
[END]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
  SETCURSOR(Cursor:Wait)
  OPEN(SQLOpenWindow)
  ACCEPT
    IF EVENT() = Event:OpenWindow
  !***WAIT***
#!
#!
  #FOR(%dctDB)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
! DICTIONARY: %dctDB. Set OWNER string here.
    #FOR(%dctSC)
      #SET(%CountFiles,0)
      #FOR(%ReportedFiles),WHERE((%dctDB = %filDB) AND (%dctSC = %filSC))
        #FIX(%File,%ReportedFiles)                          #! Just in case you need something
        #!----------------------------------------!
        #! RA.2010.09.27 - Get the EXTERNAL name. !
        #!----------------------------------------!
        #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
        #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
        #SET(%aFileUser,LOWER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
        #!SET(%aFileUser,LOWER(EXTRACT(%FileUserOptions,'RASQL')))
        #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
        #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
        #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
        #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
        #!
        #SET(%sFileNameInternal, %File)                     #! Internal File Name
        #SET(%sFileNameExternal, %aFileOpt2)                #! External File Name
        #SET(%sFileName, %sFileNameInternal)
        #IF(%sFileNameExternal <> '')
          #SET(%sFileName, %sFileNameExternal)
        #ENDIF
#!!! %FilePrefix , %File [ %sFileNameInternal , %sFileNameExternal ] %sFileName
        #!----------------------------------------!
        #!----------------------------------------!
        #IF((%CountFiles % 20) = 0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
! DICTIONARY: %dctDB, SCHEMA: %dctSC.
        #ENDIF
        #IF(SUB(%FileName,1,1) <> '''')
          #SET(%txaLine, '  ' & %FileName & ALL(' ', %AtColPos1 - (LEN(%FileName) + LEN(' '))) & '=')
          #SET(%txaLine, %txaLine & ' C_SCHEMA_' & UPPER(%filSC) & ' &' & ' ''' & %sFileName & '''')
          #SET(%txaLine, %txaLine & ALL(' ', %AtColPos2 - (LEN(%txaLine) + LEN(' '))) & ' ! ' & %FilePrefix & ':' & %File)
%txaLine
        #ELSE
  ! %ReportedFiles #<! (%FilePrefix , %FileName) [%sFileNameExternal] has no name assignment
        #ENDIF
        #SET(%CountFiles,%CountFiles + 1)
      #ENDFOR
    #ENDFOR
  #ENDFOR
#!
#!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5300
PROPERTY:END
  #SET(%CountFiles,ITEMS(%ReportedFiles))
  ! There are %CountFiles tables that had their name set up.

  COMPILE('!***WAIT***', WAIT_WINDOW)
      POST(EVENT:CloseWindow)
    END
  END
  CLOSE(SQLOpenWindow)
  SETCURSOR()
  !***WAIT***

  MESSAGE('Globals have been intitalized and database connection has occured!', 'PostgreSQL_Database_Connect')
  RETURN
[END]
[END]
#GROUP(%TxaPostgreSqlConnectEnd)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%UTILPostgreSQLConnectSchemaEnd)
#!--------------------------------------------------------------------

#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#UTILITY (ZAD_DictionaryFiles6, '2010.10.13: [DCT2SQL-UTIL] (TEMPORARY) Print Dictionary Database File Options'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2009.04.11   Roberto Artigas
#!  *   Now uses the dictionary options or the 'databases_and_schemas.txt' file
#!      for the database names and schema names.
#! 2002.06.02   Roberto Artigas
#!  *   Now the utility pops up a wordpad text file rather than printing
#!      directly to the printer. Much nicer to preview before you print.
#!--------------------------------------------------------------------
#SHEET
  #TAB ('Dictionary Print Wizard')
    #DISPLAY('The Dictionary Overview Print Utility.')
    #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will generate a report of the contents of your current dictionary.')
    #DISPLAY('To specify how you want the report constructed, click on the Next button.')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), FINISH(1)
    #DISPLAY('The dictionary report wizard creates a text file, which is then sent to your printer.')
    #DISPLAY('')
    #DISPLAY('You can, if you wish, have this wizard delete the file when it''s done, or you can keep the file')
    #DISPLAY('for later use.')
    #DISPLAY('')
    #PROMPT ('What do you want to do with the file?', OPTION), %RetainFile
    #PROMPT ('I don''t want it. Remove the file after printing.', RADIO)
    #PROMPT ('I might need it. Keep the file around.', RADIO)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), WHERE(%RetainFile = 'I might need it. Keep the file around.'), FINISH(1)
    #PROMPT ('What name do you want the text file to have?', OPTION), %WhatName
    #PROMPT ('Use the dictionary name, with a .TXT extension.', RADIO)
    #PROMPT ('Let me supply my own file name.', RADIO)
    #ENABLE (%WhatName = 'Let me supply my own file name.')
      #PROMPT ('Please enter the name of the text file to be generated.', @S100), %NewName
    #ENDENABLE
    #PROMPT ('Don''t print this report automatically. I''ll print it from the text file later.', CHECK), %DoNotPrint, AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Reported Files'), FINISH(1)
    #DISPLAY('You can report on each file in your dictionary, or you can select individual files to report on.')
    #DISPLAY('')
    #PROMPT ('Report on all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Reported Files'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('File Selection', FROM (%File)), %DictionaryReportFileSelection, INLINE, SELECTION('File Selection')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Finally...')
    #DISPLAY ('This concludes the dictionary report wizard.')
    #DISPLAY ('Click on the Finish button to generate the text file.')
  #ENDTAB
#ENDSHEET
#!#BOXED('Hide')
#!  #BUTTON('Processed Files'),MULTI(%DoTheseFiles, %DoFilePrefix & ' ' & %DoFileName & ' ' & %DoFile),INLINE
#!    #PROMPT('File Prefix: ',@s10),%DoFilePrefix,UNIQUE,REQ
#!    #PROMPT('Global Name Area: ',@s20),%DoFileName,REQ
#!    #PROMPT('File Name: ',@s30),%DoFile,REQ
#!  #ENDBUTTON
#!#ENDBOXED
#!--------------------------------------------------------------------
#DECLARE(%OutputFile)
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%WorkString)
#DECLARE(%CountFiles)
#DECLARE(%DoTheseFiles),UNIQUE
#DECLARE(%DoFilePrefix,%DoTheseFiles)
#DECLARE(%DoFileName,%DoTheseFiles)
#DECLARE(%DoFile,%DoTheseFiles)
#DECLARE(%DoFileDescription,%DoTheseFiles)          #! RAS.2003.07.22
#!--------------------------------------------------------------------
#DECLARE(%dctUserOptions)
#DECLARE(%dctDatabaseID)
#DECLARE(%dctDatabase)
#DECLARE(%dctSchemaID)
#DECLARE(%dctSchema)
#!
#DECLARE(%dctOptions)
#DECLARE(%dctOpt01)
#DECLARE(%dctOpt02)
#DECLARE(%dctOpt03)
#DECLARE(%dctOpt04)
#!
#EQUATE(%dctsch,'databases_and_schemas.txt')                    #! RA.2009.04.11
#EQUATE(%dctschRec,'')                                          #! RA.2009.04.11
#DECLARE(%A1,LONG)                                              #! RA.2009.04.11
#DECLARE(%A2,LONG)                                              #! RA.2009.04.11
#DECLARE(%A3,LONG)                                              #! RA.2009.04.11
#!
#DECLARE(%dctDB),MULTI,UNIQUE
#DECLARE(%DBid,%dctDB)
#DECLARE(%DBname,%dctDB)
#DECLARE(%DBtext,%dctDB)
#!
#DECLARE(%dctSC),MULTI,UNIQUE
#DECLARE(%SCid,%dctSC)
#DECLARE(%SCname,%dctSC)
#DECLARE(%SCtext,%dctSC)
#!
#DECLARE(%P,LONG)
#DECLARE(%L,LONG)
#SET(%dctUserOptions,%DictionaryUserOptions)
#!--------------------------------------------------------------------
#IF (%WhatName = 'Use the dictionary name, with a .TXT extension.')
  #SET (%OutputFile, SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 3) & 'TXT')
#ELSE
  #SET (%OutputFile, %NewName)
#ENDIF
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%File)
    #ADD (%ReportedFiles, %File)
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#SET(%dctDatabaseID, 1)
#SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctDatabase))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctDatabase, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctDatabase, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctDatabase, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctDB,  %dctOpt02)
    #SET(%DBid,   %dctDatabaseID)
    #SET(%DBname, %dctOpt02)
    #SET(%DBtext, %dctOpt03)
  #ENDIF
  #SET(%dctDatabaseID, %dctDatabaseID + 1)
  #SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#ENDLOOP
#!--------------------------------------------------------------------
#SET(%dctSchemaID, 1)
#SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctSchema))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctSchema, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctSchema, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctSchema, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctSC,  %dctOpt02)
    #SET(%SCid,   %dctSchemaID)
    #SET(%SCname, %dctOpt02)
    #SET(%SCtext, %dctOpt03)
  #ENDIF
  #SET(%dctSchemaID, %dctSchemaID + 1)
  #SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#ENDLOOP
#!--------------------------------------------------------------------
#IF(FILEEXISTS(%dctsch))
#!
#OPEN(%dctsch),READ
#LOOP
  #READ(%dctschRec)
  #IF(%dctschRec = %EOF)
    #BREAK
  #ELSE
#!
    #SET(%dctOpt01, '')
    #SET(%A1, 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (01) %A1, %A2, %A3
    #SET(%dctOpt01, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt02, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (02) %A1, %A2, %A3
    #SET(%dctOpt02, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt03, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, LEN(%dctschRec) + 1)
    #SET(%A3, %A2 - %A1)
#!! (03) %A1, %A2, %A3
    #SET(%dctOpt03, SUB(%dctschRec, %A1, %A3))
#!
    #CASE(UPPER(%dctOpt01))
    #OF('DATABASE')
      #FIND(%DBname,%dctOpt02)
      #IF(%DBName = '')
        #SET(%dctDatabaseID, ITEMS(%dctDB) + 1)
        #ADD(%dctDB,  %dctOpt02)
        #SET(%DBid,   %dctDatabaseID)
        #SET(%DBname, %dctOpt02)
        #SET(%DBtext, %dctOpt03)
      #ENDIF
    #OF('SCHEMA')
      #FIND(%SCname,%dctOpt02)
      #IF(%SCName = '')
        #SET(%dctSchemaID, ITEMS(%dctSC) + 1)
        #ADD(%dctSC,  %dctOpt02)
        #SET(%SCid,   %dctSchemaID)
        #SET(%SCname, %dctOpt02)
        #SET(%SCtext, %dctOpt03)
      #ENDIF
    #ENDCASE
  #ENDIF
#ENDLOOP
#CLOSE(%dctsch),READ
#!
#ENDIF
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR (%ReportedFiles)
  #FIX(%File,%ReportedFiles)
  #SET(%CountFiles,%CountFiles + 1)
  #ADD(%DoTheseFiles, %CountFiles)
  #SET(%DoFilePrefix, %FilePrefix)
  #SET(%DoFileName, %FileName)
  #SET(%DoFile, %File)
  #!
  #SET(%dctOpt01, '')
  #SET(%dctOpt02, '')
  #SET(%dctOpt03, '')
  #SET(%dctOpt04, '')
  #SET(%dctOpt01, EXTRACT(%FileUserOptions, 'DATABASE', 1))
  #SET(%dctOpt02, EXTRACT(%FileUserOptions, 'DATABASE', 2))
  #SET(%dctOpt03, EXTRACT(%FileUserOptions, 'SCHEMA'  , 1))
  #SET(%dctOpt04, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #!
  #IF(NOT %dctOpt02)
    #SET(%dctOpt02, '?')
  #ELSE
    #FIND(%DBname, %dctOpt02)
    #IF(NOT %DBname)
      #SET(%dctOpt02, '*BAD*')
    #ENDIF
  #ENDIF
  #IF(NOT %dctOpt04)
    #SET(%dctOpt04, 'public')
  #ELSE
    #IF(%dctOpt04 <> 'public')
      #FIND(%SCname, %dctOpt04)
      #IF(NOT %SCname)
        #SET(%dctOpt04, '*BAD*')
      #ENDIF
    #ENDIF
  #ENDIF
  #!
#!  #SET(%DoFileDescription, '[' & %dctOpt01 & '] ' & %dctOpt02 & '  [' & %dctOpt03 & '] ' & %dctOpt04)
  #SET(%DoFileDescription, '[')
  #IF(NOT %dctOpt01)
    #SET(%DoFileDescription, %DoFileDescription & ' ]')
  #ELSE
    #SET(%DoFileDescription, %DoFileDescription & UPPER(SUB(%dctOpt01,1,1))  & ']')
  #ENDIF
  #SET(%DoFileDescription, %DoFileDescription & ' ' & %dctOpt02)
  #SET(%DoFileDescription, %DoFileDescription & SUB('             [', (LEN(%dctOpt02)), (20 - LEN(%dctOpt02))))
  #IF(NOT %dctOpt03)
    #SET(%DoFileDescription, %DoFileDescription & ' ]')
  #ELSE
    #SET(%DoFileDescription, %DoFileDescription & UPPER(SUB(%dctOpt03,1,1))  & ']')
  #ENDIF
  #SET(%DoFileDescription, %DoFileDescription & ' ' & %dctOpt04)
#!  #SET(%P, (LEN(%dctOpt02)) )
#!  #SET(%L, (20 - LEN(%dctOpt02)) )
#!  #SET(%DoFileDescription, %DoFileDescription & '   =' & %P & '=' & %L & '=')
#ENDFOR
#!--------------------------------------------------------------------
#EQUATE (%DoSort,1)
#EQUATE (%I,0)
#EQUATE (%W1FilePrefix,'')
#EQUATE (%W1FileName,'')
#EQUATE (%W1File,'')
#EQUATE (%W1FileDescription,'')                     #! RAS.2003.07.22
#EQUATE (%W2FilePrefix,'')
#EQUATE (%W2FileName,'')
#EQUATE (%W2File,'')
#EQUATE (%W2FileDescription,'')                     #! RAS.2003.07.22
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoTheseFiles))
    #SELECT(%DoTheseFiles,%I-1)
    #SET(%W1FilePrefix,%DoFilePrefix)
    #SET(%W1FileName,%DoFileName)
    #SET(%W1File,%DoFile)
    #SET(%W1FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #SELECT(%DoTheseFiles,%I)
    #SET(%W2FilePrefix,%DoFilePrefix)
    #SET(%W2FileName,%DoFileName)
    #SET(%W2File,%DoFile)
    #SET(%W2FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #IF(%W1FilePrefix > %W2FilePrefix)
      #SET(%DoSort,1)
      #SET(%DoFilePrefix,%W1FilePrefix)
      #SET(%DoFileName,%W1FileName)
      #SET(%DoFile,%W1File)
      #SET(%DoFileDescription,%W1FileDescription)   #! RAS.2003.07.22
      #SELECT(%DoTheseFiles,%I-1)
      #SET(%DoFilePrefix,%W2FilePrefix)
      #SET(%DoFileName,%W2FileName)
      #SET(%DoFile,%W2File)
      #SET(%DoFileDescription,%W2FileDescription)   #! RAS.2003.07.22
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#CREATE (%OutputFile)
#SET(%WorkString,'Dictionary Files Report - Database Options')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!#INSERT(%DictionaryFilesHeader)
#!--------------------------------------------------------------------

      DATABASE       DESCRIPTION

#FOR(%dctDB)
      %[14]DBname %DBtext
#ENDFOR

      SCHEMA         DESCRIPTION

#FOR(%dctSC)
      %[14]SCname %SCtext
#ENDFOR

#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoTheseFiles)
  #!
  #FIX(%File,%DoFile)
  #SET(%A1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%A2,INSTRING(')',%FileUserOptions,1,%A1))
  #SET(%dctOptions,SUB(%FileUserOptions,%A1,%A2))
  #!SET(%dctOptions,EXTRACT(%FileUserOptions,'RASQL'))
  #SET(%dctOpt01,EXTRACT(%dctOptions,'RASQL',1))
  #SET(%dctOpt02,EXTRACT(%dctOptions,'RASQL',2))
  #SET(%dctOpt03,EXTRACT(%dctOptions,'RASQL',3))
  #SET(%dctOpt04,EXTRACT(%dctOptions,'RASQL',4))
#!  !!! = %DoFile = %dctOptions = %dctOpt01 = %dctOpt02 = %dctOpt03 = %dctOpt04
  #!
  #IF((%CountFiles % 20) = 0)
#INSERT(%ZADDictionaryFilesHeader6)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N3@(%CountFiles)  %[16]DoFilePrefix %[28]DoFileName %[28]DoFile %[32]dctOpt02 %DoFileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%ZADDictionaryFilesHeader6)
#CLOSE (%OutputFile)
#!--------------------------------------------------------------------
#IF (~%DoNotPrint)
  #RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#IF (%RetainFile = 'I don''t want it. Remove the file after printing.')
  #REMOVE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#GROUP(%ZADDictionaryFilesHeader6),AUTO
#EQUATE(%HFilePrefix,'PREFIX')
#EQUATE(%HFileName,'GLOBAL AREA')
#EQUATE(%HFile,'FILE NAME')
#EQUATE(%HFileExt,'FILE NAME EXTERNAL')
#EQUATE(%HFileDescription, 'DATABASE          SCHEMA')

 SEQ  %[16]HFilePrefix %[28]HFileName %[28]HFile %[32]HFileExt %HFileDescription

#GROUP(%ZADDictionaryFilesHeader6End)
#!--------------------------------------------------------------------
#GROUP(%ZADDictionaryFiles6End)
#!---------------------------------------------------------------------

#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#UTILITY (ZAD_DictionaryFiles5, '2010.09.07: [DCT2SQL-UTIL] (TEMPORARY) Print Dictionary Driver Options'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2002.06.02   Roberto Artigas Jr
#!  *   Now the utility pops up a wordpad text file rather than printing
#!      directly to the printer. Much nicer to preview before you print.
#!--------------------------------------------------------------------
#SHEET
  #TAB ('Dictionary Print Wizard')
    #DISPLAY('The Dictionary Overview Print Utility.')
    #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will generate a report of the contents of your current dictionary.')
    #DISPLAY('To specify how you want the report constructed, click on the Next button.')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), FINISH(1)
    #DISPLAY('The dictionary report wizard creates a text file, which is then sent to your printer.')
    #DISPLAY('')
    #DISPLAY('You can, if you wish, have this wizard delete the file when it''s done, or you can keep the file')
    #DISPLAY('for later use.')
    #DISPLAY('')
    #PROMPT ('What do you want to do with the file?', OPTION), %RetainFile
    #PROMPT ('I don''t want it. Remove the file after printing.', RADIO)
    #PROMPT ('I might need it. Keep the file around.', RADIO)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Output File'), WHERE(%RetainFile = 'I might need it. Keep the file around.'), FINISH(1)
    #PROMPT ('What name do you want the text file to have?', OPTION), %WhatName
    #PROMPT ('Use the dictionary name, with a .TXT extension.', RADIO)
    #PROMPT ('Let me supply my own file name.', RADIO)
    #ENABLE (%WhatName = 'Let me supply my own file name.')
      #PROMPT ('Please enter the name of the text file to be generated.', @S100), %NewName
    #ENDENABLE
    #PROMPT ('Don''t print this report automatically. I''ll print it from the text file later.', CHECK), %DoNotPrint, AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Reported Files'), FINISH(1)
    #DISPLAY('You can report on each file in your dictionary, or you can select individual files to report on.')
    #DISPLAY('')
    #PROMPT ('Report on all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Select Reported Files'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('File Selection', FROM (%File)), %DictionaryReportFileSelection, INLINE, SELECTION('File Selection')
  #ENDTAB
  #TAB ('Dictionary Print Wizard - Finally...')
    #DISPLAY ('This concludes the dictionary report wizard.')
    #DISPLAY ('Click on the Finish button to generate the text file.')
  #ENDTAB
#ENDSHEET
#!#BOXED('Hide')
#!  #BUTTON('Processed Files'),MULTI(%DoTheseFiles, %DoFilePrefix & ' ' & %DoFileName & ' ' & %DoFile),INLINE
#!    #PROMPT('File Prefix: ',@s10),%DoFilePrefix,UNIQUE,REQ
#!    #PROMPT('Global Name Area: ',@s20),%DoFileName,REQ
#!    #PROMPT('File Name: ',@s30),%DoFile,REQ
#!  #ENDBUTTON
#!#ENDBOXED
#!--------------------------------------------------------------------
#DECLARE(%OutputFile)
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%WorkString)
#DECLARE(%CountFiles)
#DECLARE(%DoTheseFiles),UNIQUE
#DECLARE(%DoFilePrefix,%DoTheseFiles)
#DECLARE(%DoFileName,%DoTheseFiles)
#DECLARE(%DoFile,%DoTheseFiles)
#DECLARE(%DoFileDescription,%DoTheseFiles)          #! RAS.2003.07.22
#!--------------------------------------------------------------------
#IF (%WhatName = 'Use the dictionary name, with a .TXT extension.')
  #SET (%OutputFile, SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 3) & 'TXT')
#ELSE
  #SET (%OutputFile, %NewName)
#ENDIF
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%File)
    #ADD (%ReportedFiles, %File)
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR (%ReportedFiles)
  #FIX(%File,%ReportedFiles)
  #SET(%CountFiles,%CountFiles + 1)
  #ADD(%DoTheseFiles, %CountFiles)
  #SET(%DoFilePrefix, %FilePrefix)
  #SET(%DoFileName, %FileName)
  #SET(%DoFile, %File)
  #SET(%DoFileDescription, '[' & %FileDriver & '] ' & %FileDriverParameter)        #! RAS.2008.08.22
#ENDFOR
#!--------------------------------------------------------------------
#EQUATE (%DoSort,1)
#EQUATE (%I,0)
#EQUATE (%W1FilePrefix,'')
#EQUATE (%W1FileName,'')
#EQUATE (%W1File,'')
#EQUATE (%W1FileDescription,'')                     #! RAS.2003.07.22
#EQUATE (%W2FilePrefix,'')
#EQUATE (%W2FileName,'')
#EQUATE (%W2File,'')
#EQUATE (%W2FileDescription,'')                     #! RAS.2003.07.22
#LOOP,WHILE(%DoSort)
  #SET(%DoSort,0)
  #LOOP,FOR(%I,2,ITEMS(%DoTheseFiles))
    #SELECT(%DoTheseFiles,%I-1)
    #SET(%W1FilePrefix,%DoFilePrefix)
    #SET(%W1FileName,%DoFileName)
    #SET(%W1File,%DoFile)
    #SET(%W1FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #SELECT(%DoTheseFiles,%I)
    #SET(%W2FilePrefix,%DoFilePrefix)
    #SET(%W2FileName,%DoFileName)
    #SET(%W2File,%DoFile)
    #SET(%W2FileDescription,%DoFileDescription)     #! RAS.2003.07.22
    #IF(%W1FilePrefix > %W2FilePrefix)
      #SET(%DoSort,1)
      #SET(%DoFilePrefix,%W1FilePrefix)
      #SET(%DoFileName,%W1FileName)
      #SET(%DoFile,%W1File)
      #SET(%DoFileDescription,%W1FileDescription)   #! RAS.2003.07.22
      #SELECT(%DoTheseFiles,%I-1)
      #SET(%DoFilePrefix,%W2FilePrefix)
      #SET(%DoFileName,%W2FileName)
      #SET(%DoFile,%W2File)
      #SET(%DoFileDescription,%W2FileDescription)   #! RAS.2003.07.22
    #ENDIF
  #ENDLOOP
#ENDLOOP
#!--------------------------------------------------------------------
#CREATE (%OutputFile)
#SET(%WorkString,'Dictionary Files Report')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())
#!#INSERT(%DictionaryFilesHeader)
#!--------------------------------------------------------------------
#SET(%CountFiles,0)
#FOR(%DoTheseFiles)
  #IF((%CountFiles % 20) = 0)
#INSERT(%ZADDictionaryFilesHeader5)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
 %@N3@(%CountFiles)  %[20]DoFilePrefix %[30]DoFileName %[30]DoFile %DoFileDescription
#ENDFOR
#!--------------------------------------------------------------------
#INSERT(%ZADDictionaryFilesHeader5)
#CLOSE (%OutputFile)
#!--------------------------------------------------------------------
#IF (~%DoNotPrint)
  #RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#IF (%RetainFile = 'I don''t want it. Remove the file after printing.')
  #REMOVE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#GROUP(%ZAdDictionaryFilesHeader5),AUTO
#EQUATE(%HFilePrefix,'PREFIX')
#EQUATE(%HFileName,'GLOBAL AREA')
#EQUATE(%HFile,'FILE NAME')
#EQUATE(%HFileDescription, 'DESCRIPTION')

 SEQ  %[20]HFilePrefix %[30]HFileName %[30]HFile %HFileDescription

#GROUP(%ZADDictionaryFilesHeader5End)
#!--------------------------------------------------------------------
#GROUP(%ZADDictionaryFiles5End)
#!---------------------------------------------------------------------

#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_PK_Auto_Exists_External, '2010.09.10: [DCT2SQL-UTIL] Does a Primary Key Auto-Increment exist? (With External Name)')
#!--------------------------------------------------------------------
#! Changes:
#! RA.2010.09.13    Roberto Artigas
#!  *   Added EXTERNAL key name RASQL(,key_name) functionality.
#! RA.2010.09.10    Roberto Artigas
#!  *   Added EXTERNAL table name RASQL(,table_name) functionality.
#!  *   Changed the RAWEB(No) to RASQL(No)
#! RA.2007.04.19    Roberto Artigas
#!  *   Added RAWEB(NO) option so certain files can be ignore by this utility.
#! RA.2007.04.04    Roberto Artigas
#!  *   Error message added if primary key has more than one field
#!--------------------------------------------------------------------
#SHEET,HSCROLL
 #TAB('General')
  #BOXED('')
   #DISPLAY('Auto-Increment Primary Key LONG checker.')
   #DISPLAY('Copyright 2001-2011 © by Roberto Artigas Jr.')
   #DISPLAY('All Rights Reserved World Wide.')
   #DISPLAY('')
   #PROMPT('Output: ',@S80),%OutputFile,AT(50,,130),DEFAULT(SUB(%DictionaryFile,1,LEN(%DictionaryFile)-4) & '.pkx')
   #DISPLAY('')
   #PROMPT('Set column divider 1 at: ',@n4),%AtColPos1,AT(150,,30),DEFAULT(30)
   #PROMPT('Set column divider 2 at: ',@n4),%AtColPos2,AT(150,,30),DEFAULT(40)
   #DISPLAY('')
  #ENDBOXED
 #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#DECLARE(%FieldTableList),MULTI,UNIQUE
#!
#DECLARE(%CountFiles  ,LONG)            #! File Counter
#DECLARE(%nLoc1       ,LONG)            #! Location 1
#DECLARE(%nLoc2       ,LONG)            #! Location 2
#DECLARE(%WorkString)                   #! Working String
#DECLARE(%WorkLine)                     #! Formated String
#DECLARE(%NKeyName)                     #! Key name
#DECLARE(%NKeyField)                    #! Key field current
#DECLARE(%NKeyAuto)                     #! Auto Increment field
#DECLARE(%nFindPK)                      #! Found a primary key
#DECLARE(%nCntFlds)                     #! Count fields in primary key
#!
#DECLARE(%NFileUser)                    #! File user options [RASQL]
#DECLARE(%NFileOpt1)                    #! File option 1 [NO]
#DECLARE(%NFileOpt2)                    #! File option 2 [EXTERNAL-FILE-NAME]
#DECLARE(%NFileOpt3)                    #! File option 3 
#DECLARE(%NFileOpt4)                    #! File option 4
#!
#DECLARE(%NKeyUser)                     #! Key user options [RASQL]
#DECLARE(%NKeyOpt1)                     #! Key option 1 [NO]
#DECLARE(%NKeyOpt2)                     #! Key option 2 [EXTERNAL-KEY-NAME]
#DECLARE(%NKeyOpt3)                     #! Key option 3
#DECLARE(%NKeyOpt4)                     #! Key option 4
#!
#EQUATE (%ErrFileNoFields   ,'File has no fields')
#EQUATE (%ErrFileType       ,'File is of a file type = ')
#EQUATE (%ErrFileDriver     ,'File is of a driver type = ')
#EQUATE (%ErrFileNoKeys     ,'File has no keys')
#EQUATE (%ErrFileNoPK       ,'File has no primary key')
#EQUATE (%ErrKeyOnePlus     ,'Primary Key has more than one field')
#!--------------------------------------------------------------------
#CREATE(%OutputFile)
#MESSAGE('Does a Primary Key Auto-Increment exist?',0)
#MESSAGE('Creating: ' & %OutputFile,1)
#!---------------------------------------------------------------------
#FOR(%File)
  #MESSAGE('Table of: ' & %File,2)                              #! RAS.2001.12.15
#!  #ERROR(%File)
#!  #ERROR(LEN(%File))
#!
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,SUB(%FileUserOptions,%nLoc1,%nLoc2))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RAWEB(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
    #! File has wrong file type
    #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
    #! File has wrong driver
    #CYCLE
  #ENDCASE
#!
  #!----------------------------------------------------------------!
  #! RAS.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.   !
  #!----------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RAS.2001.12.01
    #! File has no fields
    #CYCLE                                                      #! RAS.2001.12.01
  #ENDIF                                                        #! RAS.2001.12.01
#!
  #SET(%nFindPK,0)                                              #! No Primary Key Yet
  #IF(ITEMS(%Key))
    #FOR(%Key)
      #!------------------------------------!
      #! RA.2010.09.13 - Added Key Options. !
      #!------------------------------------!
      #SET(%nLoc1,INSTRING('RASQL(',%KeyUserOptions,1,1))
      #SET(%nLoc2,INSTRING(')',%KeyUserOptions,1,%nLoc1))
      #SET(%nKeyUser,SUB(%KeyUserOptions,%nLoc1,%nLoc2))
      #!SET(%NKeyUser,EXTRACT(%KeyUserOptions,'RASQL'))
      #SET(%NKeyOpt1,EXTRACT(%NKeyUser,'RASQL',1))
      #SET(%NKeyOpt2,EXTRACT(%NKeyUser,'RASQL',2))
      #SET(%NKeyOpt3,EXTRACT(%NKeyUser,'RASQL',3))
      #SET(%NKeyOpt4,EXTRACT(%NKeyUser,'RASQL',4))
#!%NKeyUser, %NKeyOpt1, %NKeyOpt2, %NKeyOpt3, %NKeyOpt4
      #!------------------------------------------------------------!
      #! The first option RASQL(NO) controls if a key is processed. !
      #!------------------------------------------------------------!
      #IF(SUB(%NKeyOpt1,1,1)='N')
        #CYCLE
      #ENDIF
#!
      #SET(%NKeyName,%KeyID)
      #SET(%nCntFlds,0)                                         #! Count fields
#!
      #FOR(%KeyField)
        #IF(%KeyPrimary)
          #SET(%nFindPk,1)                                      #! Found Primary Key (YES!)
          #SET(%nCntFlds,%nCntFlds+1)                           #! Increment field count
          #SET(%NKeyField, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 150))
          #SET(%NKeyAuto,  SUB(%KeyAuto,  INSTRING(':',%KeyAuto ,1,1) + 1 , 150))
          #FIX(%Field,%KeyField)
          #SET(%NKeyField, '[' & %NKeyAuto & ']' & %NKeyField & ' (' & %FieldPicture & ',' & %FieldType & ') ' & %NKeyName & ' [' & %NKeyOpt2 & ']')
          #!ADD(%FieldTableList, %NKeyField & ' ==> ' & %File)
          #SET(%WorkLine, %File & ALL(' ', %AtColPos1 - LEN(%File)) & ' ' & %NFileOpt2 & ALL(' ', %AtColPos2 - LEN(%NFileOpt2)) & ' ==> ' & %NKeyField)
          #ADD(%FieldTableList, %WorkLine)
        #ENDIF
      #ENDFOR
    #ENDFOR
  #ELSE
    #! File has no keys
    #SET(%WorkLine, %File & ALL(' ', %AtColPos1 - LEN(%File)) & ' ' & %NFileOpt2 & ALL(' ', %AtColPos2 - LEN(%NFileOpt2)) & ' ==> ' & %ErrFileNoKeys)
    #ADD(%FieldTableList, %WorkLine)
    #CYCLE
  #ENDIF
  #IF(NOT %nFindPK)
    #! No primary key found
    #SET(%WorkLine, %File & ALL(' ', %AtColPos1 - LEN(%File)) & ' ' & %NFileOpt2 & ALL(' ', %AtColPos2 - LEN(%NFileOpt2)) & ' ==> ' & %ErrFileNoPK)
    #ADD(%FieldTableList, %WorkLine)
  #ENDIF
  #IF(%nCntFlds > 1)
    #! Primary Key has more than one field
    #SET(%WorkLine, %File & ALL(' ', %AtColPos1 - LEN(%File)) & ' ' & %NFileOpt2 & ALL(' ', %AtColPos2 - LEN(%NFileOpt2)) & ' ==> ' & %ErrKeyOnePlus)
    #ADD(%FieldTableList, %WorkLine)
  #ENDIF
#ENDFOR
#!---------------------------------------------------------------------
#SET(%WorkString,'Does a Primary Key Auto-Increment exist?')
%[54]WorkString    Date: %@D010@(TODAY())
%[54]DictionaryFile    Time: %@T04@(CLOCK())

#SET(%CountFiles,0)
#FOR(%FieldTableList)
  #IF((%CountFiles % 20) = 0)
#INSERT(%UTILPKAutoExistsExternalHeader)
  #ENDIF
  #SET(%CountFiles,%CountFiles + 1)
%@N4@(%CountFiles)  %FieldTableList
#ENDFOR
#INSERT(%UTILPKAutoExistsExternalHeader)

#!---------------------------------------------------------------------
#CLOSE(%OutputFile)
#RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#!--------------------------------------------------------------------
#GROUP(%UTILPKAutoExistsExternalHeader),AUTO
#EQUATE(%HTableName,'TABLE-NAME')
#EQUATE(%HExternName,'EXTERNAL-NAME')
#EQUATE(%HFileName,'[AUTO-FIELD] KEY-FIELD (PICTURE,TYPE) KEY-NAME [EXTERNAL-KEY-NAME]')

ITEM  %[%AtColPos1]HTableName %[%AtColPos2]HExternName ==> %[30]HFileName

#GROUP(%UTILPKAutoExistsExternalHeaderEnd)
#!--------------------------------------------------------------------
#GROUP(%UTILPKAutoExistsExternalEnd)
#!--------------------------------------------------------------------


#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_PostgreSQL_Open_Close_Schema, '2011.02.11: [DCT2SQL-UTIL] PostgreSQL OPEN-CLOSE tables procedure'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2011.02.11   Roberto Artigas
#!  *   Added date to routine description.
#! 2010.12.22   Roberto Artigas
#!  *   Added NOTEPAD option to show generated file.
#!  *   Added changing window title to file that is currently being processed.
#!  *   Added additional compile / execute option when you want no action.
#!  *   Added logic to bypass files with RYB_INIT(NO) - X??? files.
#!  *   Improved open-close logic - no need to close when not open
#! 2010.09.27   Roberto Artigas
#!  *   Removed ABC classes references and substituded simple OPEN/CLOSE.
#!  *   Changes to handle 'databases_and_schemas.txt' from the DCT directory.
#!  *   Handle EXTERNAL Table Names (and output accordingly).
#! 2009.02.22    Roberto Artigas Jr
#!  *   Changed to schema generation.
#! 2007.12.29    Roberto Artigas Jr
#!  *   Creates a procedure to vacuum the PostgreSQL database tables
#!--------------------------------------------------------------------
#PREPARE
#!
#DECLARE(%DictName)                                             #! RA.2010.09.27
#DECLARE(%DictPath)                                             #! RA.2010.09.27
#DECLARE(%nLoc1)                                                #! RA.2010.09.27
#DECLARE(%nLoc2)                                                #! RA.2010.09.27
#DECLARE(%aFileUser)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt1)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt2)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt3)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt4)                                            #! RA.2010.09.27
#!
#SET(%nLoc1,INSTRING('\',%DictionaryFile,1,1))
#LOOP,WHILE(%nLoc1)
  #SET(%nLoc2,%nLoc1)
  #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,%nLoc1+1))
#ENDLOOP
#SET(%DictName,UPPER(SUB(%DictionaryFile,%nLoc2+1,LEN(%DictionaryFile)-%nLoc2-4)))
#SET(%DictPath,UPPER(SUB(%DictionaryFile,1,%nLoc2)))
#!
#DECLARE(%appTables),UNIQUE
#!
#FOR(%File)
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%aFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
  #!------------------------------------------------------------------!
  #! RA.2010.12.22 - Actually you it is better to check structures.   !
  #! The first option RYB_INIT(NO) controls if a file is initialized. !
  #!------------------------------------------------------------------!
  #SET(%nLoc1,INSTRING('RYB_INIT(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RYB_INIT',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RYB_INIT',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RYB_INIT',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RYB_INIT',4))
#!  #IF(SUB(%aFileOpt1,1,1)='N')
#!    #CYCLE
#!  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
    #CYCLE
  #ENDCASE
  #!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
    #CYCLE
  #ENDCASE
  #!
  #ADD(%appTables, %File)
#ENDFOR
#ENDPREPARE
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#PREPARE
#EQUATE(%dctsch,'databases_and_schemas.txt')                    #! RA.2009.04.11
#SET(%dctsch, %DictPath & 'databases_and_schemas.txt')          #! RA.2010.09.27
#EQUATE(%dctschRec,'')                                          #! RA.2009.04.11
#DECLARE(%A1,LONG)                                              #! RA.2009.04.11
#DECLARE(%A2,LONG)                                              #! RA.2009.04.11
#DECLARE(%A3,LONG)                                              #! RA.2009.04.11
#!
#DECLARE(%dctUserOptions)
#DECLARE(%dctDatabaseID)
#DECLARE(%dctDatabase)
#DECLARE(%dctSchemaID)
#DECLARE(%dctSchema)
#!
#DECLARE(%dctOptions)
#DECLARE(%dctOpt01)
#DECLARE(%dctOpt02)
#DECLARE(%dctOpt03)
#DECLARE(%dctOpt04)
#!
#DECLARE(%dctDB),MULTI,UNIQUE
#DECLARE(%DBid,%dctDB)
#DECLARE(%DBname,%dctDB)
#DECLARE(%DBtext,%dctDB)
#!
#DECLARE(%dctSC),MULTI,UNIQUE
#DECLARE(%SCid,%dctSC)
#DECLARE(%SCname,%dctSC)
#DECLARE(%SCtext,%dctSC)
#!
#DECLARE(%P,LONG)
#DECLARE(%L,LONG)
#SET(%dctUserOptions,%DictionaryUserOptions)
#!-----------------------------------------------------------------------------------!
#SET(%dctDatabaseID, 1)
#SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctDatabase))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctDatabase, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctDatabase, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctDatabase, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctDB,  %dctOpt02)
    #SET(%DBid,   %dctDatabaseID)
    #SET(%DBname, %dctOpt02)
    #SET(%DBtext, %dctOpt03)
  #ENDIF
  #SET(%dctDatabaseID, %dctDatabaseID + 1)
  #SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#ENDLOOP
#!-----------------------------------------------------------------------------------!
#SET(%dctSchemaID, 1)
#SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctSchema))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctSchema, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctSchema, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctSchema, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctSC,    %dctOpt02)
    #SET(%SCid,     %dctSchemaID)
    #SET(%SCname,   %dctOpt02)
    #SET(%SCtext,   %dctOpt03)
  #ENDIF
  #SET(%dctSchemaID, %dctSchemaID + 1)
  #SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#ENDLOOP
#ENDPREPARE
#!-----------------------------------------------------------------------------------!
#! RA.2009.04.11 - This is procedure that loads the options from a file.             !
#!-----------------------------------------------------------------------------------!
#IF(FILEEXISTS(%dctsch))                                        #! RA.2009.04.11
#!                                                              #! RA.2009.04.11
#OPEN(%dctsch),READ
#LOOP
  #READ(%dctschRec)
  #IF(%dctschRec = %EOF)
    #BREAK
  #ELSE
#!
    #SET(%dctOpt01, '')
    #SET(%A1, 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (01) %A1, %A2, %A3
    #SET(%dctOpt01, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt02, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (02) %A1, %A2, %A3
    #SET(%dctOpt02, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt03, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, LEN(%dctschRec) + 1)
    #SET(%A3, %A2 - %A1)
#!! (03) %A1, %A2, %A3
    #SET(%dctOpt03, SUB(%dctschRec, %A1, %A3))
#!
    #CASE(UPPER(%dctOpt01))
    #OF('DATABASE')
      #FIND(%DBname,%dctOpt02)
      #IF(%DBName = '')
        #SET(%dctDatabaseID, ITEMS(%dctDB) + 1)
        #ADD(%dctDB,  %dctOpt02)
        #SET(%DBid,   %dctDatabaseID)
        #SET(%DBname, %dctOpt02)
        #SET(%DBtext, %dctOpt03)
      #ENDIF
    #OF('SCHEMA')
      #FIND(%SCname,%dctOpt02)
      #IF(%SCName = '')
        #SET(%dctSchemaID, ITEMS(%dctSC) + 1)
        #ADD(%dctSC,  %dctOpt02)
        #SET(%SCid,   %dctSchemaID)
        #SET(%SCname, %dctOpt02)
        #SET(%SCtext, %dctOpt03)
      #ENDIF
    #ENDCASE
  #ENDIF
#ENDLOOP
#CLOSE(%dctsch),READ
#!                                                              #! RA.2009.04.11
#ENDIF                                                          #! RA.2009.04.11
#!-----------------------------------------------------------------------------------!
#!-----------------------------------------------------------------------------------!
#SHEET
  #TAB ('PostgreSQL Open-Close Tables Procedure Wizard')
    #DISPLAY('The PostgreSQL Open-Close Tables Procedure Utility.')
    #DISPLAY('Copyright 2007-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will create a procedure to open-close all your PostgreSQL tables.')
    #DISPLAY('To specify how you want the procedure constructed, click on the Next button.')
  #ENDTAB
  #TAB ('PostgreSQL Open-Close Tables Procedure Wizard - Vacuum Tables'), FINISH(1)
    #DISPLAY('You can open-close all files in your dictionary, or you can select individual files to open-close.')
    #DISPLAY('')
    #PROMPT ('Open-Close all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('PostgreSQL Open-Close Tables Procedure Wizard - Select Vacuum Tables'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('Table Selection', FROM (%appTables)), %DictionaryReportFileSelection, INLINE, SELECTION('Table Selection')
  #ENDTAB
  #TAB ('PostgreSQL Open-Close Tables Procedure Wizard - Generate Procedure'), FINISH(1)
    #DISPLAY('Generate the PostgreSQL open-close procedure.')
    #DISPLAY('')
    #PROMPT ('Generate open-close procedure.', CHECK), %InitializeGenerate, DEFAULT(1), AT(10)
    #PROMPT ('Import open-close procedure.', CHECK), %InitializeImport, DEFAULT(0), AT(10)
    #DISPLAY('')
  #ENDTAB
  #TAB ('PostgreSQL Open-Close Tables Procedure Wizard - Finally...')
    #DISPLAY ('This concludes the PostgreSQL Open-Close table wizard.')
    #DISPLAY ('Click on the Finish button to generate the procedure file.')
  #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%filName,%ReportedFiles)
#DECLARE(%filDB,%ReportedFiles)
#DECLARE(%filSC,%ReportedFiles)
#!
#DECLARE(%sFileName)                                                    #! RA.2010.09.27
#DECLARE(%sFileNameInternal)                                            #! RA.2010.09.27
#DECLARE(%sFileNameExternal)                                            #! RA.2010.09.27
#!
#DECLARE(%OutputFile)
#DECLARE(%CountFiles)
#DECLARE(%txaLine)
#EQUATE (%AtColPos, 19)
#!
#EQUATE (%AtColPos1, 35)                                                #! RA.2010.09.27
#EQUATE (%AtColPos2, 91)                                                #! RA.2010.09.27
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%appTables)
    #FIX (%File, %appTables)
    #ADD (%ReportedFiles, %appTables)
    #SET (%filName, %appTables)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #FIX (%File, %DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
    #SET (%filName, %DictionaryReportFileSelection)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#! RA.2007.12.29 - Generate so I do not have to code it by hand.
#!--------------------------------------------------------------------
#IF(%InitializeGenerate)
#SET(%OutputFile, UPPER(SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 4)) & '_POSTGRESQL_OPEN_CLOSE.TXA')
#CREATE (%OutputFile)
#INSERT(%TxaPostgreSqlOpenCloseSchema)
#CLOSE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#IF(%InitializeImport)
#IMPORT(%OutputFile),REPLACE
#ELSE
#RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%TxaPostgreSqlOpenCloseSchema)
[PROCEDURE]
NAME PostgreSQL_Tables_OpenClose
NOEXPORT
[COMMON]
DESCRIPTION '%@D010.@(TODAY()): Open-Close all database tables.'
FROM ABC Source
CATEGORY 'PostgreSQL'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[FILES]
[OTHERS]
  #FOR(%ReportedFiles)                                      #! Generate all selected list
    #FIX(%File,%ReportedFiles)                              #! Just in case you need something
%ReportedFiles
  #ENDFOR
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('')
%%GenerateOpenClose LONG  (0)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%DataSection
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
WAIT_WINDOW         EQUATE(1)
OPEN_CLOSE_TABLES   EQUATE(0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLOpenWindow WINDOW('Open-Close Tables'),AT(,,347,26),FONT('Verdana',10,,FONT:regular),CENTER,WALLPAPER('parchment-light-01.gif'), |
         TILED,GRAY,DOUBLE
       STRING('Please wait while the program opens and closes the database tables.'),AT(65,3),TRN
       STRING('This process could take several seconds.'),AT(107,12),TRN
     END
[END]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
  SETCURSOR(Cursor:Wait)
  OPEN(SQLOpenWindow)
  ACCEPT
    IF EVENT() = Event:OpenWindow
  !***WAIT***

  COMPILE('!***OPEN-CLOSE-TABLES-NEEDED***', OPEN_CLOSE_TABLES)
#!
#!
  #SET(%CountFiles,0)
  #FOR(%ReportedFiles)                                      #! Generate all selected list
    #FIX(%File,%ReportedFiles)                              #! Just in case you need something
    #!----------------------------------------!
    #! RA.2010.09.27 - Get the EXTERNAL name. !
    #!----------------------------------------!
    #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
    #SET(%aFileUser,LOWER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
    #!SET(%aFileUser,LOWER(EXTRACT(%FileUserOptions,'RASQL')))
    #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
    #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
    #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
    #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
    #!
    #SET(%sFileNameInternal, %File)                         #! Internal File Name
    #SET(%sFileNameExternal, %aFileOpt2)                    #! External File Name
    #SET(%sFileName, %sFileNameInternal)
    #IF(%sFileNameExternal <> '')
      #SET(%sFileName, %sFileNameExternal)
    #ENDIF
#!!! %FilePrefix , %File [ %sFileNameInternal , %sFileNameExternal ] %sFileName
    #!----------------------------------------!
    #!----------------------------------------!
    #IF(NOT %filSC)                                         #! RA.2009.02.25
      #SET(%filSC, 'public')                                #! RA.2009.02.25
    #ENDIF                                                  #! RA.2009.02.25
    #!
    #IF((%CountFiles % 10) = 0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
    #ENDIF
  SQLOpenWindow{PROP:TEXT} = 'Open-Close Tables (%filDB.%filSC.%sFileName)'
  OPEN(%ReportedFiles) #<! [%FilePrefix:%ReportedFiles] %filDB.%filSC.%sFileName
  IF(ERRORCODE()) THEN
    STOP('OPEN-CLOSE: %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
  ELSE
    CLOSE(%ReportedFiles)
  END
  !
  #SET(%CountFiles,%CountFiles + 1)
  #ENDFOR
  #SET(%CountFiles,ITEMS(%ReportedFiles))
  ! There are %CountFiles tables Opened and Closed.
#!
#!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5300
PROPERTY:END
  !***OPEN-CLOSE-TABLES-NEEDED***

  COMPILE('!***WAIT***', WAIT_WINDOW)
      POST(EVENT:CloseWindow)
    END
  END
  CLOSE(SQLOpenWindow)
  SETCURSOR()
  !***WAIT***
[END]
[END]
#GROUP(%TxaPostgreSqlOpenCloseSchemaEnd)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%UTILPostgreSQLOpenCloseSchemaEnd)
#!--------------------------------------------------------------------

#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_PostgreSQL_Sequences_Schema, '2011.02.11: [DCT2SQL-UTIL] PostgreSQL set sequences procedure'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2011.02.11   Roberto Artigas
#!  *   Added date to routine description.
#! 2011.01.10   Roberto Artigas
#!  *   Optional error checking on the NEXT step of the procedure.
#! 2010.12.21   Roberto Artigas
#!  *   Added logic to bypass files with RYB_INIT(NO) - X??? files.
#!  *   Added additional compilation / execution option.
#! 2010.11.22   Roberto Artigas
#!  *   Enhanced logic and debug STOP statements.
#! 2010.10.13   Roberto Artigas
#!  *   Creates a procedure to set sequences for the PostgreSQL database tables.
#!      This procedure is useful after adding a whole bunch of conversion data.
#!--------------------------------------------------------------------
#PREPARE
#!
#DECLARE(%DictName)                                             #! RA.2010.09.27
#DECLARE(%DictPath)                                             #! RA.2010.09.27
#DECLARE(%nLoc1)                                                #! RA.2010.09.27
#DECLARE(%nLoc2)                                                #! RA.2010.09.27
#DECLARE(%aFileUser)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt1)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt2)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt3)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt4)                                            #! RA.2010.09.27
#!
#SET(%nLoc1,INSTRING('\',%DictionaryFile,1,1))
#LOOP,WHILE(%nLoc1)
  #SET(%nLoc2,%nLoc1)
  #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,%nLoc1+1))
#ENDLOOP
#SET(%DictName,UPPER(SUB(%DictionaryFile,%nLoc2+1,LEN(%DictionaryFile)-%nLoc2-4)))
#SET(%DictPath,UPPER(SUB(%DictionaryFile,1,%nLoc2)))
#!
#DECLARE(%appTables),UNIQUE
#!
#FOR(%File)
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%aFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
  #!------------------------------------------------------------------!
  #! The first option RYB_INIT(NO) controls if a file is initialized. !
  #!------------------------------------------------------------------!
  #SET(%nLoc1,INSTRING('RYB_INIT(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RYB_INIT',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RYB_INIT',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RYB_INIT',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RYB_INIT',4))
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
    #CYCLE
  #ENDCASE
  #!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
    #CYCLE
  #ENDCASE
  #!
  #ADD(%appTables, %File)
#ENDFOR
#ENDPREPARE
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#PREPARE
#EQUATE(%dctsch,'databases_and_schemas.txt')                    #! RA.2009.04.11
#SET(%dctsch, %DictPath & 'databases_and_schemas.txt')          #! RA.2010.09.27
#EQUATE(%dctschRec,'')                                          #! RA.2009.04.11
#DECLARE(%A1,LONG)                                              #! RA.2009.04.11
#DECLARE(%A2,LONG)                                              #! RA.2009.04.11
#DECLARE(%A3,LONG)                                              #! RA.2009.04.11
#!
#DECLARE(%dctUserOptions)
#DECLARE(%dctDatabaseID)
#DECLARE(%dctDatabase)
#DECLARE(%dctSchemaID)
#DECLARE(%dctSchema)
#!
#DECLARE(%dctOptions)
#DECLARE(%dctOpt01)
#DECLARE(%dctOpt02)
#DECLARE(%dctOpt03)
#DECLARE(%dctOpt04)
#!
#DECLARE(%dctDB),MULTI,UNIQUE
#DECLARE(%DBid,%dctDB)
#DECLARE(%DBname,%dctDB)
#DECLARE(%DBtext,%dctDB)
#!
#DECLARE(%dctSC),MULTI,UNIQUE
#DECLARE(%SCid,%dctSC)
#DECLARE(%SCname,%dctSC)
#DECLARE(%SCtext,%dctSC)
#!
#DECLARE(%P,LONG)
#DECLARE(%L,LONG)
#SET(%dctUserOptions,%DictionaryUserOptions)
#!-----------------------------------------------------------------------------------!
#SET(%dctDatabaseID, 1)
#SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctDatabase))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctDatabase, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctDatabase, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctDatabase, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctDB,  %dctOpt02)
    #SET(%DBid,   %dctDatabaseID)
    #SET(%DBname, %dctOpt02)
    #SET(%DBtext, %dctOpt03)
  #ENDIF
  #SET(%dctDatabaseID, %dctDatabaseID + 1)
  #SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#ENDLOOP
#!-----------------------------------------------------------------------------------!
#SET(%dctSchemaID, 1)
#SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctSchema))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctSchema, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctSchema, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctSchema, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctSC,    %dctOpt02)
    #SET(%SCid,     %dctSchemaID)
    #SET(%SCname,   %dctOpt02)
    #SET(%SCtext,   %dctOpt03)
  #ENDIF
  #SET(%dctSchemaID, %dctSchemaID + 1)
  #SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#ENDLOOP
#ENDPREPARE
#!-----------------------------------------------------------------------------------!
#! RA.2009.04.11 - This is procedure that loads the options from a file.             !
#!-----------------------------------------------------------------------------------!
#IF(FILEEXISTS(%dctsch))                                        #! RA.2009.04.11
#!                                                              #! RA.2009.04.11
#OPEN(%dctsch),READ
#LOOP
  #READ(%dctschRec)
  #IF(%dctschRec = %EOF)
    #BREAK
  #ELSE
#!
    #SET(%dctOpt01, '')
    #SET(%A1, 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (01) %A1, %A2, %A3
    #SET(%dctOpt01, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt02, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (02) %A1, %A2, %A3
    #SET(%dctOpt02, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt03, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, LEN(%dctschRec) + 1)
    #SET(%A3, %A2 - %A1)
#!! (03) %A1, %A2, %A3
    #SET(%dctOpt03, SUB(%dctschRec, %A1, %A3))
#!
    #CASE(UPPER(%dctOpt01))
    #OF('DATABASE')
      #FIND(%DBname,%dctOpt02)
      #IF(%DBName = '')
        #SET(%dctDatabaseID, ITEMS(%dctDB) + 1)
        #ADD(%dctDB,  %dctOpt02)
        #SET(%DBid,   %dctDatabaseID)
        #SET(%DBname, %dctOpt02)
        #SET(%DBtext, %dctOpt03)
      #ENDIF
    #OF('SCHEMA')
      #FIND(%SCname,%dctOpt02)
      #IF(%SCName = '')
        #SET(%dctSchemaID, ITEMS(%dctSC) + 1)
        #ADD(%dctSC,  %dctOpt02)
        #SET(%SCid,   %dctSchemaID)
        #SET(%SCname, %dctOpt02)
        #SET(%SCtext, %dctOpt03)
      #ENDIF
    #ENDCASE
  #ENDIF
#ENDLOOP
#CLOSE(%dctsch),READ
#!                                                              #! RA.2009.04.11
#ENDIF                                                          #! RA.2009.04.11
#!-----------------------------------------------------------------------------------!
#!-----------------------------------------------------------------------------------!
#SHEET
  #TAB ('PostgreSQL Set Table Sequences Procedure Wizard')
    #DISPLAY('The PostgreSQL Set Table Sequences Procedure Utility.')
    #DISPLAY('Copyright 2007-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will create a procedure to set all your PostgreSQL table sequences.')
    #DISPLAY('To specify how you want the procedure constructed, click on the Next button.')
  #ENDTAB
  #TAB ('PostgreSQL Set Table Sequences Procedure Wizard - Set Sequence Tables'), FINISH(1)
    #DISPLAY('You can set all tables in your database, or you can select individual tables to set.')
    #DISPLAY('')
    #PROMPT ('Set all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('PostgreSQL Set Table Sequences Procedure Wizard - Select Set Sequence Tables'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('Table Selection', FROM (%appTables)), %DictionaryReportFileSelection, INLINE, SELECTION('Table Selection')
  #ENDTAB
  #TAB ('PostgreSQL Set Table Sequences Procedure Wizard - Prefix or File'), FINISH(1)
    #DISPLAY('Use File Prefix or File Name.')
    #DISPLAY('')
    #PROMPT ('Use File Prefix or File Name?', OPTION), %PrefixFile, DEFAULT('File Prefix')
    #PROMPT ('File Prefix', RADIO)
    #PROMPT ('File Name', RADIO)
    #DISPLAY('')
    #PROMPT('Generate EXTERNAL Column Name',CHECK),%UseExtFieldName,AT(10),DEFAULT(0)
    #ENABLE(%UseExtFieldName)                                                             
      #PROMPT('Generate Column in Quotes',CHECK),%UseExtFieldQuote,AT(25),DEFAULT(0)       
    #ENDENABLE                                                                             
  #ENDTAB
  #TAB ('PostgreSQL Set Table Sequences Procedure Wizard - Generate Procedure'), FINISH(1)
    #DISPLAY('Generate the PostgreSQL reset procedure.')
    #DISPLAY('')
    #PROMPT('Error message in NEXT() step',CHECK),%ErrorNEXT,AT(10),DEFAULT(1)
    #DISPLAY('')
    #PROMPT ('Generate set sequence procedure.', CHECK), %InitializeGenerate, DEFAULT(1), AT(10)
    #PROMPT ('Import set sequence procedure.', CHECK), %InitializeImport, DEFAULT(0), AT(10)
    #DISPLAY('')
  #ENDTAB
  #TAB ('PostgreSQL Set Table Sequences Procedure Wizard - Finally...')
    #DISPLAY ('This concludes the PostgreSQL set table sequences wizard.')
    #DISPLAY ('Click on the Finish button to generate the procedure file.')
  #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%filName,%ReportedFiles)
#DECLARE(%filDB,%ReportedFiles)
#DECLARE(%filSC,%ReportedFiles)
#!
#DECLARE(%sFileName)                                                    #! RA.2010.09.27
#DECLARE(%sFileNameInternal)                                            #! RA.2010.09.27
#DECLARE(%sFileNameExternal)                                            #! RA.2010.09.27
#!
#DECLARE(%NFOrigAuto)                                                   #! RA.2010.10.13
#DECLARE(%NFNameAuto)                                                   #! RA.2010.10.13
#!
#DECLARE(%OutputFile)
#DECLARE(%CountFiles)
#DECLARE(%txaLine)
#EQUATE (%AtColPos, 19)
#!
#EQUATE (%AtColPos1, 35)                                                #! RA.2010.09.27
#EQUATE (%AtColPos2, 91)                                                #! RA.2010.09.27
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%appTables)
    #FIX (%File, %appTables)
    #ADD (%ReportedFiles, %appTables)
    #SET (%filName, %appTables)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #FIX (%File, %DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
    #SET (%filName, %DictionaryReportFileSelection)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#! RA.2007.12.29 - Generate so I do not have to code it by hand.
#!--------------------------------------------------------------------
#IF(%InitializeGenerate)
#SET(%OutputFile, UPPER(SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 4)) & '_POSTGRESQL_SEQUENCES.TXA')
#CREATE (%OutputFile)
#INSERT(%TxaPostgreSqlSequencesSchema)
#CLOSE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#IF(%InitializeImport)
#IMPORT(%OutputFile),REPLACE
#ELSE
#RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%TxaPostgreSqlSequencesSchema)
[PROCEDURE]
NAME PostgreSQL_Tables_Sequences
NOEXPORT
[COMMON]
DESCRIPTION '%@D010.@(TODAY()): Set all database table sequences.'
FROM ABC Source
CATEGORY 'PostgreSQL'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[FILES]
[OTHERS]
  #FOR(%ReportedFiles)                                      #! Generate all selected list
    #FIX(%File,%ReportedFiles)                              #! Just in case you need something
%ReportedFiles
  #ENDFOR
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('')
%%GenerateOpenClose LONG  (0)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%DataSection
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
WAIT_WINDOW         EQUATE(1)
ALTER_SEQUENCE      EQUATE(0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLOpenWindow WINDOW('Set Table Sequences'),AT(,,347,26),FONT('Verdana',10,,FONT:regular),CENTER,WALLPAPER('parchment-light-01.gif'), |
         TILED,GRAY,DOUBLE
       STRING('Please wait while the program sets the database tables sequences.'),AT(68,3),TRN
       STRING('This process could take several seconds.'),AT(108,12),TRN
     END
[END]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
  SETCURSOR(Cursor:Wait)
  OPEN(SQLOpenWindow)
  ACCEPT
    IF EVENT() = Event:OpenWindow
  !***WAIT***

  COMPILE('!***ALTER-SEQUENCE-NEEDED***', ALTER_SEQUENCE)
#!
#!
  #SET(%CountFiles,0)
  #FOR(%ReportedFiles)                                      #! Generate all selected list
    #FIX(%File,%ReportedFiles)                              #! Just in case you need something
    #!----------------------------------------!
    #! RA.2010.09.27 - Get the EXTERNAL name. !
    #!----------------------------------------!
    #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
    #SET(%aFileUser,LOWER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
    #!SET(%aFileUser,LOWER(EXTRACT(%FileUserOptions,'RASQL')))
    #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
    #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
    #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
    #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
    #!
    #SET(%sFileNameInternal, %File)                         #! Internal File Name
    #SET(%sFileNameExternal, %aFileOpt2)                    #! External File Name
    #SET(%sFileName, %sFileNameInternal)
    #IF(%sFileNameExternal <> '')
      #SET(%sFileName, %sFileNameExternal)
    #ENDIF
#!!! %FilePrefix , %File [ %sFileNameInternal , %sFileNameExternal ] %sFileName
    #!----------------------------------------!
    #!----------------------------------------!
    #IF(NOT %filSC)                                         #! RA.2009.02.25
      #SET(%filSC, 'public')                                #! RA.2009.02.25
    #ENDIF                                                  #! RA.2009.02.25
    #!
  #SET(%NFNameAuto,'')
  #IF(ITEMS(%Key))
    #FOR(%Key)
#!---- Key        = %Key
      #IF(%KeyPrimary <> 1)
        #CYCLE
      #ENDIF
#!---- KeyPrimary = %KeyPrimary
      #IF(%KeyAuto = 1)
        #CYCLE
      #ENDIF
#!---- KeyAuto    = %KeyAuto
#!
      #IF(ITEMS(%KeyField) > 1)
        #CYCLE
      #ENDIF
#!
      #FOR(%KeyField)
#!---- KeyField   = %KeyField
        #FIX(%Field,%KeyField)
#!---- Field      = %Field
#!---- FieldType  = %FieldType
        #CASE(%FieldType)
        #OF('LONG')
          #SET(%NFNameAuto, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
          #SET(%NFOrigAuto, %NFNameAuto)                                                        #! RA.2010.10.13
          #!-------------------------------------------!
          #! RA.2010.09.13 - EXTERNAL name processing. !
          #!-------------------------------------------!
          #FIX(%Field,%KeyField)                                                                #! RA.2010.10.13
          #IF(%UseExtFieldName AND %FieldName)                                                  #! RA.2010.10.13
            #IF(%UseExtFieldQuote)                                                              #! RA.2010.10.13 - Generate External Name w/ Quotes
              #SET(%NFNameAuto, %FieldName)                                                     #! RA.2010.10.13
            #ELSE                                                                               #! RA.2010.10.13
              #SET(%NFNameAuto, SUB(%FieldName,2,LEN(%FieldName)-2))                            #! RA.2010.10.13 - Remove Quotes in External Name
            #ENDIF                                                                              #! RA.2010.10.13
          #ENDIF                                                                                #! RA.2010.10.13
          #!-------------------------------------------!
          #!-------------------------------------------!
        #ENDCASE
      #ENDFOR
#!
      #IF(%NFNameAuto)
#!---- NFNameAuto = %NFNameAuto
#!      #SET(%NFNameAuto, SUB(%KeyAuto, INSTRING(':',%KeyAuto,1,1) + 1 , 50))
        #! #IF(%UsePrefix='All' OR %PrefixColumns)                                     #! RA.2008.08.11
        #!   #SET(%NFNameAuto, %FilePrefix & '_' & %NFNameAuto)
        #! #ENDIF
        #!---------------------------------------------!
        #! RA.2007.10.10 - Behave according to option. !
        #!---------------------------------------------!
        #! #IF(NOT %IgnoreReserved)
        #!   #SET(%SqlWordItem, UPPER(%NFNameAuto))
        #!   #FIND(%SqlWordList, %SqlWordItem)
        #!   #IF(%SqlWordList)
        #!     #ADD(%ReservedFieldList, %FoundAIKeyName & %FilePrefix & ':' & %NFNameAuto)
        #!     #SET(%NFNameAuto, %NFNameAuto & '_')
        #!   #ENDIF
        #! #ENDIF
      #ENDIF
    #ENDFOR
  #ENDIF
    #!
    #IF((%CountFiles % 10) = 0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
    #ENDIF
#!
  SQLOpenWindow{PROP:TEXT} = 'Set Table Sequences (%filDB.%filSC.%sFileName)'
  OPEN(%ReportedFiles) #<! [%FilePrefix:%ReportedFiles] %filDB.%filSC.%sFileName
  IF(ERRORCODE()) THEN
    STOP('OPEN(%ReportedFiles): %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
  ELSE
    %ReportedFiles{PROP:SQL} = 'SELECT MAX(%NFNameAuto) FROM %filSC.%sFileName;'
    #!--------------------------------------------------------!
    #! RA.2011.01.11 - Option for check error on NEXT step.   !
    #! You do not want NEXT error checking if you have tables !
    #! with no data in them. This will trigger an error.      !
    #!--------------------------------------------------------!
    #IF(%ErrorNEXT)
    IF(ERRORCODE()) THEN
      STOP('SELECT MAX(%NFNameAuto): %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
    END
    #ENDIF
    NEXT(%ReportedFiles)
    #!--------------------------------------------------------!
    #! RA.2011.01.11 - Option for check error on NEXT step.   !
    #! You do not want NEXT error checking if you have tables !
    #! with no data in them. This will trigger an error.      !
    #!--------------------------------------------------------!
    #IF(%ErrorNEXT)
    IF(ERRORCODE()) THEN
      STOP('NEXT(%ReportedFiles): %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
    END
    #ENDIF
    %FilePrefix:%NFOrigAuto = %FilePrefix:%NFOrigAuto + 1
#!    STOP('%FilePrefix:%NFOrigAuto: "' & %FilePrefix:%NFOrigAuto & '"')
    #IF(%PrefixFile = 'File Prefix')
    %ReportedFiles{PROP:SQL} = 'ALTER SEQUENCE %filSC.%FilePrefix_id_seq RESTART WITH ' & %FilePrefix:%NFOrigAuto & ';'
    #ELSE
    %ReportedFiles{PROP:SQL} = 'ALTER SEQUENCE %filSC.%sFileName_id_seq RESTART WITH ' & %FilePrefix:%NFOrigAuto & ';'
    #ENDIF
    IF(ERRORCODE()) THEN
    #IF(%PrefixFile = 'File Prefix')
      STOP('ALTER SEQUENCE(%filSC.%FilePrefix_id_seq): %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
    #ELSE
      STOP('ALTER SEQUENCE(%filSC.%sFileName_id_seq): %filSC.%sFileName (%FilePrefix:%File): ' & ERRORCODE() & ': ' & ERROR() & '.')
    #ENDIF
    END
    CLOSE(%ReportedFiles)
  END
  !
  #SET(%CountFiles,%CountFiles + 1)
  #ENDFOR
  #SET(%CountFiles,ITEMS(%ReportedFiles))
  ! There are %CountFiles tables with sequences set.
#!
#!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5300
PROPERTY:END
  !***ALTER-SEQUENCE-NEEDED***

  COMPILE('!***WAIT***', WAIT_WINDOW)
      POST(EVENT:CloseWindow)
    END
  END
  CLOSE(SQLOpenWindow)
  SETCURSOR()
  !***WAIT***
[END]
[END]
#GROUP(%TxaPostgreSqlSequencesSchemaEnd)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%UTILPostgreSQLSequencesSchemaEnd)
#!--------------------------------------------------------------------


#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#UTILITY (UTIL_PostgreSQL_Connect_Schema2, '2011.05.15: [DCT2SQL-UTIL] PostgreSQL database LOGIN connect procedure'), WIZARD
#!--------------------------------------------------------------------
#! Changes:
#! 2011.05.15    Roberto Artigas
#!  *    Re-factor the template into a second version.
#!       Just a wee bit too many changes and wanted to preserve the original.
#!       Comments have dates to track generation date a bit easier.
#!       After generation the TXA now pops up in notepad.
#! 2011.02.11   Roberto Artigas
#!  *   Added date to routine description.
#! 2010.09.27   Roberto Artigas
#!  *   Changes to handle 'databases_and_schemas.txt' from the DCT directory.
#!  *   Handle EXTERNAL Table Names (and output accordingly).
#! 2009.04.11   Roberto Artigas
#!  *   Now uses the dictionary options or the 'databases_and_schemas.txt' file
#!      for the database names and schema names.
#! 2009.02.20    Roberto Artigas Jr
#!  *   Creates a procedure to connect into the PostgreSQL database
#!--------------------------------------------------------------------
#PREPARE
#!
#DECLARE(%DictName)                                             #! RA.2010.09.27
#DECLARE(%DictPath)                                             #! RA.2010.09.27
#DECLARE(%nLoc1)                                                #! RA.2010.09.27
#DECLARE(%nLoc2)                                                #! RA.2010.09.27
#DECLARE(%aFileUser)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt1)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt2)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt3)                                            #! RA.2010.09.27
#DECLARE(%aFileOpt4)                                            #! RA.2010.09.27
#!
#SET(%nLoc1,INSTRING('\',%DictionaryFile,1,1))
#LOOP,WHILE(%nLoc1)
  #SET(%nLoc2,%nLoc1)
  #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,%nLoc1+1))
#ENDLOOP
#SET(%DictName,UPPER(SUB(%DictionaryFile,%nLoc2+1,LEN(%DictionaryFile)-%nLoc2-4)))
#SET(%DictPath,UPPER(SUB(%DictionaryFile,1,%nLoc2)))
#!
#DECLARE(%appTables),UNIQUE
#!
#FOR(%File)
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%aFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
    #CYCLE
  #ENDCASE
  #!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
    #CYCLE
  #ENDCASE
  #!
  #ADD(%appTables, %File)
#ENDFOR
#ENDPREPARE
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#PREPARE
#EQUATE(%dctsch,'databases_and_schemas.txt')                    #! RA.2009.04.11
#SET(%dctsch, %DictPath & 'databases_and_schemas.txt')          #! RA.2010.09.27
#EQUATE(%dctschRec,'')                                          #! RA.2009.04.11
#DECLARE(%A1,LONG)                                              #! RA.2009.04.11
#DECLARE(%A2,LONG)                                              #! RA.2009.04.11
#DECLARE(%A3,LONG)                                              #! RA.2009.04.11
#!
#DECLARE(%dctUserOptions)
#DECLARE(%dctDatabaseID)
#DECLARE(%dctDatabase)
#DECLARE(%dctSchemaID)
#DECLARE(%dctSchema)
#!
#DECLARE(%dctOptions)
#DECLARE(%dctOpt01)
#DECLARE(%dctOpt02)
#DECLARE(%dctOpt03)
#DECLARE(%dctOpt04)
#!
#DECLARE(%dctDB),MULTI,UNIQUE
#DECLARE(%DBid,%dctDB)
#DECLARE(%DBname,%dctDB)
#DECLARE(%DBtext,%dctDB)
#!
#DECLARE(%dctSC),MULTI,UNIQUE
#DECLARE(%SCid,%dctSC)
#DECLARE(%SCname,%dctSC)
#DECLARE(%SCtext,%dctSC)
#!
#DECLARE(%P,LONG)
#DECLARE(%L,LONG)
#SET(%dctUserOptions,%DictionaryUserOptions)
#!-----------------------------------------------------------------------------------!
#SET(%dctDatabaseID, 1)
#SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctDatabase))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctDatabase, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctDatabase, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctDatabase, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctDB,  %dctOpt02)
    #SET(%DBid,   %dctDatabaseID)
    #SET(%DBname, %dctOpt02)
    #SET(%DBtext, %dctOpt03)
  #ENDIF
  #SET(%dctDatabaseID, %dctDatabaseID + 1)
  #SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#ENDLOOP
#!-----------------------------------------------------------------------------------!
#SET(%dctSchemaID, 1)
#SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctSchema))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctSchema, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctSchema, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctSchema, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctSC,    %dctOpt02)
    #SET(%SCid,     %dctSchemaID)
    #SET(%SCname,   %dctOpt02)
    #SET(%SCtext,   %dctOpt03)
  #ENDIF
  #SET(%dctSchemaID, %dctSchemaID + 1)
  #SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#ENDLOOP
#ENDPREPARE
#!-----------------------------------------------------------------------------------!
#! RA.2009.04.11 - This is procedure that loads the options from a file.             !
#!-----------------------------------------------------------------------------------!
#IF(FILEEXISTS(%dctsch))                                        #! RA.2009.04.11
#!                                                              #! RA.2009.04.11
#OPEN(%dctsch),READ
#LOOP
  #READ(%dctschRec)
  #IF(%dctschRec = %EOF)
    #BREAK
  #ELSE
#!
    #SET(%dctOpt01, '')
    #SET(%A1, 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (01) %A1, %A2, %A3
    #SET(%dctOpt01, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt02, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (02) %A1, %A2, %A3
    #SET(%dctOpt02, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt03, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, LEN(%dctschRec) + 1)
    #SET(%A3, %A2 - %A1)
#!! (03) %A1, %A2, %A3
    #SET(%dctOpt03, SUB(%dctschRec, %A1, %A3))
#!
    #CASE(UPPER(%dctOpt01))
    #OF('DATABASE')
      #FIND(%DBname,%dctOpt02)
      #IF(%DBName = '')
        #SET(%dctDatabaseID, ITEMS(%dctDB) + 1)
        #ADD(%dctDB,  %dctOpt02)
        #SET(%DBid,   %dctDatabaseID)
        #SET(%DBname, %dctOpt02)
        #SET(%DBtext, %dctOpt03)
      #ENDIF
    #OF('SCHEMA')
      #FIND(%SCname,%dctOpt02)
      #IF(%SCName = '')
        #SET(%dctSchemaID, ITEMS(%dctSC) + 1)
        #ADD(%dctSC,  %dctOpt02)
        #SET(%SCid,   %dctSchemaID)
        #SET(%SCname, %dctOpt02)
        #SET(%SCtext, %dctOpt03)
      #ENDIF
    #ENDCASE
  #ENDIF
#ENDLOOP
#CLOSE(%dctsch),READ
#!                                                              #! RA.2009.04.11
#ENDIF                                                          #! RA.2009.04.11
#!-----------------------------------------------------------------------------------!
#!-----------------------------------------------------------------------------------!
#SHEET
  #TAB ('PostgreSQL Connect Database Procedure Wizard')
    #DISPLAY('The PostgreSQL Connect Database Procedure Utility.')
    #DISPLAY('Copyright 2009-2011 © by Roberto Artigas Jr.')
    #DISPLAY('All Rights Reserved World Wide.')
    #DISPLAY('')
    #DISPLAY('This wizard will create a procedure to connect to the PostgreSQL database.')
    #DISPLAY('To specify how you want the procedure constructed, click on the Next button.')
  #ENDTAB
  #TAB ('PostgreSQL Database Connect Procedure Wizard - Connect ALL'), FINISH(1)
    #DISPLAY('You can connect to all files in your dictionary, or you can select individual files to connect.')
    #DISPLAY('')
    #PROMPT ('Connect to all files in my dictionary.', CHECK), %DictionaryReportUseAllFiles, DEFAULT(1), AT(10)
  #ENDTAB
  #TAB ('PostgreSQL Database Connect Procedure Wizard - Connect SOME'), WHERE(~%DictionaryReportUseAllFiles), FINISH(1)
    #PROMPT ('Table Selection', FROM (%appTables)), %DictionaryReportFileSelection, INLINE, SELECTION('Table Selection')
  #ENDTAB
  #TAB ('PostgreSQL Database Connect Procedure Wizard - Generate Procedure'), FINISH(1)
    #DISPLAY('Generate the PostgreSQL database connect procedure.')
    #DISPLAY('')
    #PROMPT ('Generate database connect procedure.', CHECK), %InitializeGenerate, DEFAULT(1), AT(10)
    #PROMPT ('Import database connect procedure.', CHECK), %InitializeImport, DEFAULT(0), AT(10)
    #DISPLAY('')
  #ENDTAB
  #TAB ('PostgreSQL Database Connect Procedure Wizard - Finally...')
    #DISPLAY ('This concludes the PostgreSQL database connect wizard.')
    #DISPLAY ('Click on the Finish button to generate the procedure file.')
  #ENDTAB
#ENDSHEET
#!--------------------------------------------------------------------
#DECLARE(%ReportedFiles),UNIQUE
#DECLARE(%filName,%ReportedFiles)
#DECLARE(%filDB,%ReportedFiles)
#DECLARE(%filSC,%ReportedFiles)
#!
#DECLARE(%sFileName)                                                    #! RA.2010.09.27
#DECLARE(%sFileNameInternal)                                            #! RA.2010.09.27
#DECLARE(%sFileNameExternal)                                            #! RA.2010.09.27
#DECLARE(%OutputFile)
#DECLARE(%CountFiles)
#DECLARE(%txaLine)
#EQUATE (%AtColPos, 19)
#!
#EQUATE (%AtColPos1, 35)                                                #! RA.2010.09.27
#EQUATE (%AtColPos2, 91)                                                #! RA.2010.09.27
#!--------------------------------------------------------------------
#IF (%DictionaryReportUseAllFiles)
  #FOR (%appTables)
    #FIX (%File, %appTables)
    #ADD (%ReportedFiles, %appTables)
    #SET (%filName, %appTables)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ELSE
  #FOR (%DictionaryReportFileSelection)
    #FIX (%File, %DictionaryReportFileSelection)
    #ADD (%ReportedFiles, %DictionaryReportFileSelection)
    #SET (%filName, %DictionaryReportFileSelection)
    #SET (%filDB, EXTRACT(%FileUserOptions, 'DATABASE', 2))
    #SET (%filSC, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #ENDFOR
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#! RA.2007.12.29 - Generate so I do not have to code it by hand.
#!--------------------------------------------------------------------
#IF(%InitializeGenerate)
#SET(%OutputFile, UPPER(SUB(%DictionaryFile, 1, LEN(%DictionaryFile) - 4)) & '_POSTGRESQL_LOGIN_CONNECT.TXA')
#CREATE (%OutputFile)
#INSERT(%TxaPostgreSqlConnect2)
#CLOSE (%OutputFile)
#ENDIF
#!--------------------------------------------------------------------
#! RA.2011.05.15 - In the 6.3 IDE if you generate and import you will
#! cause a GPF. The option was put there before I knew what happended.
#! It is still there for future releases when it gets fixed.
#IF(%InitializeImport)
#IMPORT(%OutputFile),REPLACE
#ELSE
#RUN('NOTEPAD.EXE "' & %OutputFile & '"')
#ENDIF
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%TxaPostgreSqlConnect2)
[PROCEDURE]
NAME PostgreSQL_Database_Connect
PROTOTYPE '(),BOOL,PROC'
GLOBAL
[COMMON]
DESCRIPTION '%@D010.@(TODAY()): Connect with LOGIN window to PostgreSQL'
FROM ABC Source
CATEGORY 'PostgreSQL'
MODIFIED '%@D010@(TODAY())' '%@T04@(CLOCK())'
[DATA]
[SCREENCONTROLS]
! PROMPT('S LOGIN RYB DP:'),USE(?S_LOGIN_RYB_DP:Prompt)
! TEXT,USE(S_LOGIN_RYB_DP)
[REPORTCONTROLS]
! TEXT,USE(S_LOGIN_RYB_DP)
S_LOGIN_RYB_DP           CSTRING(1025)
!!> IDENT(4294966479),PROMPT('S LOGIN RYB DP:'),HEADER('S LOGIN RYB DP'),PICTURE(@s255)
[SCREENCONTROLS]
! PROMPT('S LOGIN RYB DW:'),USE(?S_LOGIN_RYB_DW:Prompt)
! TEXT,USE(S_LOGIN_RYB_DW)
[REPORTCONTROLS]
! TEXT,USE(S_LOGIN_RYB_DW)
S_LOGIN_RYB_DW           CSTRING(1025)
!!> IDENT(4294966478),PROMPT('S LOGIN RYB DW:'),HEADER('S LOGIN RYB DW'),PICTURE(@s255)
[SCREENCONTROLS]
! PROMPT('S LOGIN RYB SS:'),USE(?S_LOGIN_RYB_SS:Prompt)
! TEXT,USE(S_LOGIN_RYB_SS)
[REPORTCONTROLS]
! TEXT,USE(S_LOGIN_RYB_SS)
S_LOGIN_RYB_SS           CSTRING(1025)
!!> IDENT(4294966477),PROMPT('S LOGIN RYB SS:'),HEADER('S LOGIN RYB SS'),PICTURE(@s255)
[SCREENCONTROLS]
! PROMPT('Server:'),USE(?S_SERVERNAME:Prompt)
! ENTRY(@s80),USE(S_SERVERNAME)
[REPORTCONTROLS]
! STRING(@s80),USE(S_SERVERNAME)
S_SERVERNAME             CSTRING(81)
!!> IDENT(4294966476),PROMPT('Server:'),HEADER('Server'),PICTURE(@s80)
[SCREENCONTROLS]
! PROMPT('Database:'),USE(?S_DATABASENAME:Prompt)
! ENTRY(@s80),USE(S_DATABASENAME)
[REPORTCONTROLS]
! STRING(@s80),USE(S_DATABASENAME)
S_DATABASENAME           CSTRING(81)
!!> IDENT(4294966475),PROMPT('Database:'),HEADER('Database'),PICTURE(@s80)
[SCREENCONTROLS]
! PROMPT('Port:'),USE(?L_PORTNUMBER:Prompt)
! ENTRY(@n_14),USE(L_PORTNUMBER),RIGHT(1)
[REPORTCONTROLS]
! STRING(@n_14),USE(L_PORTNUMBER),RIGHT(1)
L_PORTNUMBER             LONG
!!> IDENT(4294966474),PROMPT('Port:'),HEADER('Port'),PICTURE(@n_14),JUSTIFY(RIGHT,1)
[SCREENCONTROLS]
! CHECK('Use Enhanced Authentication'),USE(B_AUTHENTICATION),VALUE('1','0')
[REPORTCONTROLS]
! CHECK('Use Enhanced Authentication'),USE(B_AUTHENTICATION),VALUE('1','0')
B_AUTHENTICATION         BYTE
!!> IDENT(4294966473),VALID(BOOLEAN),PROMPT('Use Enhanced Authentication'),HEADER('Use Enhanced Authentication'),PICTURE(@n3),TRUEVALUE('1'),FALSEVALUE('0')
[SCREENCONTROLS]
! CHECK('Require SSL Connection'),USE(B_SSL),VALUE('1','0')
[REPORTCONTROLS]
! CHECK('Require SSL Connection'),USE(B_SSL),VALUE('1','0')
B_SSL                    BYTE
!!> IDENT(4294966472),VALID(BOOLEAN),PROMPT('Require SSL Connection'),HEADER('Require SSL Connection'),PICTURE(@n3),TRUEVALUE('1'),FALSEVALUE('0')
[SCREENCONTROLS]
! PROMPT('Username:'),USE(?S_USERNAME:Prompt)
! ENTRY(@s20),USE(S_USERNAME)
[REPORTCONTROLS]
! STRING(@s20),USE(S_USERNAME)
S_USERNAME               CSTRING(21)
!!> IDENT(4294966471),PROMPT('Username:'),HEADER('Username'),PICTURE(@s20)
[SCREENCONTROLS]
! PROMPT('Password:'),USE(?S_PASSWORD:Prompt)
! ENTRY(@s20),USE(S_PASSWORD)
[REPORTCONTROLS]
! STRING(@s20),USE(S_PASSWORD)
S_PASSWORD               CSTRING(21)
!!> IDENT(4294966470),PROMPT('Password:'),HEADER('Password'),PICTURE(@s20)
[FILES]
[OTHERS]
#!  #FOR(%ReportedFiles)                                      #! Generate all selected list
#!    #FIX(%File,%ReportedFiles)                              #! Just in case you need something
#!%ReportedFiles
#!  #ENDFOR
users
[PROMPTS]
%%ProcedureParameters MULTI LONG  ()
%%ProcedureParameterName DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterType DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterDefault DEPEND %%ProcedureParameters DEFAULT TIMES 0

%%ProcedureParameterOmitted DEPEND %%ProcedureParameters LONG TIMES 0

%%ProcedureParameterByReference DEPEND %%ProcedureParameters LONG TIMES 0

%%Parameters DEFAULT  ('() !,BOOL,PROC')
%%GenerateOpenClose LONG  (0)
%%GenerateSaveRestore LONG  (0)
[EMBED]
EMBED %%DataSection
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 50
PROPERTY:END
! RA.%@D010.@(TODAY()) - Created Procedure.
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3400
PROPERTY:END
!=====================================================!
! %@D010.@(TODAY()) - Roberto Artigas                        !
! This procedure is used to set any global variables, !
! file varibles, and database connections you need to !
! make happen before any files open.                  !
!=====================================================!
! This version contains a default window to login and !
! change database parameters. Please NOTE that these  !
! are skeletons. You will have to replace them with   !
! proper window procedures.                           !
!=====================================================!
! There are also two source procedures you will have  !
! to create specific for your database:               !
! LOGIN.CLW    - Login procedure for database.        !
! LOGINCHK.CLW - Login check validity to database.    !
! The login source gets included in this procedure.   !
! The login check gets included in the executable.    !
! Code NOT in the applications for security reasons.  !
!=====================================================!
! Please NOTE that this procedure is specific for the !
! use of multi-database and multi-schema databases.   !
!=====================================================!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3400
PROPERTY:END
  MAP
sql_user_login      PROCEDURE(),BOOL,PROC         ! User LOGIN procedure
sql_user_options    PROCEDURE(),BOOL,PROC         ! Database OPTIONS for connection
  END
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3450
PROPERTY:END
bRC                 BOOL(TRUE)                    ! Return Status for Login
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
#FOR(%dctDB)
  #SET(%txaLine, 'C_LOGIN_' & UPPER(%DBname) & ALL(' ', %AtColPos - (LEN(%DBname) + LEN('C_LOGIN_'))) & ' EQUATE(''SERVER=127.0.0.1;PORT=5432;DRIVER=PostgreSQL UNICODE;DATABASE=')
  #SET(%txaLine, %txaLine & %DBname & ';UID=root;PWD=root;Unicode=true;charset=utf8'')')
%txaLine
#ENDFOR
  #SET(%txaLine, 'C_LOGIN_RYB_USER' & ALL(' ', %AtColPos - LEN('C_LOGIN_RYB_USER')) & ' EQUATE(''DRIVER=PostgreSQL UNICODE;Unicode=true;charset=utf8;'')')
%txaLine

#FOR(%dctDB)
  #SET(%txaLine, 'C_DATABASE_' & UPPER(%DBname) & ALL(' ', %AtColPos - (LEN(%DBname) + LEN('C_DATABASE_'))) & ' EQUATE(''' & %DBname & '.'')')
%txaLine #<! %DBtext
#ENDFOR

#FOR(%dctSC)
  #SET(%txaLine, 'C_SCHEMA_' & UPPER(%SCname) & ALL(' ', %AtColPos - (LEN(%SCname) + LEN('C_SCHEMA_'))) & ' EQUATE(''' & %SCname & '.'')')
%txaLine #<! %SCtext
#ENDFOR
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
#!WAIT_WINDOW         EQUATE(0)                     ! Show 'Please Wait...' message
#!LOGIN_WINDOW        EQUATE(1)                     ! Show 'LOGIN: User Login' window
  #SET(%txaLine, 'WAIT_WINDOW' & ALL(' ', %AtColPos - LEN('WAIT_WINDOW')) & ' EQUATE(0)')
%txaLine #<! Show 'Please Wait...' message
  #SET(%txaLine, 'LOGIN_WINDOW' & ALL(' ', %AtColPos - LEN('LOGIN_WINDOW')) & ' EQUATE(1)')
%txaLine #<! Show 'LOGIN: User Login' window
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLUserLogin WINDOW('LOGIN: User'),AT(,,282,102),FONT('Verdana',10,,FONT:regular),CENTER,ICON('ryb.ico'), |
         WALLPAPER('parchment-medium-01.gif'),TILED,GRAY,DOUBLE
       PROMPT('Username:'),AT(6,70),USE(?S_USERNAME:Prompt),TRN
       ENTRY(@s20),AT(48,70,60,10),USE(S_USERNAME)
       PROMPT('Password:'),AT(6,84),USE(?S_PASSWORD:Prompt),TRN
       ENTRY(@s20),AT(48,84,60,10),USE(S_PASSWORD),PASSWORD
       PROMPT('Server:'),AT(124,70),USE(?S_SERVERNAME:Prompt:Login),TRN
       TEXT,AT(166,70,110,10),USE(S_SERVERNAME,,?S_SERVERNAME:Login),DISABLE,TRN,FONT(,,,FONT:bold,CHARSET:ANSI)
       PROMPT('Database:'),AT(124,84),USE(?S_DATABASENAME:Prompt:Login),TRN
       TEXT,AT(166,84,110,10),USE(S_DATABASENAME,,?S_DATABASENAME:Login),DISABLE,TRN,FONT(,,,FONT:bold,CHARSET:ANSI)
       IMAGE('par_ryb_big.bmp'),AT(4,4,192,60),USE(?ImageLogo),TILED
       BUTTON('OK'),AT(216,4,60,14),USE(?OkButtonLogin),DEFAULT
       BUTTON('Cancel'),AT(216,22,60,14),USE(?CancelButtonLogin)
       BUTTON('Options'),AT(216,40,60,14),USE(?OptionsButtonLogin)
     END
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLUserOptions WINDOW('LOGIN: Options'),AT(,,282,82),FONT('Verdana',10,,FONT:regular),CENTER,ICON('ryb.ico'), |
         WALLPAPER('parchment-medium-01.gif'),TILED,GRAY,DOUBLE
       PROMPT('Server:'),AT(8,6),USE(?S_SERVERNAME:Prompt),TRN
       ENTRY(@s80),AT(58,6,,10),USE(S_SERVERNAME)
       PROMPT('Database:'),AT(8,22),USE(?S_DATABASENAME:Prompt),TRN
       ENTRY(@s80),AT(58,22,,10),USE(S_DATABASENAME)
       PROMPT('Port:'),AT(8,38),USE(?L_PORTNUMBER:Prompt),TRN
       ENTRY(@n_14),AT(58,38,40,10),USE(L_PORTNUMBER),RIGHT(1)
       CHECK('Use Enhanced Authentication'),AT(8,54),USE(B_AUTHENTICATION),TRN,VALUE('1','0')
       CHECK('Require SSL Connection'),AT(8,68),USE(B_SSL),TRN,VALUE('1','0')
       BUTTON('Save'),AT(218,4,60,14),USE(?SaveButtonOptions),DEFAULT
       BUTTON('Cancel'),AT(218,22,60,14),USE(?CancelButtonOptions)
     END
[SOURCE]
PROPERTY:BEGIN
PRIORITY 3500
PROPERTY:END
SQLOpenWindow WINDOW('Datatabase Connect'),AT(,,247,26),FONT('Verdana',10,,FONT:regular),CENTER,GRAY, |
         DOUBLE
       STRING('Please wait while the program connects to the database.'),AT(35,3)
       STRING('This process could take several seconds.'),AT(58,12)
     END
[END]
EMBED %%ProcessedCode
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
! RA.%@D010.@(TODAY()): Possible corruption TPS support (just in case needed)
!
!  PUTREG(REG_LOCAL_MACHINE,'System\CurrentControlSet\Services\MRXSmb\Parameters','OplocksDisabled','1')
!  PUTREG(REG_LOCAL_MACHINE,'SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters','EnableOplocks','0')
!  PUTREG(REG_LOCAL_MACHINE,'SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters','EnableOpLockForceClose','1')
!  PUTREG(REG_LOCAL_MACHINE,'SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters','CachedOPenLimit','0')
!  PUTREG(REG_LOCAL_MACHINE,'SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters','Smb2','0')
!  PUTREG(REG_LOCAL_MACHINE,'SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters','UseOpportunisticLocking','0')
!  PUTREG(REG_LOCAL_MACHINE,'SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters','UtilizeNTCaching','0')
!  PUTREG(REG_LOCAL_MACHINE,'System\CurrentControlSet\Services\Rdr\Parameters','UseWriteBehind','0')
!  PUTREG(REG_LOCAL_MACHINE,'System\CurrentControlSet\Services\VxD\VREDIR','DiscardCacheOnOpen','1')
!
! EOE
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5100
PROPERTY:END
  COMPILE('!***WAIT***', WAIT_WINDOW)
  SETCURSOR(Cursor:Wait)
  OPEN(SQLOpenWindow)
  ACCEPT
    IF EVENT() = Event:OpenWindow
  !***WAIT***
#!
#!
  #FOR(%dctDB)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
! RA.%@D010.@(TODAY()): DICTIONARY CONNECT DEFINITIONS FOR DATABASE: %dctDB
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
    #FOR(%dctSC)
      #SET(%CountFiles,0)
      #FOR(%ReportedFiles),WHERE((%dctDB = %filDB) AND (%dctSC = %filSC))
        #FIX(%File,%ReportedFiles)                          #! Just in case you need something
        #!----------------------------------------!
        #! RA.2010.09.27 - Get the EXTERNAL name. !
        #!----------------------------------------!
        #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
        #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
        #SET(%aFileUser,LOWER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
        #!SET(%aFileUser,LOWER(EXTRACT(%FileUserOptions,'RASQL')))
        #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
        #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
        #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
        #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
        #!
        #SET(%sFileNameInternal, %File)                     #! Internal File Name
        #SET(%sFileNameExternal, %aFileOpt2)                #! External File Name
        #SET(%sFileName, %sFileNameInternal)
        #IF(%sFileNameExternal <> '')
          #SET(%sFileName, %sFileNameExternal)
        #ENDIF
#!!! %FilePrefix , %File [ %sFileNameInternal , %sFileNameExternal ] %sFileName
        #!----------------------------------------!
        #!----------------------------------------!
        #IF((%CountFiles % 20) = 0)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5200
PROPERTY:END
! RA.%@D010.@(TODAY()): DICTIONARY: %dctDB, SCHEMA: %dctSC.
        #ENDIF
        #IF(SUB(%FileName,1,1) <> '''')
          #SET(%txaLine, '  ' & %FileName & ALL(' ', %AtColPos1 - (LEN(%FileName) + LEN(' '))) & '=')
          #SET(%txaLine, %txaLine & ' C_SCHEMA_' & UPPER(%filSC) & ' &' & ' ''' & %sFileName & '''')
          #SET(%txaLine, %txaLine & ALL(' ', %AtColPos2 - (LEN(%txaLine) + LEN(' '))) & ' ! ' & %FilePrefix & ':' & %File)
%txaLine
        #ELSE
  ! %ReportedFiles #<! (%FilePrefix , %FileName) [%sFileNameExternal] has no name assignment
        #ENDIF
        #SET(%CountFiles,%CountFiles + 1)
      #ENDFOR
    #ENDFOR
  #ENDFOR
#!
#!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5300
PROPERTY:END
  #SET(%CountFiles,ITEMS(%ReportedFiles))
  ! There are %CountFiles tables that had their name set up.

  COMPILE('!***WAIT***', WAIT_WINDOW)
      POST(EVENT:CloseWindow)
    END
  END
  CLOSE(SQLOpenWindow)
  SETCURSOR()
  !***WAIT***
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5400
PROPERTY:END
  S_LOGIN_RYB_DP                    = C_LOGIN_RYB_DP
  S_LOGIN_RYB_DW                    = C_LOGIN_RYB_DW
  S_LOGIN_RYB_SS                    = C_LOGIN_RYB_SS

  S_SERVERNAME                      = '127.0.0.1'
  S_DATABASENAME                    = 'ryb_dp'

  L_PORTNUMBER                      = 5432
  B_AUTHENTICATION                  = 0
  B_SSL                             = 0

  S_USERNAME                        = ''
  S_PASSWORD                        = ''
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5400
PROPERTY:END
  COMPILE('!***LOGIN***', LOGIN_WINDOW)
  bRC                               = sql_user_login()
  !***LOGIN***
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5400
PROPERTY:END
!!!
#![SOURCE]
#!PROPERTY:BEGIN
#!PRIORITY 5500
#!PROPERTY:END
#!! RA.2010.12.22 - DICTIONARY: ryb_dp. Set OWNER string here.
#!  DB001:FullPathname                = C_DATABASE_RYB_DP
#!  DB001:DriverOptions               = ''
#!  DB001:OwnerName                   = S_LOGIN_RYB_DP
#![SOURCE]
#!PROPERTY:BEGIN
#!PRIORITY 5500
#!PROPERTY:END
#!! RA.2010.12.22 - DICTIONARY: ryb_dw. Set OWNER string here.
#!  DB002:FullPathname                = C_DATABASE_RYB_DW
#!  DB002:DriverOptions               = ''
#!  DB002:OwnerName                   = S_LOGIN_RYB_DW
#![SOURCE]
#!PROPERTY:BEGIN
#!PRIORITY 5500
#!PROPERTY:END
#!! RA.2010.12.22 - DICTIONARY: ryb_ss. Set OWNER string here.
#!  DB003:FullPathname                = C_DATABASE_RYB_SS
#!  DB003:DriverOptions               = ''
#!  DB003:OwnerName                   = S_LOGIN_RYB_SS
#!
#!
  #FOR(%dctDB)
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5500
PROPERTY:END
! RA.%@D010.@(TODAY()): DICTIONARY: %dctDB. Set OWNER string here.
  #ENDFOR
#!
#!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 9950
PROPERTY:END
  MESSAGE('Globals have been intitalized and database connection has occured!', 'PostgreSQL_Database_Connect')
  RETURN bRC
[END]
EMBED %%LocalProcedures
[DEFINITION]
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5000
PROPERTY:END
sql_user_login      PROCEDURE() !,BOOL,PROC
bStatus             BOOL(TRUE)
  CODE

  OPEN(SQLUserLogin)
  ACCEPT
    CASE ACCEPTED()
    OF ?OptionsButtonLogin
      sql_user_options()
    OF ?OkButtonLogin
      !MESSAGE('Okay')
      !-------------------------------------------!
      ! Verify that you all the component pieces. !
      !-------------------------------------------!
      IF (S_USERNAME = '') THEN
        CYCLE
      END
      IF (S_PASSWORD = '') THEN
        CYCLE
      END
      IF (S_SERVERNAME = '') THEN
        CYCLE
      END
      IF (S_DATABASENAME = '') THEN
        CYCLE
      END
      IF (L_PORTNUMBER < 1) THEN
        CYCLE
      END

      !----------------------------------------------------------!
      ! Collect all the pieces and create the connection string. !
      !----------------------------------------------------------!
      !S_LOGIN_RYB_DP                    = C_LOGIN_RYB_DP
      S_LOGIN_RYB_DP                    = ''
      S_LOGIN_RYB_DP                    = CLIP(S_LOGIN_RYB_DP) & C_LOGIN_RYB_USER
      S_LOGIN_RYB_DP                    = CLIP(S_LOGIN_RYB_DP) & 'SERVER='   & S_SERVERNAME   & ';'
      S_LOGIN_RYB_DP                    = CLIP(S_LOGIN_RYB_DP) & 'PORT='     & L_PORTNUMBER   & ';'
      S_LOGIN_RYB_DP                    = CLIP(S_LOGIN_RYB_DP) & 'UID='      & S_USERNAME     & ';'
      S_LOGIN_RYB_DP                    = CLIP(S_LOGIN_RYB_DP) & 'PWD='      & S_PASSWORD     & ';'

      S_LOGIN_RYB_DW                    = CLIP(S_LOGIN_RYB_DP)
      S_LOGIN_RYB_SS                    = CLIP(S_LOGIN_RYB_DP)

      S_LOGIN_RYB_DP                    = CLIP(S_LOGIN_RYB_DP) & 'DATABASE=' & S_DATABASENAME & ''

      S_LOGIN_RYB_DW                    = CLIP(S_LOGIN_RYB_DW) & 'DATABASE=' & 'ryb_dw'       & ''
      S_LOGIN_RYB_SS                    = CLIP(S_LOGIN_RYB_SS) & 'DATABASE=' & 'ryb_ss'       & ''

      !STOP('S_LOGIN_RYB_DP: ' & CLIP(S_LOGIN_RYB_DP) & '')
      !STOP('S_LOGIN_RYB_DW: ' & CLIP(S_LOGIN_RYB_DW) & '')
      !STOP('S_LOGIN_RYB_SS: ' & CLIP(S_LOGIN_RYB_SS) & '')

      !----------------------------------------------------!
      ! Verify connection by setting up and opening table. !
      !----------------------------------------------------!
      DB001:DriverOptions               = ''
      DB001:OwnerName                   = S_LOGIN_RYB_DP
      DB001:FullPathname                = C_DATABASE_RYB_DP

      !===INCLUDE===
      INCLUDE('LOGIN.CLW')
      !===INCLUDE===

      END

      POST(EVENT:CloseWindow)
    OF ?CancelButtonLogin
      !MESSAGE('Cancel')
      !-------------------------------------------------------!
      ! For now default the path to something when a problem. !
      ! You will be able to still connect to something.       !
      ! In production this will change to exit the program.   !
      !-------------------------------------------------------!
      S_LOGIN_RYB_DP                    = C_LOGIN_RYB_DP
      S_LOGIN_RYB_DW                    = C_LOGIN_RYB_DW
      S_LOGIN_RYB_SS                    = C_LOGIN_RYB_SS
      !-------------------------------------------------------!
      !-------------------------------------------------------!
      bStatus                           = FALSE
      POST(EVENT:CloseWindow)
    ELSE
    END
  END
  CLOSE(SQLUserLogin)

  RETURN bStatus
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5000
PROPERTY:END
sql_user_options    PROCEDURE() !,BOOL,PROC
bReturn             BOOL(TRUE)
  CODE

  OPEN(SQLUserOptions)
  ACCEPT
!    IF EVENT() = Event:OpenWindow
!      POST(EVENT:CloseWindow)
!    END
    CASE ACCEPTED()
    OF ?SaveButtonOptions
      MESSAGE('Save')
      POST(EVENT:CloseWindow)
    OF ?CancelButtonOptions
      MESSAGE('Cancel')
      POST(EVENT:CloseWindow)
    ELSE
    END
  END
  CLOSE(SQLUserOptions)

  RETURN bReturn
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5000
PROPERTY:END
!!
[SOURCE]
PROPERTY:BEGIN
PRIORITY 5000
PROPERTY:END
!!
[END]
[END]
#GROUP(%TxaPostgreSqlConnect2End)
#!--------------------------------------------------------------------
#!--------------------------------------------------------------------
#GROUP(%UTILPostgreSQLConnectSchema2End)
#!--------------------------------------------------------------------


#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
