#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! File Name:   D2M2_000.tpw
#! Purpose:     METABASE: DCT to GENERIC creation script
#! Author:      Copyright © 1999-2999 by Roberto Artigas Jr
#!              All rights reserved world wide.
#! Changes:
#! 2019.07.25:  Roberto Artigas
#!  *   Moved some code into other source files.
#! 2019.07.19:  Roberto Artigas
#!  *   Added basic GUID/UUID create table generation setup options. Not much else.
#! 2019.07.04:  Roberto Artigas
#!  *   Added option to select files to do SQL generation.
#! 2018.11.09   Roberto Artigas 
#!  *   No AUTO-INCREMENT flag found (And you need to generate a ROW level AUTO-INCREMENT)
#! 2018.04.07   Roberto Artigas
#!  *   The backend being generated for is now passed as a parameter.
#! 2018.03.15   Roberto Artigas
#!  *   Metabase and Mimer templates use WinSQL to process DDL statements.
#!      This means the semi-colons at the end get replaced with GO.
#!  *   Seems that WinSQL has a problem with comments being submitted
#!      by themselves and then reaching the end of a DDL script.
#!      You get a syntax error that has nothing to do with anything.
#! 2017.09.29   Roberto Artigas
#!  *   Creation of this generic structured template
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%MITLicenseD2M2000)
#TAB('MIT'),PROP(PROP:FontStyle,700)
#INSERT(%MITLicense)
#ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!
#UTILITY(D2M2_000, '2019.07.28: [MB] METABASE-SKELETON script')
#!-----------------------------------------------------------------------------
#! RA.2018.03.16 - Mimer: WinSQL does not like trailing comments. Gives errors.
#! RA.2017.12.27 - Made the METABASE same as MIMER. Got to have a starting point.
#! RA.2017.12.17 - The %BaseName determines what backend you are processing.
#! All the specific items related to a backend can be coded with a case statement.
#! This will make the code easier to maintain accross all the backends.
#PREPARE
#DECLARE(%BaseUtil)                                                             #! Define the UTILITY here
#SET(%BaseUtil, 'CLARION')                                                      #! TPLUTILITY: NOT A BACKEND
#DECLARE(%BaseName)                                                             #! Define the BACKEND here
#SET(%BaseName, 'PSQL')                                                         #! PSQL: ???
#SET(%BaseName, 'INTERBASE')                                                    #! INTERBASE: ???
#SET(%BaseName, 'PERVASIVE')                                                    #! PERVASIVE: ???
#SET(%BaseName, 'FIREBIRD')                                                     #! FIREBIRD: ???
#SET(%BaseName, 'SYBASE')                                                       #! SYBASE: ???
#SET(%BaseName, 'DB2')                                                          #! DB2: ???
#SET(%BaseName, 'ORACLE')                                                       #! ORACLE: ???
#SET(%BaseName, 'MYSQL')                                                        #! MYSQL:         RAYS.2018.09.03: Tested. 
#SET(%BaseName, 'SQLANYWHERE')                                                  #! SQLANYWHERE:   RAYS.2018.06.12: Tested.
#SET(%BaseName, 'POSTGRESQL')                                                   #! POSTGRESQL:    RAYS.2018.06.10: Tested.
#SET(%BaseName, 'MSSQL')                                                        #! MSSQL:         RAYS.2018.06.03: Tested.
#SET(%BaseName, 'MIMER')                                                        #! MIMER:         RAYS.2018.04.07: Tested.
#SET(%BaseName, 'METABASE')                                                     #! METABASE:      Generic-Skeleton. NO backend.
#ENDPREPARE
#!---------------------------------------------------------------------
#!INSERT(%Preamble)                                       \                     #! Basic copyright message
#!INSERT(%DefineAreasOptions)                                                    #! File,Field,Keys,Relations
#INSERT(%VariablesCommon)                                                       #! Need a few simple variables
#INSERT(%GetDictionaryPath)                                                     #! Get dictionary path and names
#INSERT(%VariablesDeclare)                                                      #! Option checks and output file names
#INSERT(%VariablesSetup)                                                        #! Setup output file names
#INSERT(%VariablesOptions)                                                      #! All option variables setup here
#INSERT(%DefineAreasOptions)                                                    #! File,Field,Keys,Relations
#INSERT(%ReserveWordDefines)                                                    #! Reserved Words Defines
#INSERT(%Preamble)                                                              #! Basic copyright message
#!---------------------------------------------------------------------
#!SHEET,HSCROLL,AT(,,288)
#SHEET,HSCROLL,AT(,,464)
  #INSERT(%ShowVariables)
  #INSERT(%MITLicenseD2M2000)
  #INSERT(%MetabaseTabSelection)                                                #! RA.2019.07.04: Added FILE selection
  #INSERT(%MetabaseTabNames)
  #INSERT(%MetabaseTabCreateDropOther)
  #INSERT(%MetabaseTabCreateDropScripting)                                      #! RA.2019.07.28: Added
  #INSERT(%MetabaseTabOptions)
  #INSERT(%MetabaseTabStrings)
  #INSERT(%MetabaseTabArrays)
#ENDSHEET
#!---------------------------------------------------------------------
#! START EXECUTION HERE
#!---------------------------------------------------------------------
#!#DECLARE(%DebugSet,LONG)
#!#SET(%DebugSet,1)
#!#DEBUG(%DebugSet)
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#!INSERT(%MetabaseGenerate)                                                     #! DDL scripts for METABASE
#!CALL(%MetabaseGenerate)                                                       #! DDL scripts for METABASE
#CALL(%MetabaseGenerate,%BaseName)                                              #! DDL scripts for METABASE
#!
#!#SET(%DebugSet,0)
#!#DEBUG(%DebugSet)
#!---------------------------------------------------------------------
#! END EXECUTION HERE
#!---------------------------------------------------------------------
#GROUP(%Preamble)                                                               #! Basic copyright message
#BOXED('The METABASE-' & %BaseName & ' Script Creator'),PROP(PROP:FontStyle,700)
  #DISPLAY(''),AT(,,,1)
  #!DISPLAY('The METABASE-' & %BaseName & ' Script Creator.')
  #DISPLAY('Copyright © 1999-2999 by Roberto Artigas y Soler')
  #DISPLAY('All Rights Reserved World Wide.')
  #DISPLAY('Released under the conditions of the MIT license.')
  #DISPLAY('E-mail: roberto.artigas.dev@gmail.com')
  #DISPLAY('Skype: Clarion Live Chat | CW-Talk')
#ENDBOXED
#!---------------------------------------------------------------------
#GROUP(%PreambleUtility)                                                        #! 2019.07.07.SUN: Added
#BOXED('A UTILITY-' & %BaseName & ' Generic Utility'),PROP(PROP:FontStyle,700)
  #DISPLAY(''),AT(,,,1)
  #DISPLAY('Copyright © 1999-2999 by Roberto Artigas y Soler')
  #DISPLAY('All Rights Reserved World Wide.')
  #DISPLAY('Released under the conditions of the MIT license.')
  #DISPLAY('E-mail: roberto.artigas.dev@gmail.com')
  #DISPLAY('Skype: Clarion Live Chat | CW-Talk')
#ENDBOXED
#!---------------------------------------------------------------------
#GROUP(%PreambleCombined)                                                        #! 2019.08.14.WED: Added
#BOXED('A COMBINED-' & %BaseName & ' Script Creator'),PROP(PROP:FontStyle,700)
  #DISPLAY(''),AT(,,,1)
  #DISPLAY('Copyright © 1999-2999 by Roberto Artigas y Soler')
  #DISPLAY('All Rights Reserved World Wide.')
  #DISPLAY('Released under the conditions of the MIT license.')
  #DISPLAY('E-mail: roberto.artigas.dev@gmail.com')
  #DISPLAY('Skype: Clarion Live Chat | CW-Talk')
#ENDBOXED
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%ExplainDCT2SQL)
#PREPARE
  #IF(NOT VAREXISTS(%ExplainTextDCT2SQL))
    #DECLARE(%ExplainTextDCT2SQL)
  #ENDIF
  #SET(%ExplainTextDCT2SQL, '')
  #!SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & 'This is one of the METABASE templates.')
  #!SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & '<13,10><13,10>')
  #SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & 'The CREATE and DROP tabs have a set of unique DDL scripts that will allow')
  #SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & ' the generating of these scripts individually so you can mix and match scripts.')
  #SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & '<13,10><13,10>')
  #SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & 'These DDL scripts will help in the loading of the data and the reindexing')
  #SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & ' of the any database tables as needed.')
  #!SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & '<13,10><13,10>')
  #!SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & 'This template has been tested with the ABC template chains.')
  #SET(%ExplainTextDCT2SQL, %ExplainTextDCT2SQL & '')
#ENDPREPARE
#!
#GROUP(%ShowVariables)
#INSERT(%ExplainDCT2SQL)
#!TAB(UPPER(%Application) & '.' & UPPER(%ProgramExtension)),PROP(PROP:FontStyle,700),PROP(PROP:FontColor,0C79A3H)
#TAB(UPPER(%DictName) & '.DCT'),PROP(PROP:FontStyle,700),PROP(PROP:FontColor,0C79A3H)
  #BOXED('Instructions'),AT(,,454),PROP(PROP:FontStyle,700)
    #DISPLAY(''),AT(,,,1)
    #!DISPLAY(%ExplainTextDCT2SQL),AT(,,260,74)
    #!DISPLAY(%ExplainTextDCT2SQL),AT(,,260,40)
    #DISPLAY(%ExplainTextDCT2SQL),AT(,,436,34)
  #ENDBOXED
  #BOXED('Hidden Variables'),AT(,,454) #!,HIDE
    #DISPLAY(''),AT(,,,1)
    #!PROMPT(''             ,@S120), %CreateNameTable   , AT(10,,266), PROP(PROP:Readonly, 1) #!, PROP(PROP:Trn, 1)
    #!PROMPT(''             ,@S120), %CreateNameTableOut, AT(10,,266), PROP(PROP:Readonly, 1) #!, PROP(PROP:Trn, 1)
    #PROMPT(''              ,@S120), %CreateNameTable   , AT(10,,444), PROP(PROP:Readonly, 1) #!, PROP(PROP:Trn, 1)
    #PROMPT(''              ,@S120), %CreateNameTableOut, AT(10,,444), PROP(PROP:Readonly, 1) #!, PROP(PROP:Trn, 1)
    #!PROMPT('DictPath: '   ,@S80 ), %DictPath, AT(60,,216), PROP(PROP:Readonly, 1), PROP(PROP:Skip, 1)
    #PROMPT('DictPath: '    ,@S80 ), %DictPath, AT(60,,394), PROP(PROP:Readonly, 1), PROP(PROP:Skip, 1)
    #PROMPT('DictName: '    ,@S40 ), %DictName, AT(60,,60), PROP(PROP:Readonly, 1)
    #PROMPT('BaseName: '    ,@S40 ), %BaseName, AT(60,,60), PROP(PROP:Readonly, 1)
    #!PROMPT('nLoc1: '       ,@N4  ), %nLoc1, AT(60,,60), PROP(PROP:Readonly, 1)
    #!PROMPT('nLoc2: '       ,@N4  ), %nLoc2, AT(60,,60), PROP(PROP:Readonly, 1)
    #PROMPT('Generate comments (filtered out by backend)', CHECK), %Comments, AT(10),   DEFAULT(TRUE)
    #PROMPT('Trace the SQL DDL code generation group flow', CHECK), %TraceFlow, AT(10), DEFAULT(FALSE)
    #PROMPT('Trace detail generation for debug purposes', CHECK), %TraceDetail, AT(10), DEFAULT(FALSE)    
    #PROMPT('Trace option parameters for debug purposes', CHECK), %TraceOption, AT(10), DEFAULT(FALSE)    
    #!PROMPT('Database: '    ,@S80 ), %NameDatabase  , AT(60,,60)
    #!PROMPT('Owner: '       ,@S40 ), %NameOwner     , AT(60,,60)
  #ENDBOXED
#ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2019.07.04: Added option to select files to do SQL generation.
#GROUP(%MetabaseTabSelection)
#TAB('Selection')  #!,PROP(PROP:FontStyle,700),PROP(PROP:FontColor,0C79A3H)
  #BOXED(''),AT(,,454),PROP(PROP:FontStyle,700)
    #!DISPLAY(''),AT(,,,1)
    #PROMPT ('Generate SQL for all files in the dictionary.', CHECK), %optUseAllFiles, DEFAULT(1), AT(10)
    #DISPLAY(''),AT(,,,1)
    #ENABLE(~%optUseAllFiles)
      #!PROMPT ('File Selection', FROM (%File)), %optFileSelection, INLINE, SELECTION('File Selection')
      #PROMPT ('File Selection', FROM (%NFilesSort)), %optFileSelection, INLINE, SELECTION('File Selection')
    #ENDENABLE
  #ENDBOXED
#ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.08 - Define some names for script generation
#GROUP(%MetabaseTabNames)
#TAB('Defines')
  #! RA.2018.04.20: A bit more useful if it is the only item on the screen
  #! #BOXED,SECTION
  #!   #BOXED('Define Constant Names'),AT(,0,454),WHERE(%optNameEnable)
  #!     #!DISPLAY(''),AT(,,,1)
  #!     #!PROMPT('Database: '   ,@S80 ), %NameDatabase  , AT(60,,216)
  #!     #PROMPT('Database: '    ,@S80 ), %NameDatabase  , AT(60,,60)
  #!     #PROMPT('Owner: '       ,@S40 ), %NameOwner     , AT(60,,60)
  #!   #ENDBOXED
  #!   #BOXED('Define Constant Names (OPTION NOT REQUIRED)'),AT(,0,454),WHERE(NOT %optNameEnable)
  #!     #!DISPLAY(''),AT(,,,1)
  #!     #DISPLAY('')
  #!     #DISPLAY('')
  #!   #ENDBOXED
  #! #ENDBOXED
  #!
  #! RA.2018.04.21: %NameDatabase is READ-ONLY. Just a reminder...
  #! RA.2018.04.20: The "%optNameEnable" in both places blanks out everything.
  #!                Preserves the vertical spacing if you have several boxes.
  #ENABLE(%optNameEnable)
    #BOXED('Define Constant Names'),AT(,,454),WHERE(%optNameEnable)
      #DISPLAY(''),AT(,,,1)
      #!PROMPT('Database: '   ,@S80 ), %NameDatabase  , AT(60,,216)
      #PROMPT('Database: '    ,@S40 ), %NameDatabase  , AT(60,,60) , PROP(PROP:Readonly, 1)
      #PROMPT('Owner: '       ,@S40 ), %NameOwner     , AT(60,,60)
      #ENABLE(%optNameOwnerEnable)
        #PROMPT('Use "Owner:" prefix when generating tables', CHECK), %optNameOwnerUse, AT(10)
      #ENDENABLE
    #ENDBOXED
  #ENDENABLE
  #ENABLE(%optDefineNamesEnable)
    #BOXED('Table Names | File Names'),AT(,,454)
      #DISPLAY(''),AT(,,,1)
      #PROMPT('Table Name Generation:',DROP('Table Names|File Names')),%optDefineNames,AT(110,,90),DEFAULT('Table Names')
    #ENDBOXED
  #ENDENABLE
  #! RA.2019.07.19: This is basic GUID/UUID create table generation setup. Not much else.
  #ENABLE(%optEnableGenerateGUID)
    #BOXED('Enable GUID/UUID Generation'),AT(,,454)
      #DISPLAY(''),AT(,,,1)
      #PROMPT('Use backend support for GUID/UUID generation', CHECK),%optGenerateGUID,AT(10)
    #ENDBOXED
  #ENDENABLE
#ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%MetabaseTabCreateDropOther)
#TAB('CREATE')
  #!BOXED(''),AT(,,454)
  #BOXED(%BaseName),AT(,,454),PROP(PROP:FontStyle,700)
   #PROMPT('CREATE Table?'              ,CHECK),%CreateChekTable            ,AT(10)
   #PROMPT(''                           ,@S120),%CreateNameTable            ,AT(10,,444)
   #!PROMPT(''                          ,@S120),%CreateNameTable            ,AT(10,,266)
   #!DISPLAY('')
   #PROMPT('CREATE Sequence?'           ,CHECK),%CreateChekSequence         ,AT(10)
   #PROMPT(''                           ,@S120),%CreateNameSequence         ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('CREATE Primary Key?'        ,CHECK),%CreateChekKeyPrimary       ,AT(10)
   #PROMPT(''                           ,@S120),%CreateNameKeyPrimary       ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('CREATE Index Unique?'       ,CHECK),%CreateChekIndexUnique      ,AT(10)
   #PROMPT(''                           ,@S120),%CreateNameIndexUnique      ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('CREATE Index Not Unique?'   ,CHECK),%CreateChekIndexNotUnique   ,AT(10)
   #PROMPT(''                           ,@S120),%CreateNameIndexNotUnique   ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('CREATE Relation?'           ,CHECK),%CreateChekRelation         ,AT(10)
   #PROMPT(''                           ,@S120),%CreateNameRelation         ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('CREATE Grant? '             ,CHECK),%CreateChekGrant            ,AT(10)
   #PROMPT(''                           ,@S120),%CreateNameGrant            ,AT(10,,444)
  #ENDBOXED
#ENDTAB
#TAB('DROP')
  #!BOXED(''),AT(,,454)
  #BOXED(%BaseName),AT(,,454),PROP(PROP:FontStyle,700)
   #PROMPT('DROP Table?'                ,CHECK),%DropItChekTable            ,AT(10)
   #PROMPT(''                           ,@S120),%DropItNameTable            ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('DROP Sequence?'             ,CHECK),%DropItChekSequence         ,AT(10)
   #PROMPT(''                           ,@S120),%DropItNameSequence         ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('DROP Primary Key?'          ,CHECK),%DropItChekKeyPrimary       ,AT(10)
   #PROMPT(''                           ,@S120),%DropItNameKeyPrimary       ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('DROP Index Unique?'         ,CHECK),%DropItChekIndexUnique      ,AT(10)
   #PROMPT(''                           ,@S120),%DropItNameIndexUnique      ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('DROP Index Not Unique?'     ,CHECK),%DropItChekIndexNotUnique   ,AT(10)
   #PROMPT(''                           ,@S120),%DropItNameIndexNotUnique   ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('DROP Relation?'             ,CHECK),%DropItChekRelation         ,AT(10)
   #PROMPT(''                           ,@S120),%DropItNameRelation         ,AT(10,,444)
   #!DISPLAY('')
   #PROMPT('DROP Grant? '               ,CHECK),%DropItChekGrant            ,AT(10)
   #PROMPT(''                           ,@S120),%DropItNameGrant            ,AT(10,,444)
  #ENDBOXED
#ENDTAB
#!
#! RA.2019.07.29: This area requires some knowledge of the SCRIPTING language for the backend.
#! NOTE: The  ,WHERE(%optUseScripting)  only shows the tabs for the BACKENDs that currently support this.
#!
#TAB('OTHER'),WHERE(%optUseScripting)
  #BOXED(%BaseName),AT(,,454),PROP(PROP:FontStyle,700)
   #PROMPT('Build GUID Index?'          ,CHECK),%BuildChekIndexGUID         ,AT(10)
   #PROMPT(''                           ,@S120),%BuildNameIndexGUID         ,AT(10,,444)
  #ENDBOXED
#ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2019.07.28: This area requires some knowledge of the SCRIPTING language for the backend.
#! NOTE: The  ,WHERE(%optUseScripting)  only shows the tabs for the BACKENDs that currently support this.
#!
#! So it is only enabled if the code exists for the specific backend. Working on PostgreSQL.
#! At this time this is only in the METABASE (not a real backend) and PostgreSQL (what I use)
#! NOTE: TRIGGERs also contain logic and table field names that are specific to your system.
#!       So that means that this area is highly customizable. (You need to know about templates.)
#GROUP(%MetabaseTabCreateDropScripting)
#TAB('CREATE2'),WHERE(%optUseScripting)
  #BOXED(%BaseName),AT(,,454),PROP(PROP:FontStyle,700)
   #PROMPT('CREATE Triggers?'           ,CHECK),%CreateChekTrigger          ,AT(10)
   #PROMPT(''                           ,@S120),%CreateNameTrigger          ,AT(10,,444)
  #ENDBOXED
#ENDTAB
#TAB('DROP2'),WHERE(%optUseScripting)
  #BOXED(%BaseName),AT(,,454),PROP(PROP:FontStyle,700)
   #PROMPT('DROP Triggers?'             ,CHECK),%DropItChekTrigger          ,AT(10)
   #PROMPT(''                           ,@S120),%DropItNameTrigger          ,AT(10,,444)
  #ENDBOXED
#ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.12.THU - Added full path name and driver to the comments.
#! RA.2018.04.08.SUN - Pass %BaseName as a parameter
#! RA.2018.03.17.SAT - No trailing comments for WinSQL. Errors out.
#GROUP(%TableNameComments,%pBaseName)
  #IF(%Comments)
    #CASE(%pBaseName)                                                           #! BACKEND EXCEPTIONS
    #OF  ('MIMER')
    #ELSE

--
-- TABLE NAME: %NFilesName [%FilePrefix]
--  FILE NAME: %NFilesFullPath [%FileDriver]
--
    #ENDCASE                                                                    #! BACKEND EXCEPTIONS
  #ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%MetabaseTabOptions)
#TAB('Options')
  #BOXED('Cosmetic Options'),AT(,,454)
    #DISPLAY(''),AT(,,,1)
    #PROMPT('Do DDL table create statement alignment for verification purposes',CHECK),%optDoSpaceAlign,AT(10)
  #ENDBOXED
  #BOXED('Tables, Fields, Sequences, Indexes, Relations'),AT(,,454)
    #DISPLAY(''),AT(,,,1)
    #PROMPT('Add "_" to the end of reserved SQL words?',CHECK),%optUnderReservedWords,AT(10)
    #!DISPLAY('')
  #ENDBOXED
#ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%MetabaseTabStrings)
  #TAB('Strings/Keys/Blobs')
   #BOXED('International Strings'),AT(,,454)
    #DISPLAY(''),AT(,,,1)
    #PROMPT('Generate international strings ',CHECK),%optGenIntlString,AT(10)
   #ENDBOXED
   #!DISPLAY('')
   #BOXED('NOT NULL Keys'),AT(,,454)
    #DISPLAY(''),AT(,,,1)
    #PROMPT('Generate NOT NULL keys ',CHECK),%optGenNotNullKeys,AT(10)
   #ENDBOXED
   #!DISPLAY('')
   #BOXED('BLOB to CLOB'),AT(,,454)
    #DISPLAY(''),AT(,,,1)
    #PROMPT('Generate CLOB fields ',CHECK),%optGenClobFields,AT(10)
   #ENDBOXED
 #ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%MetabaseTabArrays)
#TAB('Arrays')
  #BOXED('Handle Array Processing'),AT(,,454)
   #DISPLAY(''),AT(,,,1)
   #DISPLAY('There are two ways to handle arrays:')
   #DISPLAY(''),AT(,,,1)
   #DISPLAY('1) You defined a group with all the fields of the array inside this group.')
   #DISPLAY('   Then you put the array OVER the group. If you set up your arrays in this manner,')
   #DISPLAY('   then LEAVE the checkbox bellow OFF.')
   #DISPLAY(''),AT(,,,1)
   #DISPLAY('2) You define your arrays as actual fields using no groups whatsoever. ')
   #DISPLAY('   If you set up your arrays this way, then TURN ON the checkbox bellow.')
   #DISPLAY('')
   #PROMPT('I DO NOT HAVE ARRAYS OVER GROUPS. ',CHECK),%optNoArrayOver,AT(10)
  #ENDBOXED
#ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#!GROUP(%MetabaseGenerate)
#GROUP(%MetabaseGenerate,%pBaseName)                                            #! %BaseName as a parameter 
#!---------------------------------------------------------------------
#INSERT(%ReserveWordBuild)                                                      #! Reserved Words
#INSERT(%BuildQualifiedFiles)                                                   #! List of QUALIFIED tables
#INSERT(%BuildFieldsNOTNULL)                                                    #! Fields that are NOT NULL
#!---------------------------------------------------------------------
#CALL(%MetabaseTableCreate                                  ,%pBaseName)        #! TABLE create
#CALL(%MetabaseTableDropIt                                  ,%pBaseName)        #! TABLE drop
#CALL(%MetabaseSequenceCreate                               ,%pBaseName)        #! SEQUENCE create
#CALL(%MetabaseSequenceDropIt                               ,%pBaseName)        #! SEQUENCE drop
#CALL(%MetabaseKeyPrimaryCreate                             ,%pBaseName)        #! KEY PRIMARY create
#CALL(%MetabaseKeyPrimaryDropIt                             ,%pBaseName)        #! KEY PRIMARY drop
#CALL(%MetabaseIndexUniqueCreate                            ,%pBaseName)        #! INDEX UNIQUE create
#CALL(%MetabaseIndexUniqueDropIt                            ,%pBaseName)        #! INDEX UNIQUE drop
#CALL(%MetabaseIndexNotUniqueCreate                         ,%pBaseName)        #! INDEX NOT UNIQUE create
#CALL(%MetabaseIndexNotUniqueDropIt                         ,%pBaseName)        #! INDEX NOT UNIQUE drop
#CALL(%MetabaseRelationCreate                               ,%pBaseName)        #! RELATION create
#CALL(%MetabaseRelationDropIt                               ,%pBaseName)        #! RELATION drop
#CALL(%MetabaseGrantCreate                                  ,%pBaseName)        #! GRANT create
#CALL(%MetabaseGrantDropIt                                  ,%pBaseName)        #! GRANT drop
#!---------------------------------------------------------------------         #! RA.2019.07.28: Added calls bellow
#CALL(%MetabaseTriggerCreate                                ,%pBaseName)        #! TRIGGER create
#CALL(%MetabaseTriggerDropIt                                ,%pBaseName)        #! TRIGGER drop
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseTableCreate,%pBaseName)                                         #! TABLE create
#CALL(%MetabaseTableCreatePrefix                            ,%pBaseName)        #! TABLE create prefix
#CALL(%MetabaseTableCreateGenerate                          ,%pBaseName)        #! TABLE create generate
#CALL(%MetabaseTableCreateSuffix                            ,%pBaseName)        #! TABLE create suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseTableDropIt,%pBaseName)                                         #! TABLE drop
#CALL(%MetabaseTableDropItPrefix                            ,%pBaseName)        #! TABLE drop prefix
#CALL(%MetabaseTableDropItGenerate                          ,%pBaseName)        #! TABLE drop generate
#CALL(%MetabaseTableDropItSuffix                            ,%pBaseName)        #! TABLE drop suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseSequenceCreate,%pBaseName)                                      #! SEQUENCE create
#CALL(%MetabaseSequenceCreatePrefix                         ,%pBaseName)        #! SEQUENCE create prefix
#CALL(%MetabaseSequenceCreateGenerate                       ,%pBaseName)        #! SEQUENCE create generate
#CALL(%MetabaseSequenceCreateSuffix                         ,%pBaseName)        #! SEQUENCE create suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseSequenceDropIt,%pBaseName)                                      #! SEQUENCE drop
#CALL(%MetabaseSequenceDropItPrefix                         ,%pBaseName)        #! SEQUENCE drop prefix
#CALL(%MetabaseSequenceDropItGenerate                       ,%pBaseName)        #! SEQUENCE drop generate
#CALL(%MetabaseSequenceDropItSuffix                         ,%pBaseName)        #! SEQUENCE drop suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseKeyPrimaryCreate,%pBaseName)                                    #! KEY PRIMARY create
#CALL(%MetabaseKeyPrimaryCreatePrefix                       ,%pBaseName)        #! KEY PRIMARY create prefix
#CALL(%MetabaseKeyPrimaryCreateGenerate                     ,%pBaseName)        #! KEY PRIMARY create generate
#CALL(%MetabaseKeyPrimaryCreateSuffix                       ,%pBaseName)        #! KEY PRIMARY create suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseKeyPrimaryDropIt,%pBaseName)                                    #! KEY PRIMARY drop
#CALL(%MetabaseKeyPrimaryDropItPrefix                       ,%pBaseName)        #! KEY PRIMARY drop prefix
#CALL(%MetabaseKeyPrimaryDropItGenerate                     ,%pBaseName)        #! KEY PRIMARY drop generate
#CALL(%MetabaseKeyPrimaryDropItSuffix                       ,%pBaseName)        #! KEY PRIMARY drop suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseIndexUniqueCreate,%pBaseName)                                   #! INDEX UNIQUE create
#CALL(%MetabaseIndexUniqueCreatePrefix                      ,%pBaseName)        #! INDEX UNIQUE create prefix
#CALL(%MetabaseIndexUniqueCreateGenerate                    ,%pBaseName)        #! INDEX UNIQUE create generate
#CALL(%MetabaseIndexUniqueCreateSuffix                      ,%pBaseName)        #! INDEX UNIQUE create suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseIndexUniqueDropIt,%pBaseName)                                   #! INDEX UNIQUE drop
#CALL(%MetabaseIndexUniqueDropItPrefix                      ,%pBaseName)        #! INDEX UNIQUE drop prefix
#CALL(%MetabaseIndexUniqueDropItGenerate                    ,%pBaseName)        #! INDEX UNIQUE drop generate
#CALL(%MetabaseIndexUniqueDropItSuffix                      ,%pBaseName)        #! INDEX UNIQUE drop suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseIndexNotUniqueCreate,%pBaseName)                                #! INDEX NOT UNIQUE create
#CALL(%MetabaseIndexNotUniquePrefix                         ,%pBaseName)        #! INDEX NOT UNIQUE create prefix
#CALL(%MetabaseIndexNotUniqueCreateGenerate                 ,%pBaseName)        #! INDEX NOT UNIQUE create generate
#CALL(%MetabaseIndexNotUniqueSuffix                         ,%pBaseName)        #! INDEX NOT UNIQUE create suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseIndexNotUniqueDropIt,%pBaseName)                                #! INDEX NOT UNIQUE drop
#CALL(%MetabaseIndexNotUniqueDropItPrefix                   ,%pBaseName)        #! INDEX NOT UNIQUE drop prefix
#CALL(%MetabaseIndexNotUniqueDropItGenerate                 ,%pBaseName)        #! INDEX NOT UNIQUE drop generate
#CALL(%MetabaseIndexNotUniqueDropItSuffix                   ,%pBaseName)        #! INDEX NOT UNIQUE drop suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseRelationCreate,%pBaseName)                                      #! RELATION create
#CALL(%MetabaseRelationCreatePrefix                         ,%pBaseName)        #! RELATION create prefix
#CALL(%MetabaseRelationCreateGenerate                       ,%pBaseName)        #! RELATION create generate
#CALL(%MetabaseRelationCreateSuffix                         ,%pBaseName)        #! RELATION create suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseRelationDropIt,%pBaseName)                                      #! RELATION drop
#CALL(%MetabaseRelationDropItPrefix                         ,%pBaseName)        #! RELATION drop prefix
#CALL(%MetabaseRelationDropItGenerate                       ,%pBaseName)        #! RELATION drop generate
#CALL(%MetabaseRelationDropItSuffix                         ,%pBaseName)        #! RELATION drop suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseGrantCreate,%pBaseName)                                         #! GRANT create
#CALL(%MetabaseGrantCreatePrefix                            ,%pBaseName)        #! GRANT create prefix
#CALL(%MetabaseGrantCreateGenerate                          ,%pBaseName)        #! GRANT create generate
#CALL(%MetabaseGrantCreateSuffix                            ,%pBaseName)        #! GRANT create suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseGrantDropIt,%pBaseName)                                         #! GRANT drop
#CALL(%MetabaseGrantDropItPrefix                            ,%pBaseName)        #! GRANT drop prefix
#CALL(%MetabaseGrantDropItGenerate                          ,%pBaseName)        #! GRANT drop generate
#CALL(%MetabaseGrantDropItSuffix                            ,%pBaseName)        #! GRANT drof suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------         #! RA.2019.07.28: Added
#GROUP(%MetabaseTriggerCreate,%pBaseName)                                       #! TRIGGER create
#CALL(%MetabaseTriggerCreatePrefix                          ,%pBaseName)        #! TRIGGER create prefix
#CALL(%MetabaseTriggerCreateGenerate                        ,%pBaseName)        #! TRIGGER create generate
#CALL(%MetabaseTriggerCreateSuffix                          ,%pBaseName)        #! TRIGGER create suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------         #! RA.2019.07.28: Added
#GROUP(%MetabaseTriggerDropIt,%pBaseName)                                       #! TRIGGER drop
#CALL(%MetabaseTriggerDropItPrefix                          ,%pBaseName)        #! TRIGGER drop prefix
#CALL(%MetabaseTriggerDropItGenerate                        ,%pBaseName)        #! TRIGGER drop generate
#CALL(%MetabaseTriggerDropItSuffix                          ,%pBaseName)        #! TRIGGER drof suffix
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.17 - The commented code has been tested where you can see the outcome
#! as you are processing the DCT. Then some of the processing is moved to their final
#! locations where there might not be any output file open yet to show the testing
#! as we processing.
#!---------------------------------------------------------------------
#! For example: The qualified files were tested here. After testing they were moved
#! to an earlier moment to process as the qualified files can be used by all the items
#! that generate. But not all the options may generate trace output.
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseTableCreateGenerate,%pBaseName)                                 #! TABLE create generate
#!-- [GENERATE TABLE CREATE]
#!INSERT(%ShowFiles)                                                            #! Simple table show (TESTING)
#!--INSERT(%ReserveWordBuild)                                                   #! Reserved Words
#!--INSERT(%BuildQualifiedFiles)                                                #! List of QUALIFIED tables
#!--#INSERT(%BuildFieldsNOTNULL)                                                #! Fields that are NOT NULL
#INSERT(%ProcessTableCreate                                 ,%pBaseName)        #! RA.2017.12.19: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseTableDropItGenerate,%pBaseName)                                 #! TABLE drop generate
#!-- [GENERATE TABLE DROP]
#INSERT(%ProcessTableDropIt                                 ,%pBaseName)        #! RA.2017.12.19: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseSequenceCreateGenerate,%pBaseName)                              #! SEQUENCE create generate
#!-- [GENERATE SEQUENCE CREATE]
#INSERT(%ProcessSequenceCreate                              ,%pBaseName)        #! RA.2017.12.21: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseSequenceDropItGenerate,%pBaseName)                              #! SEQUENCE drop generate
#!-- [GENERATE SEQUENCE DROP]
#INSERT(%ProcessSequenceDropIt                              ,%pBaseName)        #! RA.2017.12.21: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseKeyPrimaryCreateGenerate,%pBaseName)                            #! KEY PRIMARY create generateN
#!-- [GENERATE KEY PRIMARY CREATE]
#INSERT(%ProcessPrimaryCreate                               ,%pBaseName)        #! RA.2017.12.23: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseKeyPrimaryDropItGenerate,%pBaseName)                            #! KEY PRIMARY drop generate
#!-- [GENERATE KEY PRIMARY DROP]
#INSERT(%ProcessPrimaryDropIt                               ,%pBaseName)        #! RA.2017.12.23: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseIndexUniqueCreateGenerate,%pBaseName)                           #! INDEX UNIQUE create generate
#!-- [GENERATE INDEX UNIQUE CREATE]
#INSERT(%ProcessIndexUniqueCreate                           ,%pBaseName)        #! RA.2017.12.26: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseIndexUniqueDropItGenerate,%pBaseName)                           #! INDEX UNIQUE drop generate
#!-- [GENERATE INDEX UNIQUE DROP]
#INSERT(%ProcessIndexUniqueDropIt                           ,%pBaseName)        #! RA.2017.12.26: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseIndexNotUniqueCreateGenerate,%pBaseName)                        #! INDEX NOT UNIQUE create generate
#!-- [GENERATE INDEX NOT UNIQUE CREATE]
#INSERT(%ProcessIndexNonUniqueCreate                        ,%pBaseName)        #! RA.2018.01.12: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseIndexNotUniqueDropItGenerate,%pBaseName)                        #! INDEX NOT UNIQUE drop generate
#!-- [GENERATE INDEX NOT UNIQUE DROP]
#INSERT(%ProcessIndexNonUniqueDropIt                        ,%pBaseName)        #! RA.2018.01.12: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseRelationCreateGenerate,%pBaseName)                              #! RELATION create generate
#!-- [GENERATE RELATION CREATE]
#INSERT(%ProcessRelationCreate                              ,%pBaseName)        #! RA.2018.02.25: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseRelationDropItGenerate,%pBaseName)                              #! RELATION drop generate
#!-- [GENERATE RELATION DROP]
#INSERT(%ProcessRelationDropIt                              ,%pBaseName)        #! RA.2018.02.25: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseGrantCreateGenerate,%pBaseName)                                 #! GRANT create generate
#!-- [GENERATE GRANT CREATE]
#INSERT(%ProcessGrantCreate                                 ,%pBaseName)        #! RA.2018.02.25: Tested
#!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%MetabaseGrantDropItGenerate,%pBaseName)                                 #! GRANT drop generate
#!-- [GENERATE GRANT DROP]
#INSERT(%ProcessGrantDropIt                                 ,%pBaseName)        #! RA.2018.02.25: Tested
#!
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%DefineAreasOptions)                                                     #! File,Field,Keys,Relations
#INSERT(%DefineFileOptions)                                                     #! File Options
#INSERT(%DefineFieldOptions)                                                    #! Field Options
#INSERT(%DefineKeyOptions)                                                      #! Key Options
#INSERT(%DefineRelationOptions)                                                 #! Relation Options
#!---------------------------------------------------------------------
#GROUP(%DefineFileOptions)
#!DECLARE(%NFilesSort),MULTI,UNIQUE                                             #! RA.2019.07.04: Define a bit earlier
#DECLARE(%CountNFiles)
#DECLARE(%NFiles),MULTI                       #!,UNIQUE
#DECLARE(%NFilesCount             ,%NFiles)   #! ID: Table Count
#DECLARE(%NFilesName              ,%NFiles)   #! Table Name
#DECLARE(%NFilesSeqName           ,%NFiles)   #! Table Sequence Name
#DECLARE(%NFilesSeqField          ,%NFiles)   #! Table Sequence Field
#DECLARE(%NFilesPKeyName          ,%NFiles)   #! Table Primary Key Name
#DECLARE(%NFilesPKeyField         ,%NFiles)   #! Table Primary Field Name
#DECLARE(%NFilesFullPath          ,%NFiles)   #! Table Full Path Name
#! RA.2019.07.06: Additional GUID items to verify per file
#DECLARE(%NFilesKeyCount          ,%NFiles)   #! Table Count Keys
#DECLARE(%NFilesKeyPrimary        ,%NFiles)   #! Table Count Primary Keys
#DECLARE(%NFilesFieldCount        ,%NFiles)   #! Table Count Fields
#DECLARE(%NFilesCountGUID         ,%NFiles)   #! Table Count GUID
#DECLARE(%NFilesCountTS           ,%NFiles)   #! Table Count TS
#DECLARE(%NFilesCountSTS          ,%NFiles)   #! Table Count STS
#DECLARE(%NFilesCountDTS          ,%NFiles)   #! Table Count DTS
#DECLARE(%NFilesOptionGUID        ,%NFiles)   #! Table Option GUID
#DECLARE(%NFilesOptionTS          ,%NFiles)   #! Table Option TS
#DECLARE(%NFilesOptionSTS         ,%NFiles)   #! Table Option STS
#DECLARE(%NFilesOptionDTS         ,%NFiles)   #! Table Option DTS
#! RA.2019.07.26: Verify more GUID items per file
#DECLARE(%NFilesKeyGUID           ,%NFiles)   #! Key for GUID
#DECLARE(%NFilesKeyTS             ,%NFiles)   #! Key for TS
#DECLARE(%NFilesKeySTS            ,%NFiles)   #! Key for STS
#DECLARE(%NFilesKeyDTS            ,%NFiles)   #! Key for DTS
#DECLARE(%NFilesFieldGUID         ,%NFiles)   #! Key-Field for GUID
#DECLARE(%NFilesFieldTS           ,%NFiles)   #! Key-Field for TS
#DECLARE(%NFilesFieldSTS          ,%NFiles)   #! Key-Field for STS
#DECLARE(%NFilesFieldDTS          ,%NFiles)   #! Key-Field for DTS
#! RA.2019.11.20: Added the EncryptionVersion logic to the template.
#DECLARE(%NFilesCountEncrypt      ,%NFiles)   #! Table Count EncryptionVersion
#DECLARE(%NFilesOptionEncrypt     ,%NFiles)   #! Table Option EncryptionVersion (Not used)
#!
#INSERT(%VarOptFile)                                                            #! RA.2019.07.28: Options: File
#!
#DECLARE(%TheTable)                           #! Reserved word change
#DECLARE(%TheTable2)                          #! Reserved word change (related tables) - RA.2018.06.03.SUN: Added
#!---------------------------------------------------------------------
#GROUP(%DefineFieldOptions)
#DECLARE(%CountNFields)
#DECLARE(%NFields),MULTI                      #!,UNIQUE
#DECLARE(%NFieldsCount            ,%NFields)  #! ID: Field Count
#DECLARE(%NFieldsKey              ,%NFields)  #! Clarion: Prefix:FieldName
#DECLARE(%NFieldsName             ,%NFields)  #! Clarion: Field Name
#DECLARE(%NFieldsType             ,%NFields)  #! Clarion: Field Type
#DECLARE(%NFieldsFormat           ,%NFields)  #! Clarion: Display Format
#DECLARE(%NFieldsDatLen           ,%NFields)  #! Clarion: Data Length             - RA.2018.04.15: Added
#DECLARE(%NFieldsDatDec           ,%NFields)  #! Clarion: Data Decimals           - RA.2018.04.15: Added
#DECLARE(%NFieldsDspLen           ,%NFields)  #! Clarion: Display Length          - RA.2018.04.15: Added
#DECLARE(%NFieldsDspDec           ,%NFields)  #! Clarion: Display Decimals        - RA.2018.04.15: Added
#DECLARE(%NFieldsOpts             ,%NFields)  #! Clarion: %FieldUserOptions       - RA.2019.04.30: Added
#DECLARE(%NFieldsNSql             ,%NFields)  #! SQL: Name
#DECLARE(%NFieldsTSql             ,%NFields)  #! SQL: Type
#DECLARE(%NFieldsDef              ,%NFields)  #! SQL: Default
#DECLARE(%NFieldsAuto             ,%NFields)  #! SQL: AUTO_INCREMENT
#DECLARE(%NFieldsNN               ,%NFields)  #! SQL: NOT NULL
#!
#DECLARE(%CountAFields)
#DECLARE(%AFields),MULTI                      #!,UNIQUE
#DECLARE(%AFieldsCount            ,%AFields)  #! ID: Field Count
#DECLARE(%AFieldsKey              ,%AFields)  #! Clarion: Prefix:FieldName
#DECLARE(%AFieldsName             ,%AFields)  #! Clarion: Field Name
#DECLARE(%AFieldsType             ,%AFields)  #! Clarion: Field Type
#DECLARE(%AFieldsFormat           ,%AFields)  #! Clarion: Display Format
#DECLARE(%AFieldsDatLen           ,%AFields)  #! Clarion: Data Length             - RA.2018.04.15: Added
#DECLARE(%AFieldsDatDec           ,%AFields)  #! Clarion: Data Decimals           - RA.2018.04.15: Added
#DECLARE(%AFieldsDspLen           ,%AFields)  #! Clarion: Display Length          - RA.2018.04.15: Added
#DECLARE(%AFieldsDspDec           ,%AFields)  #! Clarion: Display Decimals        - RA.2018.04.15: Added
#DECLARE(%AFieldsOpts             ,%AFields)  #! Clarion: %FieldUserOptions       - RA.2019.04.30: Added
#DECLARE(%AFieldsNSql             ,%AFields)  #! SQL: Name
#DECLARE(%AFieldsTSql             ,%AFields)  #! SQL: Type
#DECLARE(%AFieldsDef              ,%AFields)  #! SQL: Default
#DECLARE(%AFieldsAuto             ,%AFields)  #! SQL: AUTO_INCREMENT
#DECLARE(%AFieldsNN               ,%AFields)  #! SQL: NOT NULL
#!
#DECLARE(%NFieldsNOTNULL),MULTI,UNIQUE        #! Fields: KEY, INDEX
#DECLARE(%IFieldInKey)
#!
#! RA.2018.04.23: Track the auto increment fields for specific backends.
#DECLARE(%NFieldsAUTOINC),MULTI,UNIQUE        #! Fields: Auto-Increment
#DECLARE(%IFieldAutoInc)
#!
#! RA.2018.04.23: Track the primary keys to NOT-NULL them at create
#DECLARE(%NFieldsPRIMARY),MULTI,UNIQUE        #! Fields: Primary
#DECLARE(%IFieldPrimary)
#!
#INSERT(%VarOptField)                                                           #! RA.2019.07.28: Options: Field
#!
#DECLARE(%TheField)                           #! Reserved word change
#DECLARE(%CStringLen)                         #! Length of types shortened by one
#DECLARE(%LastField)                          #! Last field processed
#DECLARE(%InnerGroup)                         #! Inner group level processed
#DECLARE(%FieldComma)                         #! Number of fields - 1
#!
#DECLARE(%TestLenDec)
#DECLARE(%MoreLenDec)
#!
#DECLARE(%NFieldPKey)                         #! Field is Primary Key?
#DECLARE(%NFieldName)                         #! Field Name
#DECLARE(%NFieldType)                         #! Field Type
#DECLARE(%NFieldNSql)                         #! Field SQL Name
#DECLARE(%NFieldTSql)                         #! Field SQL Type
#DECLARE(%NFieldAuto)                         #! Field AUTO_INCREMENT
#DECLARE(%NFieldNN)                           #! Field NOT NULL
#DECLARE(%NFieldDef)                          #! Field default
#DECLARE(%NFieldLineCount)                    #! Count DDL line fields
#DECLARE(%NFieldLine)                         #! Output DDL line
#DECLARE(%NFieldLine1)                        #! Line piece
#DECLARE(%NFieldSize      ,LONG)              #! Field decimal size
#DECLARE(%NFieldDec       ,LONG)              #! Field decimal places
#DECLARE(%NLeadZero       ,LONG)              #! Have a leading zero
#DECLARE(%NFNameAuto)                         #! Field Name Auto Increment
#!
#DECLARE (%DimCount       ,LONG)              #! Number of dimensions
#DECLARE (%FldArray       ,STRING)            #! Created field name from array
#DECLARE (%FD1S           ,STRING)            #! Number for dimension 1
#DECLARE (%FD2S           ,STRING)            #! Number for dimension 2
#DECLARE (%FD3S           ,STRING)            #! Number for dimension 3
#DECLARE (%FD4S           ,STRING)            #! Number for dimension 4
#DECLARE (%FD1I           ,LONG)              #! Looping in Dimension 1
#DECLARE (%FD2I           ,LONG)              #! Looping in Dimension 2
#DECLARE (%FD3I           ,LONG)              #! Looping in Dimension 3
#DECLARE (%FD4I           ,LONG)              #! Looping in Dimension 4
#DECLARE (%FD1L           ,LONG)              #! Set to %FieldDimension1
#DECLARE (%FD2L           ,LONG)              #! Set to %FieldDimension2
#DECLARE (%FD3L           ,LONG)              #! Set to %FieldDimension3
#DECLARE (%FD4L           ,LONG)              #! Set to %fieldDimension4
#!---------------------------------------------------------------------
#GROUP(%DefineKeyOptions)
#DECLARE(%CountNKeys)
#DECLARE(%NKeys),MULTI                        #!,UNIQUE
#DECLARE(%NKeysCount              ,%NKeys)    #! ID: Key Count
#DECLARE(%NKeysKey                ,%NKeys)    #! Prefix:KeyName
#DECLARE(%NKeysName               ,%NKeys)    #! Key Name
#DECLARE(%NKeysType               ,%NKeys)    #! Key Type
#DECLARE(%NKeysFlagPri            ,%NKeys)    #! Key is: Primary
#DECLARE(%NKeysFlagSeq            ,%NKeys)    #! Key is: Sequence
#DECLARE(%NKeysFlagUni            ,%NKeys)    #! Key is: Unique
#DECLARE(%NkeysAutoField          ,%NKeys)    #! Auto-Inc Field Name
#DECLARE(%NKeysFieldCount         ,%NKeys)    #! Number of Fields
#DECLARE(%NKeysField01            ,%NKeys)    #! Field 01
#DECLARE(%NKeysField02            ,%NKeys)    #! Field 02
#DECLARE(%NKeysField03            ,%NKeys)    #! Field 03
#DECLARE(%NKeysField04            ,%NKeys)    #! Field 04
#DECLARE(%NKeysField05            ,%NKeys)    #! Field 05
#DECLARE(%NKeysField06            ,%NKeys)    #! Field 06
#DECLARE(%NKeysField07            ,%NKeys)    #! Field 07
#DECLARE(%NKeysField08            ,%NKeys)    #! Field 08
#DECLARE(%NKeysField09            ,%NKeys)    #! Field 09
#DECLARE(%NKeysSort01             ,%NKeys)    #! Sort Order 01
#DECLARE(%NKeysSort02             ,%NKeys)    #! Sort Order 02
#DECLARE(%NKeysSort03             ,%NKeys)    #! Sort Order 03
#DECLARE(%NKeysSort04             ,%NKeys)    #! Sort Order 04
#DECLARE(%NKeysSort05             ,%NKeys)    #! Sort Order 05
#DECLARE(%NKeysSort06             ,%NKeys)    #! Sort Order 06
#DECLARE(%NKeysSort07             ,%NKeys)    #! Sort Order 07
#DECLARE(%NKeysSort08             ,%NKeys)    #! Sort Order 08
#DECLARE(%NKeysSort09             ,%NKeys)    #! Sort Order 09
#!
#INSERT(%VarOptKey)                                                             #! RA.2019.07.28: Options: Key
#!
#DECLARE(%TheKey)                             #! Reserved word change
#DECLARE(%NKeyCount)                          #! File key counts
#DECLARE(%NKeyPrimary)                        #! File primary key counts
#DECLARE(%NKeyPrimaryValidSeq)                #! Valid sequence is a number
#DECLARE(%NKeyFieldIndex)                     #! Set field array into table
#DECLARE(%NKeyDidIndex)                       #! Have created an Index
#DECLARE(%NKeyComma)                          #! How many commas do I need?
#DECLARE(%NKeyFieldAD)                        #! Key Field A/D line
#DECLARE(%NKeyFieldID)                        #! Key Field ID Name
#DECLARE(%NKeySortOrder)                      #! Key Field ASC/DESC sort order
#!---------------------------------------------------------------------
#GROUP(%DefineRelationOptions)
#DECLARE(%CountNRelations)
#DECLARE(%NRelas),MULTI                       #!,UNIQUE
#DECLARE(%NRelasCount             ,%NRelas)   #! ID: Relation Count
#DECLARE(%NRelasFileFromKey       ,%NRelas)   #! File From: Prefix:Name
#DECLARE(%NRelasFileLinkKey       ,%NRelas)   #! File Link: Prefix:Name
#DECLARE(%NRelasKeyFromKey        ,%NRelas)   #!  Key From: Prefix:Name
#DECLARE(%NRelasKeyLinkKey        ,%NRelas)   #!  Key Link: Prefix:Name
#DECLARE(%NRelasType              ,%NRelas)   #! Relation Type
#DECLARE(%NRelasFileFrom          ,%NRelas)   #! Relation File: Main from
#DECLARE(%NRelasFileLink          ,%NRelas)   #! Relation File: Relate to
#DECLARE(%NRelasKeyFrom           ,%NRelas)   #! Relation Key: Main from
#DECLARE(%NRelasKeyLink           ,%NRelas)   #! Relation Key: Relate to
#DECLARE(%NRelasOnUpdate          ,%NRelas)   #! ON UPDATE: What to do?
#DECLARE(%NRelasOnDelete          ,%NRelas)   #! ON DELETE: What to do?
#DECLARE(%NRelasKeyFromCount      ,%NRelas)   #! Key From: Field Count
#DECLARE(%NRelasKFfield01         ,%NRelas)   #! Key From: Field 01
#DECLARE(%NRelasKFfield02         ,%NRelas)   #! Key From: Field 02
#DECLARE(%NRelasKFfield03         ,%NRelas)   #! Key From: Field 03
#DECLARE(%NRelasKFfield04         ,%NRelas)   #! Key From: Field 04
#DECLARE(%NRelasKFfield05         ,%NRelas)   #! Key From: Field 05
#DECLARE(%NRelasKFfield06         ,%NRelas)   #! Key From: Field 06
#DECLARE(%NRelasKFfield07         ,%NRelas)   #! Key From: Field 07
#DECLARE(%NRelasKFfield08         ,%NRelas)   #! Key From: Field 08
#DECLARE(%NRelasKFfield09         ,%NRelas)   #! Key From: Field 09
#DECLARE(%NRelasKFlabel01         ,%NRelas)   #! Key From: Label 01
#DECLARE(%NRelasKFlabel02         ,%NRelas)   #! Key From: Label 02
#DECLARE(%NRelasKFlabel03         ,%NRelas)   #! Key From: Label 03
#DECLARE(%NRelasKFlabel04         ,%NRelas)   #! Key From: Label 04
#DECLARE(%NRelasKFlabel05         ,%NRelas)   #! Key From: Label 05
#DECLARE(%NRelasKFlabel06         ,%NRelas)   #! Key From: Label 06
#DECLARE(%NRelasKFlabel07         ,%NRelas)   #! Key From: Label 07
#DECLARE(%NRelasKFlabel08         ,%NRelas)   #! Key From: Label 08
#DECLARE(%NRelasKFlabel09         ,%NRelas)   #! Key From: Label 09
#DECLARE(%NRelasKeyLinkCount      ,%NRelas)   #! Key Link: Field Count
#DECLARE(%NRelasKLfield01         ,%NRelas)   #! Key Link: Field 01
#DECLARE(%NRelasKLfield02         ,%NRelas)   #! Key Link: Field 02
#DECLARE(%NRelasKLfield03         ,%NRelas)   #! Key Link: Field 03
#DECLARE(%NRelasKLfield04         ,%NRelas)   #! Key Link: Field 04
#DECLARE(%NRelasKLfield05         ,%NRelas)   #! Key Link: Field 05
#DECLARE(%NRelasKLfield06         ,%NRelas)   #! Key Link: Field 06
#DECLARE(%NRelasKLfield07         ,%NRelas)   #! Key Link: Field 07
#DECLARE(%NRelasKLfield08         ,%NRelas)   #! Key Link: Field 08
#DECLARE(%NRelasKLfield09         ,%NRelas)   #! Key Link: Field 09
#DECLARE(%NRelasKLlabel01         ,%NRelas)   #! Key Link: Label 01
#DECLARE(%NRelasKLlabel02         ,%NRelas)   #! Key Link: Label 02
#DECLARE(%NRelasKLlabel03         ,%NRelas)   #! Key Link: Label 03
#DECLARE(%NRelasKLlabel04         ,%NRelas)   #! Key Link: Label 04
#DECLARE(%NRelasKLlabel05         ,%NRelas)   #! Key Link: Label 05
#DECLARE(%NRelasKLlabel06         ,%NRelas)   #! Key Link: Label 06
#DECLARE(%NRelasKLlabel07         ,%NRelas)   #! Key Link: Label 07
#DECLARE(%NRelasKLlabel08         ,%NRelas)   #! Key Link: Label 08
#DECLARE(%NRelasKLlabel09         ,%NRelas)   #! Key Link: Label 09
#!
#INSERT(%VarOptRelation)                                                        #! RA.2019.07.28: Options: Relation
#!
#DECLARE(%TheRelation)                        #! Reserved word change
#DECLARE(%NRelaFound)                         #! Found a relation to process
#DECLARE(%NRelaFieldIndex)                    #! Set field array into table
#DECLARE(%NRelaDidRelation)                   #! Have created an Index
#DECLARE(%NRelaFieldsParent)                  #! Relation field list for Parent table
#DECLARE(%NRelaFieldsChild)                   #! Relation field list for Child table
#DECLARE(%NRelaRestrict)                      #! Change RESTRICT_SERVER to RESTRICT
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.05 - Show the files to make sure the get presented correctly
#GROUP(%ShowFiles)
#FREE(%NFiles)
#FOR(%File)
  #!----------------------------------!
  #! Ignore certain file DRIVER types !
  #!----------------------------------!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('MEMORY')                                                               #! RA.2018.04.12 - Ignored
---- IGNORED: "%File" [DRIVER type %FileDriver]
      #CYCLE
  #ENDCASE
  #!---------------------------!
  #! Ignore certain FILE types !
  #!---------------------------!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
---- IGNORED: "%File" [FILE type %FileType]
      #CYCLE
  #ENDCASE
  #!-------------------------------------!
  #! Ignore FILES with NO FIELDS in them !
  #!-------------------------------------!
  #IF(NOT ITEMS(%Field))                                                        #! RA.2001.12.01
---- IGNORED: "%File" [No fields found]
    #CYCLE                                                                      #! RA.2001.12.01
  #ENDIF                                                                        #! RA.2001.12.01
  #!-----------------------!
  #! Check the OPTIONS now !
  #!-----------------------!
  #INSERT(%GetFileOptions)
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')                                                  #! Ignore this file
---- IGNORED: "%File" [FILE options say NO]
    #CYCLE
  #ENDIF
  #!---------------------------!
  #! We pass FILE requirements !
  #!---------------------------!
  #!#ADD(%NFiles,%File)                                                         #! This FILE is processed
  #! RA.2017.12.05 - Changes to track and output CSV files
  #ADD(%NFiles,ITEMS(%NFiles) + 1)                                              #! This FILE is processed
  #SET(%NFilesCount  , ITEMS(%NFiles))                                          #! Table ID number
  #SET(%NFilesName   , %File)                                                   #! Table Name
  #SET(%NFilesSeqName, %NFilesName & '_seq')                                    #! Table Sequence Name - RA.2017.12.21
#!
  #CALL(%HasOnePrimaryKey)                                                      #! At least ONE primary key
#!
#ENDFOR
#!
#IF(%TRUE)
  #FOR(%NFiles)
    #FIX(%File, %NFilesName)
---- PROCESSING: %[3]NFilesCount %[90]NFilesName [%FilePrefix]
  #ENDFOR
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! BUILD QUALIFIED FILES
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2019.08.04: We need to filter these before presenting for selections.     [This is done in D2M2_003.TPW]
#! FOR NOW: We are going copy the filter code and take other code out later.    [In the #GROUP(%VariablesSetup)]
#! After you start adding aliases and vendor tools/utilities it gets messy.
#! FILTER CODE IS A CANDIDATE FOR IT'S OWN GROUP: CHECK FOR REFACTOR OPTIONS!
#! RA.2019.07.04: Added option to select files to do SQL generation.
#! RA.2017.12.17: This builds a table of QUALIFIED files that can be used
#! by all the different GROUPS that generate DDL scripts or CSV files.
#GROUP(%BuildQualifiedFiles)
#FREE(%NFilesSort)                                                            #! Name order for files
#!
#!#FOR(%File)                                                                   #! Read all the files
#!  #ADD(%NFilesSort,%File)                                                     #! Name sort them by
#!#ENDFOR                                                                       #! processing them all
#!
#! RA.2019.07.04: Added option to select files to do SQL generation.
#!
#IF (%optUseAllFiles)
  #FOR (%File)
    #ADD (%NFilesSort, %File)
  #ENDFOR
#ELSE
  #FOR (%optFileSelection)
    #ADD (%NFilesSort, %optFileSelection)
  #ENDFOR
#ENDIF
#!
#FREE(%NFiles)                                                                  #! Valid file items here
#FOR(%NFilesSort)                                                               #! VALID FILE: FOR
  #FIX(%File,%NFilesSort)
  #!----------------------------------!
  #! Ignore certain file DRIVER types !
  #!----------------------------------!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('MEMORY')                                                              #! RA.2018.04.12 - Ignored
    #IF(%TraceDetail)
---- IGNORED: "%File" [DRIVER type %FileDriver]
    #ENDIF
    #CYCLE
  #ENDCASE
  #!---------------------------!
  #! Ignore certain FILE types !
  #!---------------------------!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
    #IF(%TraceDetail)
---- IGNORED: "%File" [FILE type %FileType]
    #ENDIF
    #CYCLE
  #ENDCASE
  #!-------------------------------------!
  #! Ignore FILES with NO FIELDS in them !
  #!-------------------------------------!
  #IF(NOT ITEMS(%Field))                                                        #! RA.2001.12.01
    #IF(%TraceDetail)
---- IGNORED: "%File" [No fields]
    #ENDIF
    #CYCLE                                                                      #! RA.2001.12.01
  #ENDIF                                                                        #! RA.2001.12.01
  #!-----------------------!
  #! Check the OPTIONS now !
  #!-----------------------!
  #INSERT(%GetFileOptions)
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')                                                  #! Ignore this file
    #IF(%TraceDetail)
---- IGNORED: "%File" [FILE options say NO]
    #ENDIF
    #CYCLE
  #ENDIF
  #!---------------------------!
  #! We pass FILE requirements !
  #!---------------------------!
  #!#ADD(%NFiles,%File)                                                         #! This FILE is processed
  #! RA.2017.12.05 - Changes to track and output CSV files
  #ADD(%NFiles,ITEMS(%NFiles) + 1)                                              #! This FILE is processed
  #SET(%NFilesCount       ,ITEMS(%NFiles))                                      #! Table ID number
  #SET(%NFilesName        ,%File)                                               #! Table Name
  #SET(%NFilesSeqName     ,%NFilesName & '_seq')                                #! Table Sequence Name - RA.2017.12.21
  #SET(%NFilesFullPath    ,%FileName)                                           #! Table Full Path Name - RA.2018.04.12
  #CALL(%ReplaceSubString ,%NFilesFullPath ,'''','')
#!
  #CALL(%HasOnePrimaryKey)                                                      #! At least ONE primary key
#!
#! RA.2019.07.06: Additional GUID items to track per file
#SET(%NFilesKeyCount      ,%NKeyCount)                                          #! RA.2019.07.06: Table Count Keys
#SET(%NFilesKeyPrimary    ,%NKeyPrimary)                                        #! RA.2019.07.06: Table Count Primary Keys
#SET(%NFilesFieldCount    ,ITEMS(%Field))                                       #! RA.2019.07.06: Table Count Fields
#SET(%NFilesCountGUID     ,0)                                                   #! RA.2019.07.06: Table Count GUID
#SET(%NFilesCountTS       ,0)                                                   #! RA.2019.07.06: Table Count TS
#SET(%NFilesCountSTS      ,0)                                                   #! RA.2019.07.06: Table Count STS
#SET(%NFilesCountDTS      ,0)                                                   #! RA.2019.07.06: Table Count DTS
#SET(%NFilesOptionGUID    ,0)                                                   #! RA.2019.07.25: Table Option GUID
#SET(%NFilesOptionTS      ,0)                                                   #! RA.2019.07.06: Table Option TS
#SET(%NFilesOptionSTS     ,0)                                                   #! RA.2019.07.06: Table Option STS
#SET(%NFilesOptionDTS     ,0)                                                   #! RA.2019.07.06: Table Option DTS
#SET(%NFilesKeyGUID       ,0)                                                   #! RA.2019.07.26: Key for GUID
#SET(%NFilesKeyTS         ,0)                                                   #! RA.2019.07.26: Key for TS
#SET(%NFilesKeySTS        ,0)                                                   #! RA.2019.07.26: Key for STS
#SET(%NFilesKeyDTS        ,0)                                                   #! RA.2019.07.26: Key for DTS
#SET(%NFilesFieldGUID     ,0)                                                   #! RA.2019.07.26: Key-Field for GUID
#SET(%NFilesFieldTS       ,0)                                                   #! RA.2019.07.26: Key-Field for TS
#SET(%NFilesFieldSTS      ,0)                                                   #! RA.2019.07.26: Key-Field for STS
#SET(%NFilesFieldDTS      ,0)                                                   #! RA.2019.07.26: Key-Field for DTS
#SET(%NFilesCountEncrypt  ,0)                                                   #! RA.2019.11.20: Table Count EncryptionVersion
#SET(%NFilesOptionEncrypt ,0)                                                   #! RA.2019.11.20: Table Option EncryptionVersion (Not used)
#!
#ENDFOR                                                                         #! VALID FILE: #ENDFOR
#IF(%TraceDetail)
---- BuildQualifiedFiles ----
---- Processed Files ---- BEGIN
  #FOR(%NFiles)
    #FIX(%File, %NFilesName)
---- PROCESSED: %[3]NFilesCount %[90]NFilesName [%FilePrefix] "%NFilesFullPath"
  #ENDFOR
---- Processed Files ---- END

#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.23: Build the auto-increment field list at the same time.
#! Needed for the backends that you have to modify the field attributes.                                
#!---------------------------------------------------------------------
#! RA.2017.12.17: Sanity check. If you have fields that are being used in a key add them to the NOT NULL 
#! table even if the options are not set. Having keys with components that are NULL might cause backend grief.
#! The better choice is to have keys completely populated without nulls.
#!---------------------------------------------------------------------
#! RA.2018.11.09: No AUTO-INCREMENT flag found (And you need to generate a ROW level AUTO-INCREMENT)
#! Mr. Michael Gorman removed all the auto-increment flags from his primary keys (SURPRISE!).
#! He is having the BACKEND generate the auto-increment so the DCT does not have it any
#! That caused the ROW level auto-increment generation to fail for MSSQL (and SQLANYWHERE) since that
#! generation is based out of the AUTO-INCREMENT field that is filled when you set the auto-increment flag.
#! Figured out a way to build the items in the correct tables since there are rules for auto-incrementing.
#! Tested by generating the IDENTITY (1, 1) in the create table for MSSQL.
#! Verified that MIMER sequence was being generated correctly.
#!---------------------------------------------------------------------
#! BIG NOTE: Since the %KeyAuto is BLANK if the auto-increment flag is turned off, the %NFieldsAUTOINC
#! table should be empty and you can use the %TraceDetail flag to check that that table ---IS--- empty.
#! IF you have any entries in that table, THEN you need to correct the DCT so it does not do a primary that
#! will be auto-increment on the client side. This does not prevent you from using auto-increment fields,
#! you just cannot use them on the primary unique key. That is left for the server.
#!---------------------------------------------------------------------
#GROUP(%BuildFieldsNOTNULL)                                                     #! Fields in KEY, INDEX
#FREE(%NFieldsNOTNULL)
#FREE(%NFieldsAUTOINC)                                                          #! RA.2018.04.23: Added
#FOR(%NFiles)
  #!FIX(%File,%NFiles)
  #FIX(%File,%NFilesName)
  #IF(ITEMS(%Key) > 0)
    #FOR(%Key)
      #IF(%KeyAuto)                                                             #! RA.2018.04.23: Added
        #ADD(%NFieldsAUTOINC, %KeyAuto)                                         #! RA.2018.04.23: Added
      #ENDIF                                                                    #! RA.2018.04.23: Added
      #FOR(%KeyField)
        #ADD(%NFieldsNOTNULL, %KeyField)                                        #! These are NOT NULL
      #ENDFOR
    #ENDFOR
  #ENDIF
#ENDFOR
#!
#IF(%TraceDetail)
---- Fields that are parts of keys and NOT-NULL ---- BEGIN
  #FOR(%NFieldsNOTNULL)
---- NN: %NFieldsNOTNULL
  #ENDFOR
---- Fields that are parts of keys and NOT-NULL ---- END

---- Fields AUTO-INCREMENTED ---- BEGIN
  #FOR(%NFieldsAUTOINC)
---- AI: %NFieldsAUTOINC
  #ENDFOR
---- Fields AUTO-INCREMENTED ---- END

#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#! RA.2017.12.19 - Tested
#GROUP(%ProcessTableCreate,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessTableCreate,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#!---------------------------------------------------------------------
#! RA.2018.04.23: See what has being built
#!---------------------------------------------------------------------
#IF(%TraceDetail)
---- BuildQualifiedFiles ----
---- Processed Files ---- BEGIN
  #FOR(%NFiles)
    #FIX(%File, %NFilesName)
---- FILE: %[3]NFilesCount %[94]NFilesName [%[16]FilePrefix] "%NFilesFullPath"
  #ENDFOR
---- Processed Files ---- END

---- Fields that are parts of keys and NOT-NULL ---- BEGIN
  #FOR(%NFieldsNOTNULL)
---- NN: %NFieldsNOTNULL
  #ENDFOR
---- Fields that are parts of keys and NOT-NULL ---- END

---- Fields AUTO-INCREMENTED ---- BEGIN
  #FOR(%NFieldsAUTOINC)
---- AI: %NFieldsAUTOINC
  #ENDFOR
---- Fields AUTO-INCREMENTED ---- END

---- Fields PRIMARY KEY FIELD ---- BEGIN
  #FOR(%NFieldsPRIMARY)
---- PK: %NFieldsPRIMARY
  #ENDFOR
---- Fields PRIMARY KEY FIELD ---- END

#ENDIF
#!---------------------------------------------------------------------
#! RA.2018.04.23: See what has being built
#!---------------------------------------------------------------------
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #IF(%FALSE)
---- NFiles=%NFiles: NFilesCount=%NFilesCount: NFilesName=%NFilesName
  #ENDIF
#!-- #IF((%NFilesName = 'ACTIVITY') OR (%NFilesName = 'ADJUST') OR (%NFilesName = 'CHART'))
#!
  #! RA.2018.04.23: Need to get the any auto-incremented field name so you can set up specific backends.
  #CALL(%HasOnePrimaryKey)                                                      #! At least ONE primary key
  #CALL(%MetabaseSqlField,%pBaseName)
#!
#!-- #ENDIF
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#! RA.2017.12.19 - Tested
#GROUP(%ProcessTableDropIt,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessTableDropIt,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #! RA.2018.04.19: Is it a valid backend?
  #CASE(%pBaseName)                                                             #! BACKEND EXCEPTIONS
  #OF  ('METABASE')
  #OROF('MIMER')
  #OROF('MSSQL')
  #OROF('POSTGRESQL')
  #OROF('SQLANYWHERE')
  #OROF('ORACLE')
  #OROF('DB2')
  #OROF('MYSQL')
    #! RA.2018.04.19: Droping the table
    #CASE(%pBaseName)                                                           #! BACKEND EXCEPTIONS
    #OF  ('METABASE')
    #OROF('MIMER')
DROP TABLE %TheTable CASCADE
    #OF  ('MSSQL')
    #OROF('POSTGRESQL')
    #OROF('SQLANYWHERE')
    #OROF('ORACLE')
    #OROF('DB2')
    #OROF('MYSQL')
DROP TABLE %TheTable
    #ENDCASE                                                                    #! BACKEND EXCEPTIONS
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
  #ELSE
-- [GENERATE TABLE DROP]
  #ENDCASE                                                                      #! BACKEND EXCEPTIONS
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.25 - Re-arrange SEQUENCE logic and where it happens
#! RA.2018.04.07 - Pass %BaseName as a parameter
#! RA.2017.12.21 - Tested
#GROUP(%ProcessSequenceCreate,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessSequenceCreate,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #CALL(%HasOnePrimaryKey)
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #IF(%NKeyPrimaryValidSeq)
    #! RA.2018.04.19: Is it a valid backend
    #CASE(%pBaseName)                                                           #! BACKEND EXCEPTIONS
    #OF  ('METABASE')
    #OROF('MIMER')
    #OROF('MSSQL')
    #OROF('POSTGRESQL')
    #OROF('SQLANYWHERE')
    #OROF('MYSQL')
    #OROF('ORACLE')
    #OROF('DB2')
      #! RA.2018.04.19: Create the AUTO-NUMBERING object
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
CREATE SEQUENCE %NFilesSeqName INITIAL_VALUE = 1
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
      #OF  ('MSSQL')
      #OROF('SQLANYWHERE')
        #IF(%TraceDetail)
---- IGNORE: [GENERATE SEQUENCE CREATE]
        #ENDIF
      #OF  ('POSTGRESQL')
CREATE SEQUENCE %NFilesSeqName START WITH 1
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.06.07.THU: Added
      #OF  ('MYSQL')
      #OF  ('ORACLE')
      #OF  ('DB2') 
      #ELSE
------ NO SEQUENCE CREATE GENERATION [INNER LOOP 1]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
#!
      #! RA.2018.04.19: Alter the TABLE and attach the AUTO-NUMBERING object
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
ALTER TABLE %TheTable
      ALTER %NFilesSeqField SET DEFAULT NEXT_VALUE OF %NFilesSeqName
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
      #!
      #OF  ('MSSQL')
      #OROF('SQLANYWHERE')
      #!
      #OF  ('POSTGRESQL')
ALTER TABLE %TheTable
      ALTER COLUMN %NFilesSeqField SET DEFAULT NEXTVAL('%NFilesSeqName')
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.06.07.THU: Added
      #OF  ('MYSQL')
      #OF  ('ORACLE')
      #OF  ('DB2')
      #ELSE
------ NO SEQUENCE CREATE GENERATION [INNER LOOP 2]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ELSE
-- [GENERATE SEQUENCE CREATE]
    #ENDCASE                                                                    #! BACKEND EXCEPTIONS
  #ELSE
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO SEQUENCE CREATE GENERATION
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.25 - Re-arrange SEQUENCE logic and where it happens
#! RA.2018.04.07 - Pass %BaseName as a parameter
#! RA.2017.12.21 - Tested
#GROUP(%ProcessSequenceDropIt,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessSequenceDropIt,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #CALL(%HasOnePrimaryKey)
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #IF(%NKeyPrimaryValidSeq)
    #! RA.2018.04.19: Is it a VALID backend?
    #CASE(%pBaseName)                                                           #! BACKEND EXCEPTIONS
    #OF  ('METABASE')
    #OROF('MIMER')
    #OROF('MSSQL')
    #OROF('POSTGRESQL')
    #OROF('SQLANYWHERE')
    #OROF('MYSQL')
    #OROF('ORACLE')
    #OROF('DB2')
      #! RA.2018.04.19: Drop the SEQUENCE object
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
      #OROF('POSTGRESQL')
      #OROF('MYSQL')
      #OROF('ORACLE')
      #OROF('DB2')
DROP SEQUENCE %NFilesSeqName CASCADE
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
      #OF  ('MSSQL')
      #OROF('SQLANYWHERE')
        #IF(%TraceDetail)
---- IGNORE: [GENERATE SEQUENCE DROP] 
        #ENDIF
      #ELSE
-- NO SEQUENCE DROP GENERATION
      #ENDCASE
    #ELSE
-- [GENERATE SEQUENCE DROP]
    #ENDCASE                                                                    #! BACKEND EXCEPTIONS
  #ELSE
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO SEQUENCE DROP GENERATION
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#! RA.2017.12.23 - Tested
#GROUP(%ProcessPrimaryCreate,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessPrimaryCreate,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #CALL(%HasOnePrimaryKey)
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #IF(%NFilesPKeyName)
    #! RA.2018.04.19: Is it a valid backend?
    #CASE(%pBaseName)                                                           #! BACKEND EXCEPTIONS
    #OF  ('METABASE')
    #OROF('MIMER')
    #OROF('MSSQL')
    #OROF('POSTGRESQL')
    #OROF('SQLANYWHERE')
    #OROF('MYSQL')
    #OROF('ORACLE')
    #OROF('DB2')
ALTER TABLE %TheTable
      ADD CONSTRAINT %NFilesPKeyName PRIMARY KEY (%NFilesPKeyField)
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
    #ELSE
-- [GENERATE PRIMARY CREATE]
    #ENDCASE                                                                    #! BACKEND EXCEPTIONS
  #ELSE
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO PRIMARY KEY CREATE GENERATION
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#! RA.2017.12.23 - Tested
#GROUP(%ProcessPrimaryDropIt,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessPrimaryDropIt,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #CALL(%HasOnePrimaryKey)
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #IF(%NFilesPKeyName)
    #! RA.2018.04.19: Is is a valid backend?
    #CASE(%pBaseName)                                                           #! BACKEND EXCEPTIONS
    #OF  ('METABASE')
    #OROF('MIMER')
    #OROF('MSSQL')
    #OROF('POSTGRESQL')
    #OROF('SQLANYWHERE')
    #OROF('MYSQL')
    #OROF('ORACLE')
    #OROF('DB2')
ALTER TABLE %TheTable   
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
      DROP CONSTRAINT %NFilesPKeyName CASCADE
      #OF  ('MSSQL')
      #OROF('POSTGRESQL')
      #OROF('SQLANYWHERE')
      #OROF('ORACLE')
      #OROF('DB2')
      DROP CONSTRAINT %NFilesPKeyName
      #OF('MYSQL')                                                              #! RA.2018.09.03: Different syntax
        #!ALTER TABLE tbl_name
        #!  | DROP [COLUMN] col_name
        #!  | DROP {INDEX|KEY} index_name
        #!  | DROP PRIMARY KEY
        #!  | DROP FOREIGN KEY fk_symbol
      DROP PRIMARY KEY 
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS      
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
    #ELSE
-- [GENERATE PRIMARY DROP]
    #ENDCASE                                                                    #! BACKEND EXCEPTIONS
  #ELSE
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO PRIMARY KEY DROP GENERATION
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.03.17.SAT - Clarion key words to SQL-DDL standard
#GROUP(%GiveMeSortOrder,*%pNKeySortOrder, %pKeyFieldSequence)
#IF(%pKeyFieldSequence='ASCENDING')
  #SET(%pNKeySortOrder, 'ASC')
#ELSE
  #SET(%pNKeySortOrder, 'DESC')
#END
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.06.03.SUN: Some backends do not take some Clarion options. (refactor)
#! RA.2018.03.17.SAT: Clarion key words to SQL-DDL standard
#! The backend DDL functionality will be found out as time permits.
#! Clarion Options are defined: RESTRICT, CASCADE, or CLEAR
#! Additional defines might be: RESTRICT_SERVER, CASCADE_SERVER, CLEAR_SERVER                            
#GROUP(%GiveMeRestrict,*%pNRelaRestrict, %pRelationConstraint, %pBaseName)
#SET(%pNRelaRestrict, %pRelationConstraint)
#!#IF(%pRelationConstraint='RESTRICT_SERVER')
#!  #SET(%pNRelaRestrict, 'RESTRICT')
#!#END
#CASE(%pRelationConstraint)
#OF('RESTRICT_SERVER')
  #SET(%pNRelaRestrict, 'RESTRICT')
#OF('CASCADE_SERVER')
  #SET(%pNRelaRestrict, 'CASCADE')
#OF('CLEAR_SERVER')
  #SET(%pNRelaRestrict, 'CLEAR')
#ENDCASE
#! RA.2018.06.03.SUN: Check the allowed ones
#CASE(%pBaseName)                                                               #! BACKEND EXCEPTIONS
#OF  ('METABASE')
#OROF('MIMER')
#OROF('POSTGRESQL')
#OROF('SQLANYWHERE')
#OF  ('MSSQL')
  #!  [ ON DELETE { NO ACTION | CASCADE | SET NULL | SET DEFAULT } ]   
  #!  [ ON UPDATE { NO ACTION | CASCADE | SET NULL | SET DEFAULT } ]   
  #!#IF(%pNRelaRestrict = 'RESTRICT')
  #!  #SET(%pNRelaRestrict, '')
  #!#ENDIF
  #CASE(%pNRelaRestrict)                                                        #! RA.2018.11.11: Correction
  #OF  ('RESTRICT')
  #OROF('CLEAR')
    #SET(%pNRelaRestrict, '')
  #ENDCASE
#ENDCASE                                                                        #! BACKEND EXCEPTIONS
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%ProcessIndexUniqueCreate,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessIndexUniqueCreate,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #CALL(%HasOnePrimaryKey)
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #SET(%NKeyDidIndex, %FALSE)
  #FOR(%NKeys)                                                                  #! Beginn FOR(%NKeys)
    #SET(%TheKey,%NKeysName)
    #CALL(%ReserveWordReplace,%TheKey)
    #FIX(%Key,%NKeysKey)
    #IF((%NKeysFlagPri='N') AND (%NKeysFlagUni='Y'))
      #SET(%NKeyDidIndex, %TRUE)
      #SET(%NKeyComma, ITEMS(%KeyField) - 1)                                    #! How many commas do I need?
      #! RA.2018.04.21: Is it a VALID backend?
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
      #OROF('MSSQL')
      #OROF('POSTGRESQL')
      #OROF('SQLANYWHERE')
      #OROF('MYSQL')
      #OROF('ORACLE')
      #OROF('DB2')
CREATE UNIQUE INDEX %TheKey
       ON %TheTable
        #SET(%NKeyFieldAD, '(')
        #FOR(%KeyField)
          #FIX(%Field,%KeyField)
          #SET(%NKeyFieldID,%FieldID)
          #CALL(%PadToLength,%NKeyFieldID,90)
          #CALL(%GiveMeSortOrder,%NKeySortOrder,%KeyFieldSequence)
          #!SET(%NKeyFieldAD, %NKeyFieldAD & %NKeyFieldID & ' ' & %KeyFieldSequence)
          #SET(%NKeyFieldAD, %NKeyFieldAD & %NKeyFieldID & ' ' & %NKeySortOrder)
          #IF(%NKeyComma > 0)
            #SET(%NKeyFieldAD, %NKeyFieldAD & ',')
      %NKeyFieldAD
            #SET(%NKeyFieldAD, ' ')
            #SET(%NKeyComma, %NKeyComma - 1)
         #ENDIF
        #ENDFOR
      #SET(%NKeyFieldAD, %NKeyFieldAD & ')')
      %NKeyFieldAD
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
      #ELSE
-- [GENERATE UNIQUE INDEX CREATE]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ELSE
    #ENDIF
  #ENDFOR                                                                       #! Ending FOR(%NKeys)
  #IF(~%NKeyDidIndex)
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO UNIQUE INDEX THAT IS NOT A PRIMARY KEY GENERATED [ONE DOES NOT EXIST]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%ProcessIndexUniqueDropIt,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessIndexUniqueDropIt,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #CALL(%HasOnePrimaryKey)
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                           #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #SET(%NKeyDidIndex, %FALSE)
  #FOR(%NKeys)                                                                  #! Beginn FOR(%NKeys)
    #SET(%TheKey,%NKeysName)
    #CALL(%ReserveWordReplace,%TheKey)
    #FIX(%Key,%NKeysKey)
    #IF((%NKeysFlagPri='N') AND (%NKeysFlagUni='Y'))
      #SET(%NKeyDidIndex, %TRUE)
      #! RA.2018.04.09: Is it a valid backend?
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
ALTER TABLE %TheTable
      DROP CONSTRAINT %TheKey CASCADE
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.06.07.THU: Refactor code
      #OF  ('POSTGRESQL')
      #OROF('SQLANYWHERE')
      #OROF('ORACLE')
      #OROF('DB2')
DROP INDEX %TheKey
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.06.07.THU: Refactor code
      #OF  ('MSSQL')
      #OROF('MYSQL')                                                            #! RA.2018.09.03: Changed
        #!ALTER TABLE tbl_name
        #!  | DROP [COLUMN] col_name
        #!  | DROP {INDEX|KEY} index_name
        #!  | DROP PRIMARY KEY
        #!  | DROP FOREIGN KEY fk_symbol
DROP INDEX %TheKey
     ON %TheTable
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.06.07.THU: Refactor code
      #ELSE
-- [GENERATE UNIQUE INDEX DROP]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ELSE
    #ENDIF
  #ENDFOR                                                                       #! Ending FOR(%NKeys)
  #IF(~%NKeyDidIndex)
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO UNIQUE INDEX THAT IS NOT A PRIMARY KEY GENERATED [ONE DOES NOT EXIST]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%ProcessIndexNonUniqueCreate,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessIndexNonUniqueCreate,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #CALL(%HasOnePrimaryKey)
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #SET(%NKeyDidIndex, %FALSE)
  #FOR(%NKeys)                                                                  #! Beginn FOR(%NKeys)
    #SET(%TheKey,%NKeysName)
    #CALL(%ReserveWordReplace,%TheKey)
    #FIX(%Key,%NKeysKey)
    #IF((%NKeysFlagPri='N') AND (%NKeysFlagUni='N'))
      #SET(%NKeyDidIndex, %TRUE)
      #SET(%NKeyComma, ITEMS(%KeyField) - 1)                                    #! How many commas do I need?
      #! RA.2018.04.21: Is it a VALID backend?
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
      #OROF('MSSQL')
      #OROF('POSTGRESQL')
      #OROF('SQLANYWHERE')
      #OROF('MYSQL')
      #OROF('ORACLE')
      #OROF('DB2')
CREATE INDEX %TheKey
       ON %TheTable
        #SET(%NKeyFieldAD, '(')
        #FOR(%KeyField)
          #FIX(%Field,%KeyField)
          #SET(%NKeyFieldID,%FieldID)
          #CALL(%SetupTheField,%NKeyFieldID,%pBaseName,%FieldID,%FieldName)     #! RA.2019.08.10: Handle EXTERNAL name
          #CALL(%PadToLength,%NKeyFieldID,90)
          #CALL(%GiveMeSortOrder,%NKeySortOrder,%KeyFieldSequence)
          #!SET(%NKeyFieldAD, %NKeyFieldAD & %NKeyFieldID & ' ' & %KeyFieldSequence)
          #SET(%NKeyFieldAD, %NKeyFieldAD & %NKeyFieldID & ' ' & %NKeySortOrder)
          #IF(%NKeyComma > 0)
            #SET(%NKeyFieldAD, %NKeyFieldAD & ',')
      %NKeyFieldAD
            #SET(%NKeyFieldAD, ' ')
            #SET(%NKeyComma, %NKeyComma - 1)
         #ENDIF
        #ENDFOR
      #SET(%NKeyFieldAD, %NKeyFieldAD & ')')
      %NKeyFieldAD
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
      #ELSE
-- [GENERATE UNIQUE INDEX CREATE]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ELSE
    #ENDIF
  #ENDFOR                                                                       #! Ending FOR(%NKeys)
  #IF(~%NKeyDidIndex)
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO NON-UNIQUE INDEX THAT IS NOT A PRIMARY KEY GENERATED [ONE DOES NOT EXIST]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%ProcessIndexNonUniqueDropIt,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessIndexNonUniqueDropIt,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #CALL(%HasOnePrimaryKey)
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #SET(%NKeyDidIndex, %FALSE)
  #FOR(%NKeys)                                                                  #! Beginn FOR(%NKeys)
    #SET(%TheKey,%NKeysName)
    #CALL(%ReserveWordReplace,%TheKey)
    #FIX(%Key,%NKeysKey)
    #IF((%NKeysFlagPri='N') AND (%NKeysFlagUni='N'))
      #SET(%NKeyDidIndex, %TRUE)
      #! RA.2018.04.09: Is it a valid backend?
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
ALTER TABLE %TheTable
      DROP CONSTRAINT %TheKey CASCADE
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.06.07.THU: Refactor code
      #OF  ('POSTGRESQL')
      #OROF('SQLANYWHERE')
      #OROF('ORACLE')
      #OROF('DB2')
DROP INDEX %TheKey
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.06.07.THU: Refactor code
      #OF  ('MSSQL')                                                            #! RA.2018.06.03: Change
      #OROF('MYSQL')                                                            #! RA.2081.09.03: Change
        #!ALTER TABLE tbl_name
        #!  | DROP [COLUMN] col_name
        #!  | DROP {INDEX|KEY} index_name
        #!  | DROP PRIMARY KEY
        #!  | DROP FOREIGN KEY fk_symbol
DROP INDEX %TheKey
     ON %TheTable
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.06.07.THU: Refactor code
      #ELSE
-- [GENERATE UNIQUE INDEX DROP]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ELSE
    #ENDIF
  #ENDFOR                                                                       #! Ending FOR(%NKeys)
  #IF(~%NKeyDidIndex)
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO NON-UNIQUE INDEX THAT IS NOT A PRIMARY KEY GENERATED [ONE DOES NOT EXIST]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%ProcessRelationCreate,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessRelationCreate,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #SET(%NRelaFound, %FALSE)
  #CALL(%BuildQualifiedRelations,%pBaseName)                                    #! RA.2018.06.03 - Added the backend type.
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #IF(%NRelaFound)
      #! RA.2018.04.19: Is this a VALID backend?
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
      #OROF('MSSQL')
      #OROF('POSTGRESQL')
      #OROF('SQLANYWHERE')
      #OROF('MYSQL')
        #! RA.2018.09.03: MySQL will create pure indexes (not constraints) for any foreign index it needs in a relation.
        #! So when you automagically delete the relation constrains those automagically created indexes do not get deleted.
        #! This has been tested (and discovered) in Mr. Michael Gorman's small database used for testing the templates.
      #OROF('ORACLE')
      #OROF('DB2')
        #FOR(%NRelas)
          #IF((%TraceDetail) AND (%NRelaFound=%TRUE))
----
---- %[3]NRelasCount, %NRelasFileFromKey, %NRelasType, %NRelasFileLinkKey
---- %[3]NRelasCount, %NRelasKeyFromKey, %NRelasType, %NRelasKeyLinkKey
---- %[3]NRelasCount, %NRelasKeyFromCount, %NRelasType, %NRelasKeyLinkCount
---- %[3]NRelasCount, FROM: %[90]NRelasFileFrom, %NRelasKeyFrom
---- %[3]NRelasCount, LINK: %[90]NRelasFileLink, %NRelasKeyLink
---- %[3]NRelasCount, UPDATE: %[8]NRelasOnUpdate, DELETE: %[8]NRelasOnDelete
---- %[3]NRelasCount, PF01:"%NRelasKFfield01", 02:"%NRelasKFfield02", 03:"%NRelasKFfield03", 04:"%NRelasKFfield04", 05:"%NRelasKFfield05", 06:"%NRelasKFfield06", 07:"%NRelasKFfield07", 08:"%NRelasKFfield08", 09:"%NRelasKFfield09"
---- %[3]NRelasCount, PL01:"%NRelasKFlabel01", 02:"%NRelasKFlabel02", 03:"%NRelasKFlabel03", 04:"%NRelasKFlabel04", 05:"%NRelasKFlabel05", 06:"%NRelasKFlabel06", 07:"%NRelasKFlabel07", 08:"%NRelasKFlabel08", 09:"%NRelasKFlabel09"
---- %[3]NRelasCount, CF01:"%NRelasKLfield01", 02:"%NRelasKLfield02", 03:"%NRelasKLfield03", 04:"%NRelasKLfield04", 05:"%NRelasKLfield05", 06:"%NRelasKLfield06", 07:"%NRelasKLfield07", 08:"%NRelasKLfield08", 09:"%NRelasKLfield09"
---- %[3]NRelasCount, CL01:"%NRelasKLlabel01", 02:"%NRelasKLlabel02", 03:"%NRelasKLlabel03", 04:"%NRelasKLlabel04", 05:"%NRelasKLlabel05", 06:"%NRelasKLlabel06", 07:"%NRelasKLlabel07", 08:"%NRelasKLlabel08", 09:"%NRelasKLlabel09"
---- %[3]NRelasCount, PLST:"%NRelaFieldsParent"
---- %[3]NRelasCount, CLST:"%NRelaFieldsChild"
          #ENDIF
#! RA.2018.06.07.THU: Per Michael Gorman. Change from-> "FROM_%NRelasFileFrom_TO_%NRelasKeyLink" to "%NRelasKeyLink"
#! RA.2018.06.03.SUN: Change FROM_%TheTable (Could have <schema>.<tablename> format) to FROM_%NRelasFileFrom
#! RA.2018.03.17.SAT: (TESTING) Per Mr. Michael Gorman - Changed the order.
#!ALTER TABLE %TheTable
#!      ADD CONSTRAINT FROM_%NRelasKeyFrom_TO_%NRelasKeyLink
#!      FOREIGN KEY %NRelaFieldsParent
#!      REFERENCES %NRelasFileLink
#!                  %NRelaFieldsChild
#!      ON UPDATE %NRelasOnUpdate
#!      ON DELETE %NRelasOnDelete
#!
#! RA.2018.06.03.SUN: This is a simple fix. No combinatorial changes OR extreme exceptions considered.
#! RA.2018.06.03.SUN: ALTER TABLE %NRelasFileLink to ALTER TABLE %TheTable2
#CALL(%SetupTheTable,%TheTable2,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NRelasFileLink,%NRelasFileLink,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
ALTER TABLE %TheTable2
      #!ADD CONSTRAINT FROM_%NRelasFileFrom_TO_%NRelasKeyLink
      ADD CONSTRAINT %NRelasKeyLink
      FOREIGN KEY %NRelaFieldsChild
      REFERENCES %TheTable
                  %NRelaFieldsParent
        #!-------------------------------------------------------------------!
        #! RA.2018.06.03: Not valid keywords are taken out earlier.          !
        #!                Check out #GROUP(%GiveMeRestrict,?,?,%pBaseName)   ! 
        #! RA.2018.04.16: If there is nothing to do, do not output anything. !
        #!-------------------------------------------------------------------!
        #IF(%NRelasOnUpdate)
      ON UPDATE %NRelasOnUpdate
        #ENDIF
        #IF(%NRelasOnDelete)
      ON DELETE %NRelasOnDelete
        #ENDIF
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
        #ENDFOR
      #ELSE
      #! RA.2018.04.16: Did not have any backend defined.
-- [GENERATE RELATION CREATE]
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
  #ELSE
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO RELATION CREATE GENERATION
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%ProcessRelationDropIt,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessRelationDropIt,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #SET(%NRelaFound, %FALSE)
  #CALL(%BuildQualifiedRelations,%pBaseName)                                    #! RA.2018.06.03 - Added the backend type.
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #IF(%NRelaFound)
    #! RA.2018.04.19: Is it a valid backend?
    #CASE(%pBaseName)                                                           #! BACKEND EXCEPTIONS
    #OF  ('METABASE')
    #OROF('MIMER')
    #OROF('MSSQL')
    #OROF('POSTGRESQL')
    #OROF('SQLANYWHERE')
    #OROF('MYSQL')
    #OROF('ORACLE')
    #OROF('DB2')
      #FOR(%NRelas)
        #IF((%TraceDetail) AND (%NRelaFound=%TRUE))
----
---- %[3]NRelasCount, %NRelasFileFromKey, %NRelasType, %NRelasFileLinkKey
---- %[3]NRelasCount, %NRelasKeyFromKey, %NRelasType, %NRelasKeyLinkKey
---- %[3]NRelasCount, %NRelasKeyFromCount, %NRelasType, %NRelasKeyLinkCount
---- %[3]NRelasCount, FROM: %[90]NRelasFileFrom, %NRelasKeyFrom
---- %[3]NRelasCount, LINK: %[90]NRelasFileLink, %NRelasKeyLink
---- %[3]NRelasCount, UPDATE: %[8]NRelasOnUpdate, DELETE: %[8]NRelasOnDelete
---- %[3]NRelasCount, PF01:"%NRelasKFfield01", 02:"%NRelasKFfield02", 03:"%NRelasKFfield03", 04:"%NRelasKFfield04", 05:"%NRelasKFfield05", 06:"%NRelasKFfield06", 07:"%NRelasKFfield07", 08:"%NRelasKFfield08", 09:"%NRelasKFfield09"
---- %[3]NRelasCount, PL01:"%NRelasKFlabel01", 02:"%NRelasKFlabel02", 03:"%NRelasKFlabel03", 04:"%NRelasKFlabel04", 05:"%NRelasKFlabel05", 06:"%NRelasKFlabel06", 07:"%NRelasKFlabel07", 08:"%NRelasKFlabel08", 09:"%NRelasKFlabel09"
---- %[3]NRelasCount, CF01:"%NRelasKLfield01", 02:"%NRelasKLfield02", 03:"%NRelasKLfield03", 04:"%NRelasKLfield04", 05:"%NRelasKLfield05", 06:"%NRelasKLfield06", 07:"%NRelasKLfield07", 08:"%NRelasKLfield08", 09:"%NRelasKLfield09"
---- %[3]NRelasCount, CL01:"%NRelasKLlabel01", 02:"%NRelasKLlabel02", 03:"%NRelasKLlabel03", 04:"%NRelasKLlabel04", 05:"%NRelasKLlabel05", 06:"%NRelasKLlabel06", 07:"%NRelasKLlabel07", 08:"%NRelasKLlabel08", 09:"%NRelasKLlabel09"
---- %[3]NRelasCount, PLST:"%NRelaFieldsParent"
---- %[3]NRelasCount, CLST:"%NRelaFieldsChild"
        #ENDIF
#! RA.2018.06.07.THU: Per Michael Gorman. Change from-> "FROM_%NRelasFileFrom_TO_%NRelasKeyLink" to "%NRelasKeyLink"
#! RA.2018.06.03.SUN: This is a simple fix. No combinatorial changes OR extreme exceptions considered.
#! RA.2018.06.03.SUN: ALTER TABLE %NRelasFileLink to ALTER TABLE %TheTable2
#! RA.2018.06.03.SUN: Change FROM_%TheTable (Could have <schema>.<tablename> format) to FROM_%NRelasFileFrom
#! RA.2018.03.17.SAT: (TESTING) Per Mr. Michael Gorman - Changed the order.
#CALL(%SetupTheTable,%TheTable2,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NRelasFileLink,%NRelasFileLink,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
#!ALTER TABLE %NRelasFileLink
ALTER TABLE %TheTable2
        #CASE(%pBaseName)                                                       #! BACKEND EXCEPTIONS
        #OF  ('METABASE')
        #OROF('MIMER')
      #!DROP CONSTRAINT FROM_%NRelasFileFrom_TO_%NRelasKeyLink CASCADE          #! RA.2018.06.07: Per Michael Gorman
      DROP CONSTRAINT %NRelasKeyLink CASCADE
        #OF  ('MSSQL')
        #OROF('POSTGRESQL')
        #OROF('SQLANYWHERE')
        #OROF('ORACLE')
        #OROF('DB2')
      #!DROP CONSTRAINT FROM_%NRelasFileFrom_TO_%NRelasKeyLink                  #! RA.2018.06.07: Per Michael Gorman               
      DROP CONSTRAINT %NRelasKeyLink
        #OF('MYSQL')                                                            #! RA.2018.09.03: Slightly different syntax
        #! RA.2018.09.03: MySQL will create pure indexes (not constraints) for any foreign index it needs in a relation.
        #! So when you automagically delete the relation constrains those automagically created indexes do not get deleted.
        #! This has been tested (and discovered) in Mr. Michael Gorman's small database used for testing the templates.
        #!ALTER TABLE tbl_name
        #!  | DROP [COLUMN] col_name
        #!  | DROP {INDEX|KEY} index_name
        #!  | DROP PRIMARY KEY
        #!  | DROP FOREIGN KEY fk_symbol
      DROP FOREIGN KEY %NRelasKeyLink
        #ENDCASE                                                                #! BACKEND EXCEPTIONS
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
      #ENDFOR
    #ELSE
-- [GENERATE RELATION DROP]
    #ENDCASE                                                                    #! BACKEND EXCEPTIONS
  #ELSE
    #IF(%Comments)
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #ELSE
-- NO RELATION DROP GENERATION
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
    #ENDIF
  #ENDIF
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%ProcessGrantCreate,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessGrantCreate,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #! RA.2018.04.09: Is it a VALID backend?
  #CASE(%pBaseName)                                                             #! BACKEND EXCEPTIONS
  #OF  ('METABASE')
  #OROF('MIMER')
  #OROF('MSSQL')
  #OROF('POSTGRESQL')
  #OROF('MYSQL')                                                                #! RA.2018.09.03: 'PUBLIC' has to exist as a user/group
  #OROF('ORACLE')
  #OROF('DB2')
GRANT SELECT, INSERT, UPDATE, DELETE 
      ON %TheTable
      TO PUBLIC
  #OF  ('SQLANYWHERE')
GRANT SELECT, INSERT, DELETE, UPDATE, ALTER, REFERENCES
      ON %TheTable 
      TO PUBLIC
  #ENDCASE                                                                      #! BACKEND EXCEPTIONS      
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%ProcessGrantDropIt,%pBaseName)
#IF(%TraceFlow)
  #SET(%CountNFiles,ITEMS(%NFiles))
---- #GROUP(%%ProcessGrantDropIt,'%pBaseName'): CountNFiles: %CountNFiles
#ENDIF
#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #!SET(%TheTable,%NFilesName)
  #!CALL(%ReserveWordReplace,%TheTable)
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
#!
  #! RA.2018.04.19: Is it a VALID backend?
  #CASE(%pBaseName)                                                             #! BACKEND EXCEPTIONS
  #OF  ('METABASE')
  #OROF('MIMER')
  #OROF('MSSQL')
  #OROF('POSTGRESQL')
  #OROF('MYSQL')                                                                #! RA.2018.09.03: 'PUBLIC' has to exist as a user/group
  #OROF('ORACLE')
  #OROF('DB2')
REVOKE SELECT, INSERT, UPDATE, DELETE 
       ON %TheTable
       FROM PUBLIC
  #OF  ('SQLANYWHERE')
REVOKE SELECT, INSERT, DELETE, UPDATE, ALTER, REFERENCES
       ON %TheTable 
       FROM PUBLIC
  #ENDCASE                                                                      #! BACKEND EXCEPTIONS
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
#!
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2019.07.06: Audit GUID fields
#! RA.2018.04.07: Pass %BaseName as a parameter
#GROUP(%MetabaseSqlField,%pBaseName)
#IF(%TraceFlow)
---- #GROUP(%%MetabaseSqlField,'%pBaseName')
#ENDIF
#CALL(%BuildQualifiedFields,%pBaseName)                                         #! Just use Fields you need
#!
#CALL(%BuildQualifiedFieldsGUID,%pBaseName)                                     #! RA.2019.07.06: Audit GUID fields
#!
#CALL(%BuildFieldTypes,%pBaseName)                                              #! FIELD: Clarion to SQL types
#GROUP(%MetabaseSqlFieldEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! BUILD QUALIFIED FIELDS
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%BuildQualifiedFields,%pBaseName)                                        #! Just use what you need
#!
#FREE(%AFields)                                                                 #! Valid field items here (with field from arrays)
#FREE(%NFields)                                                                 #! Valid field items here (from original table)
#SET(%InnerGroup, 0)                                                            #! This counts GROUP-END pairs
#SET(%FieldComma, ITEMS(%Field) - 1)                                            #! How many commas do I need?
#!
#FOR(%Field)                                                                    #! VALID FIELD: FOR
  #!-----------------------!
  #! Check the OPTIONS now !
  #!-----------------------!
  #INSERT(%GetFieldOptions)                                                     #! RASQL(,,,) for Fields
  #!--------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a field is processed. !
  #!--------------------------------------------------------------!
  #IF(SUB(%NFieldOpt1,1,1)='N')                                                 #! Ignore this field
    #IF(%TraceDetail)
---- IGNORED: "%Field" [FIELD options say NO]
    #ENDIF
    #CYCLE
  #ENDIF
  #!------------------------------------------------!
  #! Begin removal of types that are not processed. !
  #!------------------------------------------------!
  #IF(%FieldType='GROUP')
    #SET(%InnerGroup, %InnerGroup + 1)
    #IF(INSTRING('OVER(',%FieldStatement,1,1))
      #!SET(%FieldCount, %FieldCount + 1)                                       #! RAS.2001.01.15
      #!SET(%FieldComma, %FieldComma - 1)                                       #! RAS.2001.01.12
    #ENDIF
    #SET(%FieldComma, %FieldComma - 1)                                          #! RAS.2001.01.12
    #! RA.2017.12.03 - Tested: GROUP displayed
    #IF(%TraceDetail)
---- IGNORED: "%Field" [FIELD type is "%FieldType"]
    #ENDIF
    #CYCLE
  #ENDIF
  #!
  #IF(%FieldType='END')
    #SET(%InnerGroup, %InnerGroup - 1)
    #SET(%FieldComma, %FieldComma - 1)
    #! RA.2017.12.03 - Tested: END displayed
    #IF(%TraceDetail)
---- IGNORED: "%Field" [FIELD type is "%FieldType"]
    #ENDIF
    #CYCLE
  #ENDIF
  #SET(%FD1L,%FieldDimension1)                                                  #! Name 1 made shorter
  #SET(%FD2L,%FieldDimension2)                                                  #! Name 2 made shorter
  #SET(%FD3L,%FieldDimension3)                                                  #! Name 3 made shorter
  #SET(%FD4L,%FieldDimension4)                                                  #! Name 4 made shorter
  #IF(%FD1L>0)                                                                  #! IF we got array field,
    #IF(NOT %optNoArrayOver)                                                    #! AND we got groups,
---- IGNORED: "%Field" [FIELD has option NO ARRAY OVER=FALSE]
---- POSSIBLE: Dictionary ERROR [Human error: Check this field]
      #SET(%FieldComma, %FieldComma - 1)                                        #! THEN ignore the array
      #CYCLE                                                                    #! field since the fields
    #ENDIF                                                                      #! in the group are going
  #ELSE
#!---- PROCESSING: "%Field" [FIELD has option NO ARRAY OVER=TRUE]
  #ENDIF                                                                        #! to define the array.
  #!----------------------------!
  #! We pass FIELD requirements !
  #!----------------------------!
  #!ADD(%NFields,%Field)                                                        #! This FIELD is processed
  #ADD(%NFields           ,ITEMS(%NFields) + 1)
  #SET(%NFieldsCount      ,ITEMS(%NFields))
  #SET(%NFieldsKey        ,%Field)                                              #! Prefix:FieldName
  #SET(%NFieldsName       ,%FieldID)                                            #! FieldName
  #CALL(%SetupTheField,%NFieldsName,%pBaseName,%FieldID,%FieldName)             #! RA.2019.08.10: Handle EXTERNAL name
  #SET(%NFieldsType       ,%FieldType)
  #SET(%NFieldsFormat     ,UPPER(%FieldDisplayPicture))
  #SET(%NFieldsOpts       ,%FieldUserOptions)                                   #! RA.2019.04.30.TUE
  #!
  #! RA.2018.04.15: Setup Length/Decimals [For the numeric types]
  #SET(%NFieldsDatLen     ,%FieldMemoSize)                                      #! Clarion: Data Length
  #SET(%NFieldsDatDec     ,%FieldPlaces)                                        #! Clarion: Data Decimals
  #SET(%NFieldsDspLen     ,0)                                                   #! Clarion: Display Length
  #SET(%NFieldsDspDec     ,0)                                                   #! Clarion: Display Decimals
  #! 
  #CASE(%NFieldsType)
  #OF  ('DECIMAL')
  #OROF('PDECIMAL')
  #OROF('DEC')
  #OROF('NUMERIC')
  #!
  #OROF('SREAL')
  #OROF('BFLOAT4')
  #OROF('FLOAT')
  #OROF('FLOAT4')
  #!
  #OROF('REAL')
  #OROF('BFLOAT8')
  #OROF('DOUBLE')
  #OROF('FLOAT8')
    #SET(%TestLenDec      ,UPPER(%FieldDisplayPicture))
    #SET(%MoreLenDec      ,'')
    #CALL(%ReplaceSubString,%TestLenDec,'-','')
    #CALL(%ReplaceSubString,%TestLenDec,'_','')
    #CALL(%ReplaceSubString,%TestLenDec,'$','')
    #CALL(%ReplaceSubString,%TestLenDec,'@','')
    #CALL(%ReplaceSubString,%TestLenDec,'N','')
    #CALL(%ReplaceSubString,%TestLenDec,'B','')
    #CALL(%ReplaceSubString,%TestLenDec,'(','')
    #CALL(%ReplaceSubString,%TestLenDec,')','')
    #SET(%nLoc1           ,INSTRING('.',%TestLenDec,1,1))
    #IF(%nLoc1 > 0)
      #SET(%NFieldsDspLen ,SUB(%TestLenDec,1,%nLoc1-1))
      #SET(%NFieldsDspDec ,SUB(%TestLenDec,%nLoc1+1,LEN(%TestLenDec)))      
    #ENDIF
    #!
    #IF(%TraceDetail)
----00 Field: %FieldID [%FieldType]  NFieldsDatLen="%NFieldsDatLen", NFieldsDatDec="%NFieldsDatDec", NFieldsDspLen="%NFieldsDspLen", NFieldsDspDec="%NFieldsDspDec"
#!----01 Field: %FieldID [%FieldType] >>> "%TestLenDec" :=: "%MoreLenDec" <<< | Display=%FieldDisplayPicture | Places=%FieldPlaces | Picture=%FieldPicture | Statement=%FieldStatement [%FieldMemoSize]
    #ENDIF
  #ENDCASE
  #! RA.2018.04.15: Only needed when DECIMAL types [Double Check]
  #CASE(%NFieldsType)
  #OF  ('DECIMAL')
  #OROF('PDECIMAL')
  #OROF('DEC')
  #OROF('NUMERIC')
    #SET(%MoreLenDec      ,UPPER(%FieldStatement))
    #SET(%nLoc1           ,INSTRING('),',%MoreLenDec,1,1))
    #IF(%nLoc1 > 0)
      #SET(%MoreLenDec    ,SUB(%MoreLenDec,1,%nLoc1))
    #ENDIF
    #CALL(%ReplaceSubString,%MoreLenDec,%NFieldsType,'')
    #!CALL(%ReplaceSubString,%MoreLenDec,'-','')
    #!CALL(%ReplaceSubString,%MoreLenDec,'_','')
    #!CALL(%ReplaceSubString,%MoreLenDec,'$','')
    #!CALL(%ReplaceSubString,%MoreLenDec,'@','')
    #!CALL(%ReplaceSubString,%MoreLenDec,'N','')
    #!CALL(%ReplaceSubString,%MoreLenDec,'B','')
    #CALL(%ReplaceSubString,%MoreLenDec,'(','')
    #CALL(%ReplaceSubString,%MoreLenDec,')','')
    #!
    #IF(%TraceDetail)
----02 Field: %FieldID [%FieldType] >>> "%TestLenDec" :=: "%MoreLenDec" <<< | Display=%FieldDisplayPicture | Places=%FieldPlaces | Picture=%FieldPicture | Statement=%FieldStatement [%FieldMemoSize]
    #ENDIF
  #ENDCASE  
 #!----------------------------------------------------------------!
  #! The second option RASQL(,<FieldType>) overrides the field type !
  #! in the dictionary. This allows conversion of data types that   !
  #! have no existence in the dictionary but exist in the SQL.      !
  #!----------------------------------------------------------------!
  #IF(%NFieldOpt2)
    #SET(%NFieldsType,UPPER(%NFieldOpt2))
    #IF(%TraceDetail)
---- Field Type Override: %NFieldsName [%NFieldsType] %NFieldOpt2 (%NFieldsFormat)
    #ENDIF
  #ENDIF
#ENDFOR                                                                         #! VALID FIELD: #ENDFOR
#IF(%TraceDetail)

---- BuildQualifiedFields ----
---- InnerGroup: %InnerGroup
---- FieldComma: %FieldComma
  #FOR(%NFields)
---- %[3]NFieldsCount %[90]NFieldsKey (%[10]NFieldsType, %[10]NFieldsFormat, (%[4]NFieldsDatLen, %[4]NFieldsDatDec), ?) "%NFieldsOpts"
  #ENDFOR

#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.07 - Pass %BaseName as a parameter
#GROUP(%BuildFieldTypes,%pBaseName)                                             #! FIELD: Clarion to SQL types
#!---- InnerGroup: %InnerGroup
#!---- FieldComma: %FieldComma
#FOR(%NFields)
  #FIX(%Field,%NFieldsKey)
  #!-----------------------!
  #! Check the OPTIONS now !
  #!-----------------------!
  #INSERT(%GetFieldOptions)                                                     #! RASQL(,,,) for Fields
#!  
#!--00 %[3]NFieldsCount %[30]NFieldsKey (%[10]NFieldsType, %[10]NFieldsFormat, ?)
#!
  #!-------------------------------------------------------------------------!
  #! RA.2017.12.06 - Ponder a more intelligent approach to this if posible.  !
  #! Check if KEYIN or PATTERN are being used in the database picture field. !
  #! Just fix your database to a simple data type and format differently.    !
  #! RA.2017.12.06 - Do you need to make this an option in the future?       !
  #!-------------------------------------------------------------------------!
  #IF(%TRUE)
    #CASE(SUB(%NFieldsFormat,2,1))
    #OF  ('S')                                                  #! STRING
    #OROF('N')                                                  #! NUMERIC
    #OROF('D')                                                  #! DATE
    #OROF('T')                                                  #! TIME
    #OROF('E')                                                  #! SCIENTIFIC
    #!OROF('K')                                                  #! KEYIN
    #!OROF('P')                                                  #! PATTERN
    #ELSE
---- MIGHT NEED TO FIX THIS: Field format "%NFieldsFormat" is not handled for "%NFieldsKey". [CHANGE YOUR CLARION SPECIFIC FIELD FORMAT]
    #ENDCASE
  #ENDIF
  #!--------------------------------------------------------------------------------!
  #! Calculate decimal size and places for some fields.                             !
  #! Only DECIMAL fields have characters and decimals.                              !
  #! Everything else that needs it, is figured out from the display mask used.      !
  #!--------------------------------------------------------------------------------!
  #! RA.2018.04.15: This figures out if you have any leading zeros in the numerics. !
  #! The decimal size and places are figured out before you get here in the         !
  #! #GROUP(%BuildQualifiedFields). Both the data and the display are figured out.  !
  #!--------------------------------------------------------------------------------!
  #SET(%NFieldSize         ,%FieldMemoSize)                     #! Field decimal size
  #SET(%NFieldDec          ,%FieldPlaces)                       #! Field decimal places
  #SET(%NLeadZero          ,0)                                  #! NO leading zero
#!
  #CASE(%NFieldsType)
  #OF  ('DECIMAL')
  #OROF('PDECIMAL')
  #OROF('DEC')
  #OROF('NUMERIC')
  #!
  #OROF('SREAL')
  #OROF('BFLOAT4')
  #OROF('FLOAT')
  #OROF('FLOAT4')
  #!
  #OROF('REAL')
  #OROF('BFLOAT8')
  #OROF('DOUBLE')
  #OROF('FLOAT8')
    #SET(%TestLenDec       ,UPPER(%NFieldsFormat))
    #CALL(%ReplaceSubString,%TestLenDec,'-','')
    #CALL(%ReplaceSubString,%TestLenDec,'_','')
    #CALL(%ReplaceSubString,%TestLenDec,'$','')
    #CALL(%ReplaceSubString,%TestLenDec,'@','')
    #CALL(%ReplaceSubString,%TestLenDec,'B','')
    #CALL(%ReplaceSubString,%TestLenDec,'(','')
    #CALL(%ReplaceSubString,%TestLenDec,')','')
    #!
    #IF(%TraceDetail)  
#!----LEADZERO: 01A:0 %NFieldsType: "%NFieldsFormat", %nLoc1, %nLoc2, (%NFieldSize, %NFieldDec), %NLeadZero
#!----LEADZERO: 01A:0 %NFieldsType: "%NFieldsFormat", "%TestLenDec" (%NFieldSize, %NFieldDec), %NLeadZero
    #ENDIF
    #SET(%NLeadZero,INSTRING('N0',%TestLenDec,1,1))
    #IF(%TraceDetail)  
      #IF(%NLeadZero > 0)
#!----LEADZERO: 01A:1 %NFieldsType: "%TestLenDec", %nLoc1, %nLoc2, (%NFieldSize, %NFieldDec), %NLeadZero [Found Leading Zero]
----LEADZERO: 01A:1 %NFieldsType: "%TestLenDec", "%TestLenDec" (%NFieldSize, %NFieldDec), %NLeadZero [Found Leading Zero]
      #ENDIF
    #ENDIF
  #!--------------------------------------------------------!
  #! RAS.2001.10.23 - Parse sizes for non-decimal numerics. !
  #! And set the leading zero flag if you find the need.    !
  #!--------------------------------------------------------!
  #OF  ('LONG')
  #OROF('ULONG')
  #OROF('SHORT')
  #OROF('USHORT')
  #OROF('BYTE')
    #SET(%TestLenDec       ,UPPER(%NFieldsFormat))
    #CALL(%ReplaceSubString,%TestLenDec,'-','')
    #CALL(%ReplaceSubString,%TestLenDec,'_','')
    #CALL(%ReplaceSubString,%TestLenDec,'$','')
    #CALL(%ReplaceSubString,%TestLenDec,'@','')
    #CALL(%ReplaceSubString,%TestLenDec,'B','')
    #CALL(%ReplaceSubString,%TestLenDec,'(','')
    #CALL(%ReplaceSubString,%TestLenDec,')','')
    #!
    #IF(%TraceDetail)  
#!----LEADZERO: 01B:0 %NFieldsType: "%NFieldsFormat", %nLoc1, %nLoc2, (%NFieldSize, %NFieldDec), %NLeadZero
#!----LEADZERO: 01B:0 %NFieldsType: "%NFieldsFormat", "%TestLenDec" (%NFieldSize, %NFieldDec), %NLeadZero
    #ENDIF
    #SET(%NLeadZero,INSTRING('N0',%TestLenDec,1,1))
    #! RA.2017.12.03 - Tested
    #IF(%TraceDetail)  
      #IF(%NLeadZero > 0)
#!----LEADZERO: 01B:1 %NFieldsType: "%NFieldsFormat", %nLoc1, %nLoc2, (%NFieldSize, ?), %NLeadZero [Found Leading Zero]
----LEADZERO: 01B:1 %NFieldsType: "%NFieldsFormat", "%TestLenDec" (%NFieldSize, %NFieldDec), %NLeadZero [Found Leading Zero]
      #ENDIF
    #ENDIF
  #ENDCASE
#!
  #SET(%NFieldsNSql ,'')                                        #! Field SQL name
  #SET(%NFieldsTSql ,'')                                        #! Field SQL type
  #SET(%NFieldsDef  ,'')                                        #! Field default
  #SET(%NFieldsAuto ,'')                                        #! Field AUTO_INCREMENT
  #SET(%NFieldsNN   ,'')                                        #! Field NOT NULL
#!
  #!------------------------------------!
  #! Is the field name a reserved word? !
  #!------------------------------------!
  #SET(%TheField,%NFieldsName)
  #CALL(%ReserveWordReplace,%TheField)
  #SET(%NFieldsNSql,%TheField)
#!
  #!------------------------------------------------------!
  #! Deal with the dictionary field type conversion here. !
  #!------------------------------------------------------!
  #CASE(%NFieldsType)
  #OF  ('BLOB')
      #SET(%NFieldsTSql,            'BLOB(' & %FieldMemoSize & ')')
      #!
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #!OROF('METABASE')
      #OROF('MSSQL')                                                            #! RA.2018.11.10: Michael Gorman request
        #!---------------------------------------------------------------------------------------------!
        #! http://developer.mimer.com/documentation/html_92/Mimer_SQL_Mobile_DocSet/Syntax_Rules4.html !
        #!---------------------------------------------------------------------------------------------!
        #IF(%optGenClobFields)
          #SET(%NFieldsTSql,        'CLOB(' & %FieldMemoSize & ')' )
          #IF(%optGenIntlString)
            #SET(%NFieldsTSql,      'NCLOB(' & %FieldMemoSize & ')' )
          #ENDIF
        #ELSE
          #SET(%NFieldsTSql,        'VARCHAR(' & %FieldMemoSize & ')' )
          #IF(%optGenIntlString)
            #SET(%NFieldsTSql,      'NVARCHAR(' & %FieldMemoSize & ')' )
          #ENDIF
        #ENDIF
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
      #!
  #OF  ('MEMO')
  #OROF('STRING')
      #SET(%NFieldsTSql,            'CHAR(' & %FieldMemoSize & ')')
      #!
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #!OROF('METABASE')
      #OROF('MSSQL')                                                            #! RA.2018.11.10: Michael Gorman request
        #SET(%NFieldsTSql,          'VARCHAR(' & %FieldMemoSize & ')' )
        #IF(%optGenIntlString)
          #SET(%NFieldsTSql,        'NVARCHAR(' & %FieldMemoSize & ')' )
        #ENDIF
      #OF  ('MYSQL')
        #! RA.2018.07.16.MON: TINYTEXT (255), TEXT (65,535), MEDIUMTEXT (16,777,215), LONGTEXT (4,294,967,295)
        #!#IF   (%FieldMemoSize < 256)
        #!  #SET(%NFieldsTSql,        'TINYTEXT')
        #!#ELSIF(%FieldMemoSize < 65536)
        #!  #SET(%NFieldsTSql,        'TEXT')
        #!#ELSIF(%FieldMemoSize < 16777216)
        #!  #SET(%NFieldsTSql,        'MEDIUMTEXT')
        #!#ELSIF(%FieldMemoSize < 4294967296)
        #!  #SET(%NFieldsTSql,        'LONGTEXT')
        #!#ENDIF
        #! RA.2018.07.16.MON: CHAR(<255),  VARHAR(>255)
        #IF   (%FieldMemoSize < 256)
          #SET(%NFieldsTSql,        'CHAR(' & %FieldMemoSize & ')')
        #ELSE
          #SET(%NFieldsTSql,        'VARCHAR(' & %FieldMemoSize & ')' )
        #ENDIF
        #! RA.2019.07.20.SAT: Identify primary key for function default.
        #! RA.2019.07.04.THU: Set up for UUID primary key (Need 16 bytes)
        #IF   (%NFieldOpt3 = '[GUIDPKEY]' OR %NFieldOpt3 = '[GUID]')
          #SET(%NFieldsTSql,        'BINARY(' & %FieldMemoSize & ')')
        #ENDIF
      #OF  ('POSTGRESQL')
        #! RA.2019.07.20.SAT: Identify primary key for function default.
        #! RA.2019.07.04.THU: Set up for UUID primary key (Need 16 bytes)
        #IF   (%NFieldOpt3 = '[GUIDPKEY]' OR %NFieldOpt3 = '[GUID]')
          #IF(%optGenerateGUID)                                                 #! RA.2019.07.19: Added
            #SET(%NFieldsTSql,      'UUID')
          #ENDIF
        #ENDIF
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
#!
  #OF  ('CSTRING')
  #OROF('PSTRING')
      #SET(%CStringLen, %FieldMemoSize - 1)
      #SET(%NFieldsTSql,            'VARCHAR(' & %CStringLen & ')' )
      #!
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #!OROF('METABASE')
      #OROF('MSSQL')                                                            #! RA.2018.11.10: Michael Gorman request
        #IF(%optGenIntlString)
          #SET(%NFieldsTSql,        'NVARCHAR(' & %CStringLen & ')' )
        #ENDIF
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
      #!
  #OF  ('BYTE')
  #OROF('UTINYINT')
  #OROF('UINT1')
  #OROF('TINYINT')
  #OROF('INT1')
  #OROF('BIT')                                                                  #! RA.2019.07.04: Added
  #OROF('BOOL')                                                                 #! RA.2019.07.04: Added
  #OROF('BOOLEAN')                                                              #! RA.2019.07.04: Added
      #SET(%NFieldsTSql,            'TINYINT')
      #!
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('MIMER')
      #!OROF('METABASE')
      #OROF('POSTGRESQL')                                                       #! RA.2019.09.15: Added
        #SET(%NFieldsTSql,          'SMALLINT')
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
      #!
  #OF  ('USHORT')
  #OROF('USMALLINT')
  #OROF('UINT2')
  #OROF('SHORT')
  #OROF('SMALLINT')
  #OROF('INT2')
      #SET(%NFieldsTSql,            'SMALLINT')
  #OF  ('ULONG')
  #OROF('UINT')
  #OROF('UINT4')
      #SET(%NFieldsTSql,            'INTEGER')
  #OF  ('LONG')
  #OROF('INT')
  #OROF('INT4')
  #OROF('INTEGER')
      #SET(%NFieldsTSql,            'INTEGER')
      #IF(INSTRING('@D',%NFieldsFormat,1,1))
        #SET(%NFieldsTSql,          'DATE')
      #ENDIF
      #IF(INSTRING('@T',%NFieldsFormat,1,1))
        #SET(%NFieldsTSql,          'TIME')
      #ENDIF
      #!
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('METABASE')
      #OROF('MIMER')
        #SET(%NFieldsTSql,          'INTEGER')
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
      #!
  #OF  ('UINT8')
      #SET(%NFieldsTSql,            'BIGINT')
  #OF  ('INT8')
      #SET(%NFieldsTSql,            'BIGINT')
      #!
  #OF  ('DATE')
  #OROF('TIME')
  #! RA.2019.07.23: This might need to be backend exceptions (but not right now)
  #OROF('TIMETZ')                                                               #! RA.2019.07.23: PostgreSQL
  #OROF('BIGINT')                                                               #! RA.2019.07.23: PostgreSQL
  #OROF('TIMESTAMP')                                                            #! RA.2019.07.23: PostgreSQL
  #OROF('TIMESTAMPTZ')                                                          #! RA.2019.07.23: PostgreSQL
      #SET(%NFieldsTSql,            %NFieldsType)
  #!---------------------------------------------------------------------!
  #! RA.2001.01.09 - IMPORTANT - READ THIS NOW.                          !
  #!---------------------------------------------------------------------!
  #! There is a very big assumption here that your doing a business type !
  #! application so you want to convert binary inaccurate formats to the !
  #! totally binary (financial) accurate format of DECIMAL.              !
  #!---------------------------------------------------------------------!
  #! I get tired of those hours of time spent on penny off errors on     !
  #! financial screens and reports with a calculator to finally come up  !
  #! with the solution of "It is a rounding error!" due to the binary    !
  #! inaccurate format representation of "floats" and "doubles" that     !
  #! are often used to represent money amounts with an actual fractional !
  #! point part for the cents. This happens often in older applications  !
  #! written in languages that did not have a decimal type and with      !
  #! people that did not have experience or knowledge enough to save     !
  #! those financial amounts as whole pennies and adjust their formulas. !
  #!---------------------------------------------------------------------!
  #! If you need the SREAL (4 bytes) and REAL (8 bytes) left alone then  !
  #! move them somewhere else.                                           !
  #!---------------------------------------------------------------------!
  #! RA.2017.12.06 - IMPORTANT - READ THIS NOW.                          !
  #!---------------------------------------------------------------------!
  #! There are some scientific database in the future that I might have  !
  #! to deal with for GIS and DATA analysis. Ponder how to deal with it. !
  #! Start by separating the different types. Still handling the same.   !
  #!---------------------------------------------------------------------!
  #OF  ('DECIMAL')
  #OROF('PDECIMAL')
  #OROF('DEC')
  #OROF('NUMERIC')
      #SET(%NFieldsTSql,            'DECIMAL(' & %NFieldSize & ',' & %NFieldDec & ')')
#!
  #! RA.2018.04.13: This is the 4 bytes variety.
  #OF  ('SREAL')
  #OROF('BFLOAT4')
  #OROF('FLOAT')
  #OROF('FLOAT4')
      #! RA.2018.04.13: Change process to use what is there.
      #!SET(%NFieldsTSql,           'DECIMAL(' & %NFieldSize & ',' & %NFieldDec & ')')
      #SET(%NFieldsTSql,            'REAL')
#!
  #! RA.2018.04.13: This is the 8 bytes variety.
  #OF  ('REAL')
  #OROF('BFLOAT8')
  #OROF('DOUBLE')
  #OROF('FLOAT8')
      #! RA.2018.04.13: Change process to use what is there.
      #!SET(%NFieldsTSql,           'DECIMAL(' & %NFieldSize & ',' & %NFieldDec & ')')
      #SET(%NFieldsTSql,            'FLOAT')
      #!
      #! RA.2019.07.30: PostgreSQL wants 'DOUBLE PRECISION' for 8 bytes with 15 digits of precission
      #!
      #CASE(%pBaseName)                                                         #! BACKEND EXCEPTIONS
      #OF  ('POSTGRESQL')
        #SET(%NFieldsTSql,          'DOUBLE PRECISION')
      #ENDCASE                                                                  #! BACKEND EXCEPTIONS
#!
  #ELSE
      #!---------------------------------------------!
      #! This is a field type not currently handled. !
      #! Time to do some more template programming.  !
      #!---------------------------------------------!
      #SET(%NFieldsTSql,            '***' & %NFieldsType & '***')
  #ENDCASE
#!
  #!----------------------------------------------------------!
  #! Deal with field validation parameters in the dictionary. !
  #!----------------------------------------------------------!
  #! If you are validating something, that means it's going   !
  #! to have some value. Mark it as NOT NULL.                 !
  #!----------------------------------------------------------!
  #! RA.2018.04.29: In the VALIDATION you got to make sure it !
  #! shows up as NOT-NULL. Show %FieldValidation type.        !
  #!----------------------------------------------------------!
  #IF(VAREXISTS(%ReplaceFunctionSQL)=0)                                         #! RA.2019.07.20: Added EARLIER today
    #DECLARE(%ReplaceFunctionSQL)
  #ENDIF
  #SET(%NFieldsDef  ,'')                                                        #! RA.2019.07.20: Moved HERE today
  #!IF(%optGenNotNullKeys)                                                      #! RA.2012.06.10 - Per Michael Gorman
    #IF(%FieldValidation)
      #IF(%TraceDetail)
---- %[10]FieldValidation VALIDATE: %[3]NFields, %NFieldsKey 
      #ENDIF
      #SET(%NFieldsNN,              'NOT NULL')
      #!
      #! RA.2019.07.20: IF something is NULL, THEN you need to think about it.
      #! IF you mark something as NOT NULL but you have NO DEFAULT, THEN this might cause
      #! a tiny little problem on the backend. Fake the default by type. 
      #! For numeric default a zero [0], and for string default an empty string ['']
      #! You can add an initial item if you DO NOT have a FUNCTION for default.
      #!
      #!IF(%FieldValidation = 'NONZERO')
        #IF(%FieldInitial)
          #! IF this is a Clarion function, THEN ignore it and DEFAULT.
          #! Code can use some improvement here. Just think about it.
          #IF(INSTRING('(',UPPER(%FieldInitial),1,1))
            #CALL(%IsFieldTypeNumeric,%nLoc2,%FieldType)
            #IF(%nLoc2)
              #SET(%NFieldsDef  , 'DEFAULT 0')
            #ELSE
              #SET(%NFieldsDef  , 'DEFAULT <39><39>')
            #ENDIF
          #ENDIF
        #ELSE
          #CALL(%IsFieldTypeNumeric,%nLoc2,%FieldType)
          #IF(%nLoc2)
            #SET(%NFieldsDef  , 'DEFAULT 0')
          #ELSE
            #SET(%NFieldsDef  , 'DEFAULT <39><39>')
          #ENDIF
        #ENDIF
      #!ENDIF
    #ELSE
      #!
      #! RA.2019.07.20: The other side of this also requires a bit of thought.
      #! IF you have NO validation (do not care if it IS NULL),
      #! AND it HAS a clarion function puting something in the field, 
      #! THEN you might need to default a value from the SQL side of things.
      #! For numeric default a zero [0], and for string default an empty string ['']
      #! You can add an initial item if you DO NOT have a FUNCTION for default.
      #!
      #! AND while this in reality might not make a difference in the SQL side of things
      #! (since a NULL will be generated in the backend), it might make things a bit harder
      #! to think about if you have a NULL hanging around at the wrong time.
      #! Avoiding NULL if posible is just a CHOICE for me. You can choose differently.
      #!
      #! NOTE: At this time all SQL backend function items will ONLY generate
      #!       if there is nothing in the DEFAULT field. Be aware of this.
      #! 
      #IF(%TraceDetail)
---- %[10]FieldValidation NO-VALID: %[3]NFields, %NFieldsKey 
      #ENDIF
      #CASE(UPPER(%NFieldOpt3))
      #OF  ('[GUIDPKEY]')                                                       #! ryb_MakeGUID()
      #OROF('[GUID]')
      #OROF('[USER]')                                                           #! current_user
      #OROF('[DATE]')                                                           #! current_date
      #OROF('[TIME]')                                                           #! current_time
      #OROF('[STAMP]')                                                          #! current_timestamp
        #! RA.2019.07.20: It is set above. However just making sure.
        #! This will get generated later from: %IsInitialFunctionReplaceSQL     
        #SET(%NFieldsDef      ,'')                                              #! RA.2019.07.20: Moved HERE today
      #ELSE
        #! RA.2019.07.21: Something easy this way comes. (If you do it!)
        #! IF there is a function on the Clarion side doing something,
        #! THEN it would be a good idea to default something for the SQL side.
        #! Lets avoid the NULL condition whenever possible.
        #!
        #! On the CLARION side:
        #!
        #! ryb_MakeGUID()       ! Wrap: StringTheory.MakeGUID()                 #! [GUIDPKEY]
        #! ryb_TerminalName()   ! Wrap: ???
        #! ryb_ComputerName()   ! Wrap: vuFile Utilities
        #! ryb_UserName()       ! Wrap: vuFile Utilities                        #! current_user
        #! ryb_ServerDate()     ! Wrap: TODAY()                                 #! current_date
        #! ryb_ServerTime()     ! Wrap: CLOCK()                                 #! current_time
        #! ryb_ServerStamp()    ! Wrap: glo:SyncDesktop.GetElapsedTimeUTC()     #! current_timestamp
        #!
        #! The wrappers are to isolate all the procedures used by the system for which the 
        #! procedure contents can be replaced without changing your DCT %FieldInitial settings.
        #! SOC: Separation of concerns (less maintenance in the long run) functional process.
        #! 
        #IF(INSTRING('(',UPPER(%FieldInitial),1,1))
          #CALL(%IsFieldTypeNumeric,%nLoc2,%FieldType)
          #IF(%nLoc2)
            #SET(%NFieldsDef  , 'DEFAULT 0')
          #ELSE
            #SET(%NFieldsDef  , 'DEFAULT <39><39>')
          #ENDIF
        #ENDIF    
      #ENDCASE
    #ENDIF
  #!ENDIF                                                                       #! RA.2012.06.10 - Per Michael Gorman
#!
  #!-----------------------------------------------!
  #! Set the field if it is in the NOT-NULL table. !
  #!-----------------------------------------------!
  #IF(%optGenNotNullKeys)                                                       #! RA.2012.06.10 - Per Michael Gorman
    #!SET(%IFieldInKey,%NFields)                                                #! Field Name
    #SET(%IFieldInKey,%NFieldsKey)                                              #! Field Name
    #FIND(%NFieldsNOTNULL,%IFieldInKey)                                         #! Field In Key list lookup
    #IF(%NFieldsNOTNULL)                                                        #! Found? Yes, part of key.
      #IF(%TraceDetail)
---- NOT-NULL: %[3]NFields, %NFieldsKey
      #ENDIF
      #SET(%NFieldsNN,              'NOT NULL')                                 #! Lookup keys fields can
    #ENDIF                                                                      #! not be NULL. Make it so!
  #ENDIF                                                                        #! RA.2012.06.10 - Per Michael Gorman
#!
  #!-----------------------------------------------------! 
  #! Set the field if it is in the AUTO-INCREMENT table. !
  #!-----------------------------------------------------! 
  #IF(%optGenNotNullKeys)                                                       #! RA.2018.04.24: Added
    #!SET(%IFieldAutoInc,%NFields)                                              #! Field Name
    #SET(%IFieldAutoInc,%NFieldsKey)                                            #! Field Name
    #FIND(%NFieldsAUTOINC,%IFieldAutoInc)                                       #! Field In Key list lookup
    #IF(%NFieldsAUTOINC)                                                        #! Found? Yes, part of key.
      #IF(%TraceDetail)
---- AUTO-INC: %[3]NFields, %NFieldsKey
      #ENDIF
      #SET(%NFieldsNN,              'NOT NULL')                                 #! Lookup keys fields can
    #ENDIF                                                                      #! not be NULL. Make it so!
  #ENDIF                                                                        #! RA.2018.04.24: Added
#!
  #!----------------------------------------------------------!
  #! IF this is a PRIMARY KEY, THEN make sure it is NOT-NULL. !
  #!----------------------------------------------------------!
    #SET(%IFieldPrimary,%NFieldsKey)                                            #! Field Name
    #FIND(%NFieldsPRIMARY,%IFieldPrimary)                                       #! Field In primary list lookup
    #IF(%NFieldsPRIMARY)                                                        #! Found? Yes, primary.
      #IF(%TraceDetail)
---- %[7]NULL PRIMARY KEY: %[3]NFields, %NFieldsKey
      #ENDIF
      #SET(%NFieldsNN,              'NOT NULL')                                 #! Lookup keys fields can
    #ENDIF                                                                      #! not be NULL. Make it so!
#!
  #!--------------------------------------------------------------!
  #!--------------------------------------------------------------!
  #! Generate BACKEND special syntax for auto incremented fields. !
  #!--------------------------------------------------------------!
  #!--------------------------------------------------------------!
  #! RA.2018.04.24: %TraceDetail flag only shows special cases.
  #SET(%NFieldsAuto , '')                                                       #! RA.2018.04.24: Added
  #SET(%IFieldAutoInc,%NFieldsKey)                                              #! Field Name
  #FIND(%NFieldsAUTOINC,%IFieldAutoInc)                                         #! Field In Auto-Increment list
  #IF(%NFieldsAUTOINC)                                                          #! Found? Yes, sequence.
    #CASE(%pBaseName)                                                           #! BACKEND EXCEPTIONS
    #OF  ('MSSQL')
      #IF(%TraceDetail)
---- IDENTITY: %[3]NFields, %NFieldsKey ('MSSQL')
      #ENDIF
      #SET(%NFieldsAuto , 'IDENTITY (1, 1)')
    #!----------------------------------------------!
    #! RA.2018.06.09: TESTED: This works correctly. !
    #! Double DEFAULT statements should not happen. !
    #!----------------------------------------------!
    #OF  ('SQLANYWHERE')
      #IF(%TraceDetail)
---- IDENTITY: %[3]NFields, %NFieldsKey ('SQLANYWHERE')
      #ENDIF
      #SET(%NFieldsAuto , 'DEFAULT AUTOINCREMENT')
    #ELSE
    #ENDCASE                                                                    #! BACKEND EXCEPTIONS
  #ENDIF                                                                        #! Process sequence
#!
  #!-------------------------------------------------!
  #!-------------------------------------------------!
  #! Deal with the initial values in the dictionary. !
  #!-------------------------------------------------!
  #!-------------------------------------------------!
  #! RA.2018.05.01: Finally got some code here.      !
  #!-------------------------------------------------!
  #!SET(%NFieldsDef  ,'')                                                       #! RA.2019.07.20: Move a BIT earlier in the code 
  #IF(%FieldInitial)
    #!----------------------------------------------------------!
    #! RA.2018.05.01: Check for CLARION things and ignore them. !
    #!----------------------------------------------------------!
    #SET(%nLoc1, 0)
    #SET(%nLoc2, INSTRING(')',%FieldInitial,-1,LEN(CLIP(%FieldInitial))))
    #SET(%nLoc1, %nLoc1 + %nLoc2)
    #SET(%nLoc2, INSTRING('(',%FieldInitial,-1,LEN(CLIP(%FieldInitial))))
    #SET(%nLoc1, %nLoc1 + %nLoc2)
    #SET(%nLoc2, INSTRING(':',%FieldInitial,-1,LEN(CLIP(%FieldInitial))))
    #SET(%nLoc1, %nLoc1 + %nLoc2)
    #IF (%nLoc1 > 0)
      #IF(%TraceDetail)
---- DEFAULT FIELD VALUE: %[3]NFields, %NFieldsKey, FieldInitial="%FieldInitial" [%nLoc1] IGNORED: Seems to be a CLARION DEFAULT
      #ENDIF
    #ELSE
      #IF(%TraceDetail)
---- DEFAULT FIELD VALUE: %[3]NFields, %NFieldsKey, FieldInitial="%FieldInitial"
      #ENDIF
      #CALL(%IsFieldTypeNumeric,%nLoc2,%FieldType)
      #IF(%nLoc2)
        #!SET(%NFieldsNN   , 'NOT NULL')
        #SET(%NFieldsDef  , 'DEFAULT '   & %FieldInitial & ''  )
      #ELSE
        #!SET(%NFieldsNN   , 'NOT NULL')
        #! RA.2019.07.19: Remove the single quotes from string defaults that have them.
        #! That makes sure that only one single set of quotes gets in the SQL statement.
        #SET(%NFieldsDef  , %FieldInitial)
        #CALL(%ReplaceSubString,%NFieldsDef,'''','')      
        #SET(%NFieldsDef  , 'DEFAULT ''' & %NFieldsDef & '''')
        #!SET(%NFieldsDef  , 'DEFAULT ''' & %FieldInitial & '''')
      #ENDIF
    #ENDIF
  #ENDIF
  #!---------------------------------------------------!
  #! RA.2018.05.01: Now for the SQL parameter default. !
  #!---------------------------------------------------!
  #IF(%NFieldOpt3)
    #IF(%TraceDetail)
#!---- 01 CHECK SQL FIELD DEFAULT: [%FieldID] NFieldOpt3="%NFieldOpt3", NFieldsDef="%NFieldsDef" [ Anything in NFieldsDef? ]
    #ENDIF
    #!
    #! --- IMPORTANT ---
    #! RA.2019.07.20: The DEFAULT has to be '' (empty) to be able to generate the GUID/UUID function call.
    #! The Clarion function will set the GUID/UUID from that side and will be in the %FieldInitial.
    #! The SQL function call to the backend to generate on [GUIDKEY] the DEFAULT, #IF(%NFieldsDef='').
    #! We have introduced the '%optGenerateGUID' to support backend GUID/UUID generation by function call.
    #! We might have to RETHINK and/or REWORK the default section with all that was learned.
    #! --- IMPORTANT ---
    #!
    #IF(%NFieldsDef='')
      #IF(VAREXISTS(%ReplaceFunctionSQL)=0)
        #DECLARE(%ReplaceFunctionSQL)
      #ENDIF
      #CALL(%IsInitialFunctionReplaceSQL,%nLoc2,%ReplaceFunctionSQL,%pBaseName,%FieldType,%FieldInitial,%NFieldOpt3,%NFieldOpt2)
      #IF(%nLoc2)
        #!SET(%NFieldsNN     , 'NOT NULL')
        #SET(%NFieldsDef    , 'DEFAULT ' & %ReplaceFunctionSQL & ''  )
      #ELSE
        #CALL(%IsInitialFunctionSQL,%nLoc2,%NFieldOpt3)
        #IF(%nLoc2)
          #!SET(%NFieldsNN   , 'NOT NULL')
          #SET(%NFieldsDef  , 'DEFAULT ' & %NFieldOpt3 & ''  )
        #ENDIF
      #ENDIF
    #ENDIF
    #IF(%TraceDetail)
#!---- 02 CHECK SQL FIELD DEFAULT: NFieldOpt3="%NFieldOpt3", NFieldsDef="%NFieldsDef" 
    #ENDIF
    #! RA.2018.05.03: ??? TESTING
    #CASE(UPPER(%NFieldOpt3))
    #OF  ('[DATE]')
    #OROF('[TIME]')
      #IF(%ReplaceFunctionSQL='')
        #SET(%NFieldOpt3, 0)
      #ENDIF
    #ENDCASE
    #! RA.2018.05.03: ???
    #IF(%NFieldsDef='')
      #CALL(%IsFieldTypeNumeric,%nLoc2,%FieldType)
      #IF(%nLoc2)
        #!SET(%NFieldsNN   , 'NOT NULL')
        #SET(%NFieldsDef  , 'DEFAULT '   & %NFieldOpt3 & ''  )
      #ELSE
        #!SET(%NFieldsNN   , 'NOT NULL')
        #SET(%NFieldsDef  , 'DEFAULT ''' & %NFieldOpt3 & '''')
      #ENDIF
    #ENDIF
    #IF(%TraceDetail)
#!---- 03 CHECK SQL FIELD DEFAULT: NFieldOpt3="%NFieldOpt3", NFieldsDef="%NFieldsDef" 
---- DEFAULT FIELD VALUE: %[3]NFields, %NFieldsKey, NFieldOpt3="%NFieldOpt3", NFieldsDef="%NFieldsDef" 
    #ENDIF
  #ENDIF
  #!---------------------------------------------------------------------------------------------!
  #! RA.2018.06.07: After all that code, some backends do not deal well with the default clause. !
  #! RA.2018.06.07: Reported by Michael Gorman, for the MIMER backend.                           ! 
  #!---------------------------------------------------------------------------------------------!
  #CASE(%pBaseName)                                                           #! BACKEND EXCEPTIONS
  #OF  ('MIMER')
    #SET(%NFieldsDef, '')
    #IF(%TraceDetail)
---- 04 CHECK SQL FIELD DEFAULT: On the backend "%pBaseName" so it was cleared. 
    #ENDIF
  #ENDCASE                                                                    #! BACKEND EXCEPTIONS
  #!-------------------------------------------------!
  #! Deal with the initial values in the dictionary. !
  #!-------------------------------------------------!
  #!-------------------------------------------------!
#!
#!--02 %[90]NFieldsName (%[10]NFieldsType, %[10]NFieldsFormat, %[15]NFieldsTSql, %[10]NFieldsNN, ?)
  #!-------------------------------------------!
  #! DDL: Generate single line or array lines. !
  #! 2017.12.18 - These now just get added to  !
  #! %AFields table to be dumped at the end.   !
  #!-------------------------------------------!
  #SET(%FD1L,%FieldDimension1)                                                  #! Name 1 made shorter
  #SET(%FD2L,%FieldDimension2)                                                  #! Name 2 made shorter
  #SET(%FD3L,%FieldDimension3)                                                  #! Name 3 made shorter
  #SET(%FD4L,%FieldDimension4)                                                  #! Name 4 made shorter
  #!
  #IF(%FD1L>0)                                                                  #! GOT array field?
    #!CALL(%BuildArrayLinesSQL)                                                 #! Array lines of DDL
    #CALL(%BuildArrayLinesSQL,%pBaseName)                                       #! Array lines of DDL
  #ELSE                                                                         #! GOT single field?
    #!CALL(%BuildSingleLineSQL)                                                 #! Single line of DDL
    #CALL(%AddNextTableItem)                                                    #! Single line of DDL
  #ENDIF                                                                        #! DDL done
#ENDFOR
#!
#!CALL(%OutputAFieldsDDL)                                                       #! Generate the DDL lines
#CALL(%OutputAFieldsDDL,%pBaseName)                                             #! Generate the DDL lines
#!---------------------------------------------------------------------
#! RA.2017.12.06 - Consider making an option out of this area.
#! This shows the original table and the larger SQL table if it happens.
#! We can see the before and after tables after processing the table.
#!---------------------------------------------------------------------
#! RA.2017.12.18 - Arrays have been only found in old clarion DCTs (lately).
#! The practice has been slowly disappearing with the increasing use of SQL.
#!---------------------------------------------------------------------
#IF((%TRUE) AND (ITEMS(%NFields) <> ITEMS(%AFields)))
----
---- %NFilesName [%FilePrefix]: FINAL DATA TABLE LIST
----
  #CALL(%FinalDataList)
----
---- %NFilesName [%FilePrefix]: FINAL DUMP TABLE LIST (ARRAY INCLUDED)
----
  #CALL(%FinalDumpList)

#ELSE
#!----
#!---- FINAL DATA TABLE LIST (NO ARRAYS)
#!----
#!  #CALL(%FinalDumpList)
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.18 - Dump the original fields that are valid from the file.
#GROUP(%FinalDataList)
  #FOR(%NFields)
    #SET(%NFieldsNSql,CLIP(%NFieldsName))
    #SET(%NFieldsTSql,CLIP(%NFieldsTSql))
    #SET(%NFieldsAuto,CLIP(%NFieldsAuto))
    #SET(%NFieldsNN  ,CLIP(%NFieldsNN  ))
    #SET(%NFieldsDef ,CLIP(%NFieldsDef ))
---- %[3]NFieldsCount %[30]NFieldsKey, %[30]NFieldsName, %[10]NFieldsType, %[10]NFieldsFormat, %[30]NFieldsNSql, %NFieldsTSql, %NFieldsAuto, %NFieldsNN, %NFieldsDef
  #ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.18 - Dump all the fields including the generated array fields.
#GROUP(%FinalDumpList)
  #FOR(%AFields)
    #SET(%AFieldsNSql,CLIP(%AFieldsNSql))
    #SET(%AFieldsTSql,CLIP(%AFieldsTSql))
    #SET(%AFieldsAuto,CLIP(%AFieldsAuto))
    #SET(%AFieldsNN  ,CLIP(%AFieldsNN  ))
    #SET(%AFieldsDef ,CLIP(%AFieldsDef ))
---- %[3]AFieldsCount %[30]AFieldsKey, %[30]AFieldsName, %[10]AFieldsType, %[10]AFieldsFormat, %[30]AFieldsNSql, %AFieldsTSql, %AFieldsAuto, %AFieldsNN, %AFieldsDef
  #ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! This called group pads a line with spaces to a specific length.
#! There will be at least one space added if the length is invalid.
#GROUP(%PadToLength,*%LineText,%Col)
#DECLARE(%LineLen)
#DECLARE(%AddLen)
#SET(%LineLen,LEN(%LineText))
#IF (%Col < 1)
  #SET(%Col, 1)
#ENDIF
#SET(%AddLen,%Col-%LineLen)
#IF(%AddLen < 1)
  #SET(%AddLen, 1)
#ENDIF
#LOOP,WHILE(%AddLen > 0)
  #SET(%LineText, %LineText & ' ')
  #SET(%AddLen, %AddLen - 1)
#ENDLOOP
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! Original called group to pad a line with spaces. Needs refactoring.
#! Actually needs deprecation after a suitable period of time.
#GROUP(%GoToColumnAndAdd,*%LineText,%Col,%MoreText)
#DECLARE(%LineLen)
#DECLARE(%MoreLen)
#DECLARE(%AddLen)
#SET(%LineLen,LEN(%LineText))
#SET(%MoreLen,LEN(%MoreText))
#!---- %LineLen: %LineText (%Col)
#!---- %MoreLen: %MoreText
#IF (%Col < 1)
  #SET(%Col, 1)
#ENDIF
#!#IF (%Col > 100)
#!  #SET(%Col, 100)
#!#ENDIF
#SET(%AddLen,%Col-%LineLen)
#IF(%AddLen < 1)
  #SET(%AddLen, 1)
#ENDIF
#!---- %AddLen
#!                              0        1         2         3         4         5         6         7         8         9         0
#!                              1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
#SET(%LineText,%LineText & SUB('                                                                                                    ',1,%AddLen) & ' ' & %MoreText)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! Create a formated sql DDL line for the script.
#! Please note that everything exists in the template table fields.
#!---------------------------------------------------------------------
#! RA.2017.12.04 - ARRAY handling: Arrays #CALL this GROUP multiple times.
#! Because of padding make sure that fields are CLIP'ed when we get here.
#! If the array happens to be the last field, handle with %FieldComma
#! before we get to this #GROUP. Check END and NOT END conditions.
#!---------------------------------------------------------------------
#! RA.2017.12.18- This GROUP has been refactored several times to the
#! point that it just formats the DDL that comes from each %AFields array
#! item that gets put into the correct variables. Single place to refactor.
#!---------------------------------------------------------------------
#GROUP(%BuildSingleLineSQL)                                                     #! Single Line of DDL
#!
#SET(%NFieldsNSql,CLIP(%NFieldsNSql))                         #! SQL Name
#SET(%NFieldsTSql,CLIP(%NFieldsTSql))                         #! SQL Type
#SET(%NFieldsAuto,CLIP(%NFieldsAuto))                         #! AUTO_INCREMENT
#SET(%NFieldsNN  ,CLIP(%NFieldsNN  ))                         #! NOT NULL
#SET(%NFieldsDef ,CLIP(%NFieldsDef ))                         #! DEFAULT
#!
#SET(%NFieldLineCount   , %NFieldLineCount + 1)                                 #! RA.2019.07.19: Added
#SET(%NFieldLine        , '')
#! RA.2018.09.03: Cosmetic option created to allow the DDL statements alignment (the default)
#! to be removed and replaced with a single space. Michael Gorman request.
#IF(%optDoSpaceAlign)                                                           #! RA.2018.09.03: Added
#CALL(%PadToLength,%NFieldsNSql,90)
#SET(%NFieldLine,   %NFieldLine & ''  & %NFieldsNSql)         #! SQL Name
#CALL(%PadToLength,%NFieldsTSql,20)
#ELSE                                                                           #! RA.2018.09.03: Added
#SET(%NFieldLine,   %NFieldLine & ' '  & %NFieldsNSql)        #! SQL Name       #! RA.2018.09.03: Added
#ENDIF                                                                          #! RA.2018.09.03: Added
#!
#SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldsTSql)         #! SQL Type
#IF(%NFieldsAuto)
  #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldsAuto)         #! AUTO_INCREMENT
#ENDIF
#IF(%NFieldsNN)
  #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldsNN)           #! NOT NULL
#ENDIF
#IF(%NFieldsDef)
  #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldsDef)          #! DEFAULT
#ENDIF
#!
#SET(%NFieldLine, CLIP(%NFieldLine))
#!
#! RA.2017.12.04 - This logic works with the ARRAY routines that call it.
#! Since a common #GROUP now dumps the DDL line and we format the line 
#! the calling routine has to adjust the %FieldComma variable.
#!
#!---- NFieldOpt1 = "%NFieldOpt1"
#!---- FieldComma = %FieldComma
#! #IF(%FieldComma > 0)
#!   #SET(%FieldComma, %FieldComma - 1)
#!   #IF(SUB(%NFieldOpt1,1,1)='E')                               #! RASQL(END)
#!   %NFieldLine
#!   #ELSE
#!   %NFieldLine ,
#!   #ENDIF
#! #ELSE
#!   %NFieldLine
#! #ENDIF
#IF(%NFieldLineCount = 1)
  %NFieldLine
#ELSE
 ,%NFieldLine
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! Uses original padding function.
#GROUP(%BuildSingleLineSQL1)                                                    #! Single Line of DDL
#!
#SET(%NFieldsNSql,CLIP(%NFieldsNSql))                         #! SQL Name
#SET(%NFieldsTSql,CLIP(%NFieldsTSql))                         #! SQL Type
#SET(%NFieldsAuto,CLIP(%NFieldsAuto))                         #! AUTO_INCREMENT
#SET(%NFieldsNN  ,CLIP(%NFieldsNN  ))                         #! NOT NULL
#SET(%NFieldsDef ,CLIP(%NFieldsDef ))                         #! DEFAULT
#!
#SET(%NFieldLine,   '')
#SET(%NFieldLine,   %NFieldLine & ''  & %NFieldsNSql)         #! SQL Name
#CALL(%GoToColumnAndAdd,%NFieldLine, 90,%NFieldsTSql)
#!#SET(%NFieldLine, %NFieldLine & ' ' & %NFieldsTSql)         #! SQL Type
#IF(%NFieldsAuto)
  #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldsAuto)         #! AUTO_INCREMENT
#ENDIF
#!#IF(%NFieldsNN)
#!  #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldsNN)         #! NOT NULL
#!#ENDIF
#CALL(%GoToColumnAndAdd,%NFieldLine,110,%NFieldsNN)
#IF(%NFieldsDef)
  #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldsDef)          #! DEFAULT
#ENDIF
#!
#SET(%NFieldLine, CLIP(%NFieldLine))
#!
#IF(%FieldComma > 0)
  #SET(%FieldComma, %FieldComma - 1)
  #IF(SUB(%NFieldOpt1,1,1)='E')                               #! RASQL(END)
  %NFieldLine
  #ELSE
  %NFieldLine ,
  #ENDIF
#ELSE
  %NFieldLine
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.17 - Tested a number of ways. The complete field table %AFields has all
#! fields including the array generated ones. At this time the DDL gets generated for
#! the table create. Please note that the tables and the fields have a sequence number
#! generated. This generation will be necessary for the keys and relations also.
#!---------------------------------------------------------------------
#! RA.2017.12.06 - Did the more complete aproach and built a table that contains the
#! original fields and additional field array items. At the end of this process you
#! will have a table with no arrays but with all the SQL necessary fields.
#! And while in this day and age there should be no databases with arrays, there might
#! be still some old Clarion databases that might need conversion to a new form.
#!---------------------------------------------------------------------
#! RA.2017.11.28 - The array support was originally added to deal with dictionaries
#! that had array of fiels (such as weekly, monthly, and yearly accumulators) but that
#! is not necessarily a good design for tables. This area might need additional after
#! the refactoring since the dictionaries tested have been designed for SQL tables.
#! Because of this better design it has been a while since arrays have come through.
#! When we start here we have an SQL field line item in the template table with a base
#! field name. If we have to build additional generated items with new names we might
#! want to consider (in the future) building the name up and adding all the additional
#! names to the field table so at the end of the generate we have all the names there.
#!---------------------------------------------------------------------
#!GROUP(%BuildArrayLinesSQL)                                                    #! Array Lines of DDL
#GROUP(%BuildArrayLinesSQL,%pBaseName)                                          #! Array Lines of DDL
#! Save the values from the last template table field. Will re-use these defintitions.
#SET(%NFieldNSql,%NFieldsNSql)                                #! Field SQL Name
#SET(%NFieldTSql,%NFieldsTSql)                                #! Field SQL Type
#SET(%NFieldAuto,%NFieldsAuto)                                #! Field AUTO_INCREMENT
#SET(%NFieldNN  ,%NFieldsNN)                                  #! Field NOT NULL
#SET(%NFieldDef ,%NFieldsDef)                                 #! Field default
#!--AR %[30]NFieldsKey %NFieldsType, %NFieldsFormat, (%FD1L)(%FD2L)(%FD3L)(%FD4L), %NFieldsTSql, ?
#!---- ARRAY CODE DOES NOT EXIST
#!----------------------------------------------------------------------------!
#! If we got an array field at this point, we do not have arrays over groups. !
#! We have simple array fields and must add additional fields to the table.   !
#!----------------------------------------------------------------------------!
#IF(%FD1L>0)                                                  #! We GOT array field
  #SET(%FldArray,'')                                          #! Clear created name
  #SET(%FD1S,'')                                              #! Number dimension 1
  #SET(%FD2S,'')                                              #! Number dimension 2
  #SET(%FD3S,'')                                              #! Number dimension 3
  #SET(%FD4S,'')                                              #! Number dimension 4
  #!
  #SET(%DimCount,1)                                           #! Got dimension 1
  #IF(%FD2L>0)                                                #! Dimension 2?
    #SET(%DimCount,%DimCount+1)                               #! Got dimension 2
    #IF(%FD3L>0)                                              #! Dimension 3?
      #SET(%DimCount,%DimCount+1)                             #! Got dimension 3
      #IF(%FD4L>0)                                            #! Dimension 4?
        #SET(%DimCount,%DimCount+1)                           #! Got dimension 4
      #ENDIF                                                  #! Dimension 4?
    #ENDIF                                                    #! Dimension 3?
  #ENDIF                                                      #! Dimension 2?
#ENDIF                                                        #! We GOT array field
#!--AR ARRAYS TO PROCESS: %DimCount => (%FD1L)(%FD2L)(%FD3L)(%FD4L)
#! RA.2017.12.04 - Process each level with one #GROUP. Logic is easier to follow.
#CASE(%DimCount)                                              #! Logic on dimension
#OF(1)                                                        #! A 1 dimension array
  #CALL(%BuildArray01Dimension)
#OF(2)                                                        #! A 2 dimension array
  #CALL(%BuildArray02Dimension)
#OF(3)                                                        #! A 3 dimension array
  #CALL(%BuildArray03Dimension)
#OF(4)                                                        #! A 4 dimension array
  #CALL(%BuildArray04Dimension)
#ENDCASE                                                      #! Logic on dimension
#! RA.2017.12.05 - After all this is done, clean up after yourself.
#!SET(%NFieldsNSql, %NFieldsName)                              #! Original Field Name
#!--ARN %[3]NFieldsCount NFieldsNSql: %NFieldsNSql <= NFieldsName: %NFieldsName
#!--ARA %[3]AFieldsCount AFieldsNSql: %AFieldsNSql <= AFieldsName: %AFieldsName
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.15 - Added the Len/Dec fields for the numeric fields.
#! RA.2017.12.04 - Build up the table for ALL items so I can output to a CSV file.
#! RA.2017.12.05 - The COUNT field contains the actual ID that is generated.
#GROUP(%AddNextTableItem)
#ADD(%AFields,ITEMS(%AFields) + 1)
#SET(%AFieldsCount ,ITEMS(%AFields))
#SET(%AFieldsKey   ,%NFieldsKey)                              #! Clarion: Prefix:FieldName
#SET(%AFieldsName  ,%NFieldsName)                             #! Clarion: FieldName
#SET(%AFieldsType  ,%NFieldsType)                             #! Clarion: FieldType
#SET(%AFieldsFormat,%NFieldsFormat)                           #! Clarion: FieldFormat
#SET(%AFieldsDatLen,%NFieldsDatLen)                           #! Clarion: Data Length             - RA.2018.04.15: Added
#SET(%AFieldsDatDec,%NFieldsDatDec)                           #! Clarion: Data Decimals           - RA.2018.04.15: Added
#SET(%AFieldsDspLen,%NFieldsDspLen)                           #! Clarion: Display Length          - RA.2018.04.15: Added
#SET(%AFieldsDspDec,%NFieldsDspDec)                           #! Clarion: Display Decimals        - RA.2018.04.15: Added
#SET(%AFieldsOpts  ,%NFieldsOpts)                             #! Clarion: %FieldUserOptions       - RA.2019.04.30: Added
#SET(%AFieldsNSql  ,CLIP(%NFieldsNSql))                       #! Field SQL Name
#SET(%AFieldsTSql  ,CLIP(%NFieldsTSql))                       #! Field SQL Type
#SET(%AFieldsAuto  ,CLIP(%NFieldsAuto))                       #! Field AUTO_INCREMENT
#SET(%AFieldsNN    ,CLIP(%NFieldsNN  ))                       #! Field NOT NULL
#SET(%AFieldsDef   ,CLIP(%NFieldsDef ))                       #! Field default
#MESSAGE('AddNextTableItem(' & ITEMS(%AFields) & '): ' & %NFieldsKey & ' => ' & %AFieldsNSql & '', 2)
#!---- AddNextTableItem: %AFieldsCount, %AFieldsKey, %AFieldsType, %AFieldsFormat, %AFieldsNSql, %AFieldsTSql
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.06 - Tested
#GROUP(%BuildArray01Dimension)                                                  #! Array Lines of DDL
#!--AR 01 Dimension [%DimCount]
#LOOP,FOR(%FD1I,1,%FD1L)
  #SET(%FD1S,'_' & %FD1I)
  #SET(%FldArray,%NFieldsName & %FD1S)
  #SET(%NFieldsNSql,%FldArray)
#!
#!---- BuildArray01Dimension: (%FD1S)(%FD2S)(%FD3S)(%FD4S) <=> %FldArray [%NFieldsNSql]
#!
  #IF(%FD1I=%FD1L)                                              #! Last field?
#!-- %FldArray
    #IF(%FieldComma > 0)
      #SET(%FieldComma, %FieldComma - 1)
      #IF(SUB(%NFieldOpt1,1,1)='E')                             #! RASQL(END)
#!  %NFieldLine
#!SET(%FieldComma, 0)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
      #ELSE
#!  %NFieldLine ,
#!SET(%FieldComma, %FieldComma + 1)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
      #ENDIF
    #ELSE
#!  %NFieldLine
#!SET(%FieldComma, 0)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
    #ENDIF
  #ELSE                                                         #! Not last field
#!  %NFieldLine ,
#!SET(%FieldComma, %FieldComma + 1)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
  #ENDIF                                                        #! Just dump stuff
#!
#!
#ENDLOOP
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.06 - Tested
#GROUP(%BuildArray02Dimension)                                                  #! Array Lines of DDL
#!--AR 02 Dimension [%DimCount]
#LOOP,FOR(%FD1I,1,%FD1L)
  #SET(%FD1S,'_' & %FD1I)
  #LOOP,FOR(%FD2I,1,%FD2L)
    #SET(%FD2S,'_' & %FD2I)
    #SET(%FldArray,%NFieldsName & %FD1S & %FD2S)
    #SET(%NFieldsNSql,%FldArray)
#!
#!---- BuildArray02Dimension: (%FD1S)(%FD2S)(%FD3S)(%FD4S) <=> %FldArray [%NFieldsNSql]
#!
    #IF((%FD1I=%FD1L)AND(%FD2I=%FD2L))                          #! Last field?
#!-- %FldArray
      #IF(%FieldComma > 0)
        #SET(%FieldComma, %FieldComma - 1)
        #IF(SUB(%NFieldOpt1,1,1)='E')                           #! RASQL(END)
#!  %NFieldLine
#!SET(%FieldComma, 0)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
        #ELSE
#!  %NFieldLine ,
#!SET(%FieldComma, %FieldComma + 1)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
        #ENDIF
      #ELSE
#!  %NFieldLine
#!SET(%FieldComma, 0)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
      #ENDIF
    #ELSE                                                       #! Not last field
#!  %NFieldLine ,
#!SET(%FieldComma, %FieldComma + 1)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
    #ENDIF                                                      #! Just dump stuff
#!
#!
  #ENDLOOP
#ENDLOOP
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.06 - Tested
#GROUP(%BuildArray03Dimension)                                                  #! Array Lines of DDL
#!--AR 03 Dimension [%DimCount]
#LOOP,FOR(%FD1I,1,%FD1L)
  #SET(%FD1S,'_' & %FD1I)
  #LOOP,FOR(%FD2I,1,%FD2L)
    #SET(%FD2S,'_' & %FD2I)
    #LOOP,FOR(%FD3I,1,%FD3L)
      #SET(%FD3S,'_' & %FD3I)
      #SET(%FldArray,%NFieldsName & %FD1S & %FD2S & %FD3S)
      #SET(%NFieldsNSql,%FldArray)
#!
#!---- BuildArray03Dimension: (%FD1S)(%FD2S)(%FD3S)(%FD4S) <=> %FldArray [%NFieldsNSql]
#!
      #IF((%FD1I=%FD1L)AND(%FD2I=%FD2L)AND(%FD3I=%FD3L))        #! Last field?
#!-- %FldArray
        #IF(%FieldComma > 0)
          #SET(%FieldComma, %FieldComma - 1)
          #IF(SUB(%NFieldOpt1,1,1)='E')                         #! RASQL(END)
#!  %NFieldLine
#!SET(%FieldComma, 0)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
          #ELSE
#!  %NFieldLine ,
#!SET(%FieldComma, %FieldComma + 1)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
          #ENDIF
        #ELSE
#!  %NFieldLine
#!SET(%FieldComma, 0)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
        #ENDIF
      #ELSE                                                     #! Not last field
#!  %NFieldLine ,
#!SET(%FieldComma, %FieldComma + 1)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
      #ENDIF                                                    #! Just dump stuff
#!
#!
    #ENDLOOP
  #ENDLOOP
#ENDLOOP
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.05 - Tested
#GROUP(%BuildArray04Dimension)                                                  #! Array Lines of DDL
#!--AR 04 Dimension [%DimCount]
#LOOP,FOR(%FD1I,1,%FD1L)
  #SET(%FD1S,'_' & %FD1I)
  #LOOP,FOR(%FD2I,1,%FD2L)
    #SET(%FD2S,'_' & %FD2I)
    #LOOP,FOR(%FD3I,1,%FD3L)
      #SET(%FD3S,'_' & %FD3I)
      #LOOP,FOR(%FD4I,1,%FD4L)
        #SET(%FD4S,'_' & %FD4I)
        #SET(%FldArray,%NFieldNSql & %FD1S & %FD2S & %FD3S & %FD4S)
        #SET(%NFieldsNSql,%FldArray)
#!
#!---- BuildArray04Dimension: (%FD1S)(%FD2S)(%FD3S)(%FD4S) <=> %FldArray [%NFieldsNSql]
#!
        #IF((%FD1I=%FD1L)AND(%FD2I=%FD2L)AND(%FD3I=%FD3L)AND(%FD4I=%FD4L)) #! Last field?
#!-- %FldArray
          #IF(%FieldComma > 0)
            #SET(%FieldComma, %FieldComma - 1)
            #IF(SUB(%NFieldOpt1,1,1)='E')                        #! RASQL(END)
#!  %NFieldLine
#!SET(%FieldComma, 0)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
            #ELSE
#!  %NFieldLine ,
#!SET(%FieldComma, %FieldComma + 1)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
            #ENDIF
          #ELSE
#!  %NFieldLine
#!SET(%FieldComma, 0)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
          #ENDIF
        #ELSE                                                   #! Not last field
#!  %NFieldLine ,
#!SET(%FieldComma, %FieldComma + 1)
#!CALL(%BuildSingleLineSQL)
#CALL(%AddNextTableItem)                                        #! Single line of DDL
        #ENDIF                                                  #! Just dump stuff
#!
#!
      #ENDLOOP
    #ENDLOOP
  #ENDLOOP
#ENDLOOP
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%OutputNFilesDDL)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%OutputNFilesCSV)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2018.04.25 - Implement "Table" vs "File" names option.                    DO BETTER HERE !!!!
#! RA.2018.04.07 - Pass %BaseName as a parameter
#! RA.2017.12.12 - Process the whole table after creation.
#! After you have built everything you can dump it out as DDL script.
#!GROUP(%OutputAFieldsDDL)
#GROUP(%OutputAFieldsDDL,%pBaseName)
#!#FOR(%NFiles)
  #FIX(%File,%NFilesName)
  #INSERT(%TableNameComments,%pBaseName)                                        #! OPTION: Table name comments
  #SET(%TheTable,'')                                                            #! RA.2018.04.25: Default nothing
  #CALL(%SetupTheTable,%TheTable,%pBaseName,%NFilesCount,%optDefineNamesEnable,%optDefineNames,%NFilesName,%NFilesFullPath,%optNameOwnerUse,%NameOwner,%NameDatabase)
  #SET(%FieldComma, ITEMS(%AFields) - 1)                                        #! How many commas do I need?
#!
CREATE TABLE %TheTable (
#!
  #CASE(%pBaseName)                                                             #! BACKEND EXCEPTIONS
  #OF  ('METABASE')                                                             #! RA.2017.12.20: CREATE TABLE
  #OROF('MIMER')                                                                #! RA.2017.12.20: CREATE TABLE
  #OROF('MSSQL')                                                                #! RA.2018.04.21: CREATE TABLE
  #OROF('POSTGRESQL')                                                           #! RA.2018.06.06: CREATE TABLE
  #OROF('SQLANYWHERE')                                                          #! RA.2018.06.08: CREATE TABLE
  #OROF('MYSQL')                                                                #! RA.2018.06.14: CREATE TABLE
  #OROF('ORACLE')
  #OROF('DB2')
    #SET(%NFieldLineCount   , 0)                                                #! RA.2019.07.19: Added
    #FOR(%AFields)
      #SET(%NFieldsNSql,CLIP(%AFieldsNSql))
      #SET(%NFieldsTSql,CLIP(%AFieldsTSql))
      #SET(%NFieldsAuto,CLIP(%AFieldsAuto))
      #SET(%NFieldsNN  ,CLIP(%AFieldsNN  ))
      #SET(%NFieldsDef ,CLIP(%AFieldsDef ))
#!--DDL-- %[3]AFieldsCount %[30]AFieldsKey %[10]AFieldsType, %[10]AFieldsFormat, %[30]NFieldsNSql, %NFieldsTSql, %NFieldsAuto, %NFieldsNN, %NFieldsDef
      #CALL(%BuildSingleLineSQL)
    #ENDFOR
  #ELSE
-- [GENERATE TABLE CREATE]
  #ENDCASE                                                                      #! BACKEND EXCEPTIONS
#!
)
#!----------------------------------------------------------------------------!
#! RA.2018.04.21: Some backends have options for the TABLES that are created. !
#! RA.2017.12.20: Make sure this is explicit for the backend.                 !
#!----------------------------------------------------------------------------!
  #CASE(%pBaseName)                                                             #! BACKEND EXCEPTIONS
  #OF  ('METABASE')
  #OROF('MIMER')
  #OROF('MSSQL')
  #OROF('POSTGRESQL')
  #OROF('SQLANYWHERE')
  #OROF('MYSQL')
  #OROF('ORACLE')
  #OROF('DB2')
  #ENDCASE                                                                      #! BACKEND EXCEPTIONS
#!
#CALL(%TerminatorTerminates,%pBaseName)                                         #! RA.2018.04.21.SAT: Refactor code
#!
#! RA.2018.04.08 - If no comments generate a space for the tables. Easier to read.
  #CASE(%pBaseName)                                                             #! BACKEND EXCEPTIONS
  #OF  ('MIMER')

  #ENDCASE                                                                      #! BACKEND EXCEPTIONS
#!#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%OutputAFieldsCSV)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2017.12.21 -  Put into its own group so we can eliminate duplicated code.
#! By defined convention a primary key is one numeric field that can be sequenced
#! or auto-incremented depending on your terminology. They are specific per backend.
#GROUP(%HasOnePrimaryKey)
#!-----------------------------------------------------------!
#! Check to see that every FILE has at least one PRIMARY key !
#!-----------------------------------------------------------!
#SET(%NKeyCount, 0)                                                             #! Has no keys
#SET(%NKeyPrimary, 0)                                                           #! Has no primary keys
#SET(%NKeyPrimaryValidSeq, 0)                                                   #! No valid sequence, numeric only
#!
#IF(ITEMS(%Key) > 0)                                                            #! IF we have keys,
  #FOR(%Key)                                                                    #! THEN process FOR(%Key)
#!---- 00: File="%File" == Key="%Key", KeyPrimary="%KeyPrimary", KeyAuto="%KeyAuto"
    #INSERT(%GetKeyOptions)
    #IF(SUB(%NKeyOpt1,1,1)='N')                                                 #! Ignore this key
      #IF(%TraceDetail)
---- IGNORED: "%File-%Key" [Key options say NO]
      #ENDIF
      #CYCLE
    #ENDIF
    #SET(%NKeyCount, %NKeyCount + 1)                                            #! Count the keys
#!---->>>NKeyCount = %NKeyCount
    #IF(%KeyPrimary>0)
      #SET(%NKeyPrimary, %NKeyPrimary + 1)                                      #! Count the primary keys
#!---->>>NKeyPrimary = %NKeyPrimary
      #!
      #! RA.2017.12.23 - There can only be one primary key with only ane integer field
      #!                 for a sequence to be valid. Otherwise, NOT a valid sequence.
      #IF(ITEMS(%KeyField)=1)                                                   #! [?=1]
        #SET(%NFilesPKeyName,%KeyID)                                            #! Table Primary Key Name
        #FOR(%KeyField)                                                         #! Beginning FOR(%KeyField)
          #FIX(%Field,%KeyField)
          #SET(%NFilesPKeyField,%FieldID)                                       #! Table Primary Field Name
#!----??? Key="%Key", KeyField="%KeyField", FieldType="%FieldType"
          #! RA.2018.04.29: Build up the PRIMARY KEY field table (needed for the NOT-NULL logic).
          #ADD(%NFieldsPRIMARY,%KeyField)
          #!-----------------------------
          #! RA.2017.12.21: The primary field type has to be numeric to be a valid sequence (auto-increment).
          #CASE(%FieldType)                                                     #! Invalid field types
          #OF  ('BLOB')
          #OROF('MEMO')
          #OROF('DATE')
          #OROF('TIME')
          #OROF('STRING')
          #OROF('CSTRING')
          #OROF('PSTRING')
            #IF(%TraceDetail)
#!---- IGNORED SEQUENCE: "%File-%Key-%KeyField-%FieldType" [Not a valid field type]
            #ENDIF
          #ELSE                                                                 #! Valid sequence field type
            #SET(%NKeyPrimaryValidSeq, 1)                                       #! Valid sequence, numeric only
            #SET(%NFilesSeqField,%FieldID)                                      #! Field to DEFAULT to SEQUENCE
          #ENDCASE
        #ENDFOR                                                                 #! Ending FOR(%KeyField)
      #ENDIF                                                                    #! [?=1]
      #!
    #ENDIF
  #ENDFOR
#ENDIF
#!
#IF(~%NKeyCount)                                                                #! ERROR: No Keys exist
---- WARNING: "%File" has no KEYS defined
#ENDIF
#IF(~%NKeyPrimary)                                                              #! ERROR: No Primary Key
---- WARNING: "%File" has no PRIMARY KEY defined
#ENDIF
#IF(%NKeyPrimary > 1)                                                           #! ERROR: More than one Primary Key
  #SET(%NKeyPrimaryValidSeq, 0)                                                 #! No Valid sequence to create
---- WARNING: "%File" has multiple PRIMARY KEYS defined
#ENDIF
#!
#CALL(%BuildQualifiedIndexes)                                                   #! Just use Indexes you need
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2019.08.10: Handle [???] External in the fields for indexes [GUID and Time Stamp fields]
#! RA.2018.11.09: No AUTO-INCREMENT flag found (And you need to generate a ROW level AUTO-INCREMENT)
#! Mr. Michael Gorman removed all the auto-increment flags from his primary keys (SURPRISE!).
#! He is having the BACKEND generate the auto-increment so the DCT does not have any definition.
#! That caused the ROW level auto-increment generation to fail for MSSQL (and SQLANYWHERE) since that
#! generation is based out of the AUTO-INCREMENT field that is filled when you set the auto-increment flag.
#! Figured out a way to build the items in the correct tables since there are rules for auto-incrementing.
#! Tested by generating the IDENTITY (1, 1) in the create table for MSSQL.
#! Verified that MIMER sequence was being generated correctly.
#! The %TraceDetail flag shows WARNING statements that will come out when the AUTO-INCREMENT flag is missing.
#! The changes to the template code were just in this #GROUP(). Glad that I rebuilt the code. 
#!---------------------------------------------------------------------
#GROUP(%BuildQualifiedIndexes)                                                  #! Just use Indexes you need
#!DECLARE(%NKeys),MULTI                  #!,UNIQUE
#!DECLARE(%NKeysCount          ,%NKeys)  #! ID: Key Count
#!DECLARE(%NKeysKey            ,%NKeys)  #! Prefix:KeyName
#!DECLARE(%NKeysName           ,%NKeys)  #! Key Name
#!DECLARE(%NKeysType           ,%NKeys)  #! Key Type
#!DECLARE(%NKeysFlagPri        ,%NKeys)  #! Key is: Primary
#!DECLARE(%NKeysFlagSeq        ,%NKeys)  #! Key is: Sequence
#!DECLARE(%NKeysFlagUni        ,%NKeys)  #! Key is: Unique
#!DECLARE(%NkeysAutoField      ,%NKeys)  #! Auto-Inc Field Name
#!DECLARE(%NKeysFieldCount     ,%NKeys)  #! Number of Fields
#!DECLARE(%NKeysField01        ,%NKeys)  #! Field 01
#!DECLARE(%NKeysField02        ,%NKeys)  #! Field 02
#!DECLARE(%NKeysField03        ,%NKeys)  #! Field 03
#!DECLARE(%NKeysField04        ,%NKeys)  #! Field 04
#!DECLARE(%NKeysField05        ,%NKeys)  #! Field 05
#!DECLARE(%NKeysField06        ,%NKeys)  #! Field 06
#!DECLARE(%NKeysField07        ,%NKeys)  #! Field 07
#!DECLARE(%NKeysField08        ,%NKeys)  #! Field 08
#!DECLARE(%NKeysField09        ,%NKeys)  #! Field 09
#!DECLARE(%NKeysSort01         ,%NKeys)  #! Sort Order 01
#!DECLARE(%NKeysSort02         ,%NKeys)  #! Sort Order 02
#!DECLARE(%NKeysSort03         ,%NKeys)  #! Sort Order 03
#!DECLARE(%NKeysSort04         ,%NKeys)  #! Sort Order 04
#!DECLARE(%NKeysSort05         ,%NKeys)  #! Sort Order 05
#!DECLARE(%NKeysSort06         ,%NKeys)  #! Sort Order 06
#!DECLARE(%NKeysSort07         ,%NKeys)  #! Sort Order 07
#!DECLARE(%NKeysSort08         ,%NKeys)  #! Sort Order 08
#!DECLARE(%NKeysSort09         ,%NKeys)  #! Sort Order 09
#FREE(%NKeys)                                                                   #! Clear the key table
#!
#IF(ITEMS(%Key) > 0)                                                            #! IF we have keys,
  #FOR(%Key)                                                                    #! THEN process FOR(%Key)
    #INSERT(%GetKeyOptions)
    #IF(SUB(%NKeyOpt1,1,1)='N')                                                 #! Ignore this key
      #IF(%TraceDetail)
---- IGNORED: "%File-%Key" [Key options say NO]
      #ENDIF
      #CYCLE
    #ENDIF
    #!CLEAR(%NKeys)
    #ADD(%NKeys               , ITEMS(%NKeys) + 1)                              #! This KEY is processed
    #SET(%NKeysCount          , ITEMS(%NKeys))                                  #! Key ID number
    #SET(%NKeysKey            , %Key)                                           #! Key Prefix:Name
    #SET(%NKeysName           , %KeyID)                                         #! Key Name
    #CALL(%SetupTheKey,%NKeysName,%BaseName,%KeyID,%KeyName)                   #! RA.2019.08.10: Handle External Key Name
    #SET(%NKeysType           , %KeyIndex)                                      #! Key Type
    #SET(%NKeysFlagPri        , 'N')                                            #! Key is: Primary
    #SET(%NKeysFlagSeq        , 'N')                                            #! Key is: Sequence
    #SET(%NKeysFlagUni        , 'N')                                            #! Key is: Unique
    #SET(%NkeysAutoField      , %KeyAuto)                                       #! Auto-Inc Field Name
    #SET(%NKeysFieldCount     , ITEMS(%KeyField))                               #! Key fields count
    #!
    #IF(%KeyPrimary)
      #SET(%NKeysFlagPri      , 'Y')                                            #! Key is: Primary
      #IF(%NKeysFieldCount=1)
        #FOR(%KeyField)                                                         #! Beginning FOR(%KeyField)
          #FIX(%Field,%KeyField)
          #CASE(%FieldType)                                                     #! Invalid field types
          #OF  ('BLOB')
          #OROF('MEMO')
          #OROF('DATE')
          #OROF('TIME')
          #OROF('STRING')
          #OROF('CSTRING')
          #OROF('PSTRING')
            #IF(%TraceDetail)
#!---- IGNORED SEQUENCE: "%File-%Key-%KeyField-%FieldType" [Not a valid field type]
            #ENDIF
          #ELSE                                                                 #! Valid sequence field type
            #SET(%NKeysFlagSeq  , 'Y')                                          #! Key is: Sequence
            #!
            #! RA.2018.11.09: No AUTO-INCREMENT flag found (And you need to generate a ROW level AUTO-INCREMENT)
            #IF(~%NkeysAutoField)
              #IF(%TraceDetail)
---- WARNING: "%NKeysKey" has no AUTO-INCREMENT flag set (BACKEND provides AUTO-INCREMENT)
---- WARNING: "%Field" is the current field being processed
              #ENDIF 
              #SET(%NkeysAutoField      , %Field)                               #! Auto-Inc Field Name
              #ADD(%NFieldsAUTOINC      , %Field)                               #! Add to the Auto-Inc table   
            #ENDIF
            #!
          #ENDCASE
        #ENDFOR                                                                 #! Ending FOR(%KeyField)
      #ENDIF
    #ENDIF
    #!
    #IF(~%KeyDuplicate)
      #SET(%NKeysFlagUni      , 'Y')                                            #! Key is: Unique
    #ENDIF
    #!
    #SET(%NKeyFieldIndex      , 0)
    #FOR(%KeyField)                                                             #! Beginning FOR(%KeyField)
      #FIX(%Field,%KeyField)
      #SET(%NKeyFieldIndex, %NKeyFieldIndex + 1)
      #CALL(%BuildQualifiedIndexFields)
    #ENDFOR                                                                     #! Ending FOR(%KeyField)
  #ENDFOR                                                                       #! Processed all FOR(%Key)
  #!
  #IF(%TraceDetail)
    #FOR(%NKeys)
---- %[3]NKeysCount, %[10]NKeysType, %NKeysKey  #!, %NKeysName,
---- %[3]NKeysCount, Primary=%[1]NKeysFlagPri, Sequence=%[1]NKeysFlagSeq, Unique=%[1]NKeysFlagUni, %[3]NKeysFieldCount, "%NkeysAutoField"
---- %[3]NKeysCount, 01:"%NKeysField01", 02:"%NKeysField02", 03:"%NKeysField03", 04:"%NKeysField04", 05:"%NKeysField05", 06:"%NKeysField06", 07:"%NKeysField07", 08:"%NKeysField08", 09:"%NKeysField09"
---- %[3]NKeysCount, 01:"%NKeysSort01", 02:"%NKeysSort02", 03:"%NKeysSort03", 04:"%NKeysSort04", 05:"%NKeysSort05", 06:"%NKeysSort06", 07:"%NKeysSort07", 08:"%NKeysSort08", 09:"%NKeysSort09"
----
    #ENDFOR
  #ENDIF
  #!
#ENDIF                                                                          #! We have keys
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2019.08.10: Handle [???] External in the fields for indexes [GUID and Time Stamp fields]
#! RA.2018.04.16: Change to ANSI standard compatible DDL keyword.
#! #CALL(%GiveMeSortOrder, %NKeysSort01 -> 09, %NKeysSort01 -> 09)
#GROUP(%BuildQualifiedIndexFields)
#CASE(%NKeyFieldIndex)
#OF(1)
  #SET(%NKeysField01, %FieldID)
  #CALL(%SetupTheField,%NKeysField01,%BaseName,%FieldID,%FieldName)            #! RA.2019.08.10: Handle EXTERNAL fields
  #SET(%NKeysSort01, %KeyFieldSequence)
  #CALL(%GiveMeSortOrder, %NKeysSort01, %NKeysSort01)
#OF(2)
  #SET(%NKeysField02, %FieldID)
  #CALL(%SetupTheField,%NKeysField02,%BaseName,%FieldID,%FieldName)            #! RA.2019.08.10: Handle EXTERNAL fields
  #SET(%NKeysSort02, %KeyFieldSequence)
  #CALL(%GiveMeSortOrder, %NKeysSort02, %NKeysSort02)
#OF(3)
  #SET(%NKeysField03, %FieldID)
  #CALL(%SetupTheField,%NKeysField03,%BaseName,%FieldID,%FieldName)            #! RA.2019.08.10: Handle EXTERNAL fields
  #SET(%NKeysSort03, %KeyFieldSequence)
  #CALL(%GiveMeSortOrder, %NKeysSort03, %NKeysSort03)
#OF(4)
  #SET(%NKeysField04, %FieldID)
  #CALL(%SetupTheField,%NKeysField04,%BaseName,%FieldID,%FieldName)            #! RA.2019.08.10: Handle EXTERNAL fields
  #SET(%NKeysSort04, %KeyFieldSequence)
  #CALL(%GiveMeSortOrder, %NKeysSort04, %NKeysSort04)
#OF(5)
  #SET(%NKeysField05, %FieldID)
  #CALL(%SetupTheField,%NKeysField05,%BaseName,%FieldID,%FieldName)            #! RA.2019.08.10: Handle EXTERNAL fields
  #SET(%NKeysSort05, %KeyFieldSequence)
  #CALL(%GiveMeSortOrder, %NKeysSort05, %NKeysSort05)
#OF(6)
  #SET(%NKeysField06, %FieldID)
  #CALL(%SetupTheField,%NKeysField06,%BaseName,%FieldID,%FieldName)            #! RA.2019.08.10: Handle EXTERNAL fields
  #SET(%NKeysSort06, %KeyFieldSequence)
  #CALL(%GiveMeSortOrder, %NKeysSort06, %NKeysSort06)
#OF(7)
  #SET(%NKeysField07, %FieldID)
  #CALL(%SetupTheField,%NKeysField07,%BaseName,%FieldID,%FieldName)            #! RA.2019.08.10: Handle EXTERNAL fields
  #SET(%NKeysSort07, %KeyFieldSequence)
  #CALL(%GiveMeSortOrder, %NKeysSort07, %NKeysSort07)
#OF(8)
  #SET(%NKeysField08, %FieldID)
  #CALL(%SetupTheField,%NKeysField08,%BaseName,%FieldID,%FieldName)            #! RA.2019.08.10: Handle EXTERNAL fields
  #SET(%NKeysSort08, %KeyFieldSequence)
  #CALL(%GiveMeSortOrder, %NKeysSort08, %NKeysSort08)
#OF(9)
  #SET(%NKeysField09, %FieldID)
  #CALL(%SetupTheField,%NKeysField09,%BaseName,%FieldID,%FieldName)            #! RA.2019.08.10: Handle EXTERNAL fields
  #SET(%NKeysSort09, %KeyFieldSequence)
  #CALL(%GiveMeSortOrder, %NKeysSort09, %NKeysSort09)
#ENDCASE
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%RemovePrefix,%pChar,*%pStr),AUTO
#DECLARE(%n1)
#DECLARE(%n2)
#SET(%n1,INSTRING(%pChar,%pStr,1,1))
#SET(%n2,LEN(%pStr))
#SET(%pStr,SUB(%pStr,%n1+1,%n2-%n1))
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2019.08.10: Handle [???] External in the fields for relationships [GUID and Time Stamp fields]
#! RA.2018.06.03 - Added the backend type. Options restricted by backend.
#! RA.2018.01.01 - Brand new year. Let do a brand new #GROUP for relations.
#! We are going to go from father to child on this process. That will make
#! it easier to deal with the fact that in cases the child key is longer.
#! We do have to create the intermediate table so we can output later.
#GROUP(%BuildQualifiedRelations,%pBaseName)
#FREE(%NRelas)
#!
#IF(ITEMS(%Relation) > 0)
  #FOR(%Relation)
#!--00 %NFilesName, %FileRelationType, %Relation, %RelationPrefix, %RelationAlias
    #INSERT(%GetRelationOptions)                                                #! Get this relation options
    #IF(SUB(%NRelationOpt1,1,1)='N')                                            #! Ignore this relation
      #IF(%TraceDetail)
---- IGNORED: "%File-%Relation" [Relation options say NO]
      #ENDIF
      #CYCLE
    #ENDIF
    #IF(%FileRelationType = 'MANY:1')
      #IF(%TraceDetail)
---- IGNORED: "%File-%Relation" [Relation type is "%FileRelationType"]
      #ENDIF
      #CYCLE
    #ENDIF
    #IF(%RelationAlias)
      #IF(%TraceDetail)
---- IGNORED: "%File-%Relation" ["%RelationAlias" is the ALIASED name]
      #ENDIF
      #CYCLE
    #ENDIF
    #SET(%NRelaFound, %TRUE)
    #ADD(%NRelas              , ITEMS(%NRelas) + 1)                             #! This RELATION is processed
    #SET(%NRelasCount         , ITEMS(%NRelas))                                 #! Relation ID number
    #SET(%NRelasFileFromKey   , %FilePrefix & ':' & %NFilesName)                #! File From: Prefix:Name
    #SET(%NRelasFileLinkKey   , %RelationPrefix & ':' & %Relation)              #! File Link: Prefix:Name
    #SET(%NRelasKeyFromKey    , %FileKey)                                       #!  Key From: Prefix:Name
    #SET(%NRelasKeyLinkKey    , %RelationKey)                                   #!  Key Link: Prefix:Name
    #SET(%NRelasType          , %FileRelationType)                              #! Relation Type
    #SET(%NRelasFileFrom      , %NFilesName)                                    #! File From: Main from
    #SET(%NRelasFileLink      , %Relation)                                      #! File Link: Relate To
    #SET(%NRelasKeyFrom       , %FileKey)                                       #!  Key From: Main from
    #CALL(%RemovePrefix,':',%NRelasKeyFrom)                                     #! Remove the FROM prefix
    #SET(%NRelasKeyLink       , %RelationKey)                                   #!  Key Link: Relate To
    #CALL(%RemovePrefix,':',%NRelasKeyLink)                                     #! Remove the LINK prefix
    #!SET(%NRelasOnUpdate      , %RelationConstraintUpdate)                     #! ON UPDATE: What to do?
    #!SET(%NRelasOnDelete      , %RelationConstraintDelete)                     #! ON DELETE: What to do?
    #!CALL(%GiveMeRestrict, %NRelasOnUpdate, %RelationConstraintUpdate)         #! ON UPDATE: What to do?
    #!CALL(%GiveMeRestrict, %NRelasOnDelete, %RelationConstraintDelete)         #! ON DELETE: What to do?
    #CALL(%GiveMeRestrict, %NRelasOnUpdate, %RelationConstraintUpdate ,%pBaseName)  #! RA.2018.06.03: Changes
    #CALL(%GiveMeRestrict, %NRelasOnDelete, %RelationConstraintDelete ,%pBaseName)  #! RA.2018.06.03: Changes
#!--01 %[3]NRelasCount, %NRelasFileFromKey, %NRelasType, %NRelasFileLinkKey
#!--01 %[3]NRelasCount, %NRelasKeyFromKey,  %NRelasType, %NRelasKeyLinkKey
#!--01 %[3]NRelasCount, FROM: %[90]NRelasFileFrom, %NRelasKeyFrom
#!--01 %[3]NRelasCount, LINK: %[90]NRelasFileLink, %NRelasKeyLink
#!
    #SET(%NRelasKeyFromCount, ITEMS(%FileKeyField))
    #SET(%NRelasKeyLinkCount, ITEMS(%RelationKeyField))
#!----02 KF: %[3]NRelasKeyFromCount, %FileKeyField
    #SET(%NRelaFieldIndex  , 0)
    #SET(%NRelaFieldsParent,'(')                                                #! Relation field list for Parent table
    #SET(%NRelaFieldsChild ,'(')                                                #! Relation field list for Child table
    #FOR(%FileKeyField)
      #SET(%NRelaFieldIndex, %NRelaFieldIndex + 1)
      #CALL(%BuildQualifiedRelationFields)
#!----02 %FileKeyField, %FileKeyFieldLink
    #ENDFOR
    #SET(%NRelaFieldsParent, %NRelaFieldsParent & ')')                          #! Relation field list for Parent table
    #SET(%NRelaFieldsChild , %NRelaFieldsChild  & ')')                          #! Relation field list for Child table
#!----03 KL: %[3]NRelasKeyLinkCount, %RelationKeyField
#!    #FOR(%RelationKeyField)
#!    %RelationKeyField, %RelationKeyFieldLink
#!    #ENDFOR
#!----
#!
#!DECLARE(%NRelasKeyFromCount ,%NRelas)  #! Key From: Field Count
#!DECLARE(%NRelasKFfield01    ,%NRelas)  #! Key From: Field 01
#!DECLARE(%NRelasKFfield02    ,%NRelas)  #! Key From: Field 02
#!DECLARE(%NRelasKFfield03    ,%NRelas)  #! Key From: Field 03
#!DECLARE(%NRelasKFfield04    ,%NRelas)  #! Key From: Field 04
#!DECLARE(%NRelasKFfield05    ,%NRelas)  #! Key From: Field 05
#!DECLARE(%NRelasKFfield06    ,%NRelas)  #! Key From: Field 06
#!DECLARE(%NRelasKFfield07    ,%NRelas)  #! Key From: Field 07
#!DECLARE(%NRelasKFfield08    ,%NRelas)  #! Key From: Field 08
#!DECLARE(%NRelasKFfield09    ,%NRelas)  #! Key From: Field 09
#!DECLARE(%NRelasKFlabel01    ,%NRelas)  #! Key From: Label 01
#!DECLARE(%NRelasKFlabel02    ,%NRelas)  #! Key From: Label 02
#!DECLARE(%NRelasKFlabel03    ,%NRelas)  #! Key From: Label 03
#!DECLARE(%NRelasKFlabel04    ,%NRelas)  #! Key From: Label 04
#!DECLARE(%NRelasKFlabel05    ,%NRelas)  #! Key From: Label 05
#!DECLARE(%NRelasKFlabel06    ,%NRelas)  #! Key From: Label 06
#!DECLARE(%NRelasKFlabel07    ,%NRelas)  #! Key From: Label 07
#!DECLARE(%NRelasKFlabel08    ,%NRelas)  #! Key From: Label 08
#!DECLARE(%NRelasKFlabel09    ,%NRelas)  #! Key From: Label 09
#!DECLARE(%NRelasKeyLinkCount ,%NRelas)  #! Key Link: Field Count
#!DECLARE(%NRelasKLfield01    ,%NRelas)  #! Key Link: Field 01
#!DECLARE(%NRelasKLfield02    ,%NRelas)  #! Key Link: Field 02
#!DECLARE(%NRelasKLfield03    ,%NRelas)  #! Key Link: Field 03
#!DECLARE(%NRelasKLfield04    ,%NRelas)  #! Key Link: Field 04
#!DECLARE(%NRelasKLfield05    ,%NRelas)  #! Key Link: Field 05
#!DECLARE(%NRelasKLfield06    ,%NRelas)  #! Key Link: Field 06
#!DECLARE(%NRelasKLfield07    ,%NRelas)  #! Key Link: Field 07
#!DECLARE(%NRelasKLfield08    ,%NRelas)  #! Key Link: Field 08
#!DECLARE(%NRelasKLfield09    ,%NRelas)  #! Key Link: Field 09
#!DECLARE(%NRelasKLlabel01    ,%NRelas)  #! Key Link: Label 01
#!DECLARE(%NRelasKLlabel02    ,%NRelas)  #! Key Link: Label 02
#!DECLARE(%NRelasKLlabel03    ,%NRelas)  #! Key Link: Label 03
#!DECLARE(%NRelasKLlabel04    ,%NRelas)  #! Key Link: Label 04
#!DECLARE(%NRelasKLlabel05    ,%NRelas)  #! Key Link: Label 05
#!DECLARE(%NRelasKLlabel06    ,%NRelas)  #! Key Link: Label 06
#!DECLARE(%NRelasKLlabel07    ,%NRelas)  #! Key Link: Label 07
#!DECLARE(%NRelasKLlabel08    ,%NRelas)  #! Key Link: Label 08
#!DECLARE(%NRelasKLlabel09    ,%NRelas)  #! Key Link: Label 09
#!---- BUILD IT HERE (ALTERNATIVE LOCATION)
  #ENDFOR
#ENDIF
#!
#! RA.2018.01.15 - Dump the whole %NRelas table after everything processed.
#IF((%TraceDetail) AND (%NRelaFound=%TRUE))
  #FOR(%NRelas)
---- %[3]NRelasCount, %NRelasFileFromKey, %NRelasType, %NRelasFileLinkKey
---- %[3]NRelasCount, %NRelasKeyFromKey, %NRelasType, %NRelasKeyLinkKey
---- %[3]NRelasCount, %NRelasKeyFromCount, %NRelasType, %NRelasKeyLinkCount
---- %[3]NRelasCount, FROM: %[90]NRelasFileFrom, %NRelasKeyFrom
---- %[3]NRelasCount, LINK: %[90]NRelasFileLink, %NRelasKeyLink
---- %[3]NRelasCount, UPDATE: %[8]NRelasOnUpdate, DELETE: %[8]NRelasOnDelete
---- %[3]NRelasCount, PF01:"%NRelasKFfield01", 02:"%NRelasKFfield02", 03:"%NRelasKFfield03", 04:"%NRelasKFfield04", 05:"%NRelasKFfield05", 06:"%NRelasKFfield06", 07:"%NRelasKFfield07", 08:"%NRelasKFfield08", 09:"%NRelasKFfield09"
---- %[3]NRelasCount, PL01:"%NRelasKFlabel01", 02:"%NRelasKFlabel02", 03:"%NRelasKFlabel03", 04:"%NRelasKFlabel04", 05:"%NRelasKFlabel05", 06:"%NRelasKFlabel06", 07:"%NRelasKFlabel07", 08:"%NRelasKFlabel08", 09:"%NRelasKFlabel09"
---- %[3]NRelasCount, CF01:"%NRelasKLfield01", 02:"%NRelasKLfield02", 03:"%NRelasKLfield03", 04:"%NRelasKLfield04", 05:"%NRelasKLfield05", 06:"%NRelasKLfield06", 07:"%NRelasKLfield07", 08:"%NRelasKLfield08", 09:"%NRelasKLfield09"
---- %[3]NRelasCount, CL01:"%NRelasKLlabel01", 02:"%NRelasKLlabel02", 03:"%NRelasKLlabel03", 04:"%NRelasKLlabel04", 05:"%NRelasKLlabel05", 06:"%NRelasKLlabel06", 07:"%NRelasKLlabel07", 08:"%NRelasKLlabel08", 09:"%NRelasKLlabel09"
---- %[3]NRelasCount, PLST:"%NRelaFieldsParent"
---- %[3]NRelasCount, CLST:"%NRelaFieldsChild"
  #ENDFOR
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2019.08.10: Handle [???] External in the fields for relationships [GUID and Time Stamp fields]
#! NOT NEEDED at this time: Bruce's TimeStamp, ServerTimeStamp, and DeletedTimeStamp do not have relationships.
#! If you need items that are external names in the relationships, this will have to be reworked.
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%BuildQualifiedRelationFields)
#!----02 %%BuildQualifiedRelationFields
#!----02 %NRelaFieldIndex, %FileKeyField, %FileKeyFieldLink
#CASE(%NRelaFieldIndex)
#OF(1)
  #SET(%NRelasKFfield01, %FileKeyField)
  #SET(%NRelasKFlabel01, %FileKeyField)
  #CALL(%RemovePrefix,':',%NRelasKFlabel01)
  #SET(%NRelasKLfield01, %FileKeyFieldLink)
  #SET(%NRelasKLlabel01, %FileKeyFieldLink)
  #CALL(%RemovePrefix,':',%NRelasKLlabel01)
  #! RA.2019.08.10: The %NRelasKFlabel(01-09) and %NRelasKLlabel(01-09) will need external.
  #SET(%NRelaFieldsParent,%NRelaFieldsParent & ''  & %NRelasKFlabel01)
  #SET(%NRelaFieldsChild ,%NRelaFieldsChild  & ''  & %NRelasKLlabel01)
#OF(2)
  #SET(%NRelasKFfield02, %FileKeyField)
  #SET(%NRelasKFlabel02, %FileKeyField)
  #CALL(%RemovePrefix,':',%NRelasKFlabel02)
  #SET(%NRelasKLfield02, %FileKeyFieldLink)
  #SET(%NRelasKLlabel02, %FileKeyFieldLink)
  #CALL(%RemovePrefix,':',%NRelasKLlabel02)
  #! RA.2019.08.10: The %NRelasKFlabel(01-09) and %NRelasKLlabel(01-09) will need external.
  #SET(%NRelaFieldsParent,%NRelaFieldsParent & ',' & %NRelasKFlabel02)
  #SET(%NRelaFieldsChild ,%NRelaFieldsChild  & ',' & %NRelasKLlabel02)
#OF(3)
  #SET(%NRelasKFfield03, %FileKeyField)
  #SET(%NRelasKFlabel03, %FileKeyField)
  #CALL(%RemovePrefix,':',%NRelasKFlabel03)
  #SET(%NRelasKLfield03, %FileKeyFieldLink)
  #SET(%NRelasKLlabel03, %FileKeyFieldLink)
  #CALL(%RemovePrefix,':',%NRelasKLlabel03)
  #! RA.2019.08.10: The %NRelasKFlabel(01-09) and %NRelasKLlabel(01-09) will need external.
  #SET(%NRelaFieldsParent,%NRelaFieldsParent & ',' & %NRelasKFlabel03)
  #SET(%NRelaFieldsChild ,%NRelaFieldsChild  & ',' & %NRelasKLlabel03)
#OF(4)
  #SET(%NRelasKFfield04, %FileKeyField)
  #SET(%NRelasKFlabel04, %FileKeyField)
  #CALL(%RemovePrefix,':',%NRelasKFlabel04)
  #SET(%NRelasKLfield04, %FileKeyFieldLink)
  #SET(%NRelasKLlabel04, %FileKeyFieldLink)
  #CALL(%RemovePrefix,':',%NRelasKLlabel04)
  #! RA.2019.08.10: The %NRelasKFlabel(01-09) and %NRelasKLlabel(01-09) will need external.
  #SET(%NRelaFieldsParent,%NRelaFieldsParent & ',' & %NRelasKFlabel04)
  #SET(%NRelaFieldsChild ,%NRelaFieldsChild  & ',' & %NRelasKLlabel04)
#OF(5)
  #SET(%NRelasKFfield05, %FileKeyField)
  #SET(%NRelasKFlabel05, %FileKeyField)
  #CALL(%RemovePrefix,':',%NRelasKFlabel05)
  #SET(%NRelasKLfield05, %FileKeyFieldLink)
  #SET(%NRelasKLlabel05, %FileKeyFieldLink)
  #CALL(%RemovePrefix,':',%NRelasKLlabel05)
  #! RA.2019.08.10: The %NRelasKFlabel(01-09) and %NRelasKLlabel(01-09) will need external.
  #SET(%NRelaFieldsParent,%NRelaFieldsParent & ',' & %NRelasKFlabel05)
  #SET(%NRelaFieldsChild ,%NRelaFieldsChild  & ',' & %NRelasKLlabel05)
#OF(6)
  #SET(%NRelasKFfield06, %FileKeyField)
  #SET(%NRelasKFlabel06, %FileKeyField)
  #CALL(%RemovePrefix,':',%NRelasKFlabel06)
  #SET(%NRelasKLfield06, %FileKeyFieldLink)
  #SET(%NRelasKLlabel06, %FileKeyFieldLink)
  #CALL(%RemovePrefix,':',%NRelasKLlabel06)
  #! RA.2019.08.10: The %NRelasKFlabel(01-09) and %NRelasKLlabel(01-09) will need external.
  #SET(%NRelaFieldsParent,%NRelaFieldsParent & ',' & %NRelasKFlabel06)
  #SET(%NRelaFieldsChild ,%NRelaFieldsChild  & ',' & %NRelasKLlabel06)
#OF(7)
  #SET(%NRelasKFfield07, %FileKeyField)
  #SET(%NRelasKFlabel07, %FileKeyField)
  #CALL(%RemovePrefix,':',%NRelasKFlabel07)
  #SET(%NRelasKLfield07, %FileKeyFieldLink)
  #SET(%NRelasKLlabel07, %FileKeyFieldLink)
  #CALL(%RemovePrefix,':',%NRelasKLlabel07)
  #! RA.2019.08.10: The %NRelasKFlabel(01-09) and %NRelasKLlabel(01-09) will need external.
  #SET(%NRelaFieldsParent,%NRelaFieldsParent & ',' & %NRelasKFlabel07)
  #SET(%NRelaFieldsChild ,%NRelaFieldsChild  & ',' & %NRelasKLlabel07)
#OF(8)
  #SET(%NRelasKFfield08, %FileKeyField)
  #SET(%NRelasKFlabel08, %FileKeyField)
  #CALL(%RemovePrefix,':',%NRelasKFlabel08)
  #SET(%NRelasKLfield08, %FileKeyFieldLink)
  #SET(%NRelasKLlabel08, %FileKeyFieldLink)
  #CALL(%RemovePrefix,':',%NRelasKLlabel08)
  #! RA.2019.08.10: The %NRelasKFlabel(01-09) and %NRelasKLlabel(01-09) will need external.
  #SET(%NRelaFieldsParent,%NRelaFieldsParent & ',' & %NRelasKFlabel08)
  #SET(%NRelaFieldsChild ,%NRelaFieldsChild  & ',' & %NRelasKLlabel08)
#OF(9)
  #SET(%NRelasKFfield09, %FileKeyField)
  #SET(%NRelasKFlabel09, %FileKeyField)
  #CALL(%RemovePrefix,':',%NRelasKFlabel09)
  #SET(%NRelasKLfield09, %FileKeyFieldLink)
  #SET(%NRelasKLlabel09, %FileKeyFieldLink)
  #CALL(%RemovePrefix,':',%NRelasKLlabel09)
  #! RA.2019.08.10: The %NRelasKFlabel(01-09) and %NRelasKLlabel(01-09) will need external.
  #SET(%NRelaFieldsParent,%NRelaFieldsParent & ',' & %NRelasKFlabel09)
  #SET(%NRelaFieldsChild ,%NRelaFieldsChild  & ',' & %NRelasKLlabel09)
#ENDCASE
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
