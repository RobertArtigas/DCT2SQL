#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! File Name:   D2PGRERA.tpw
#! Purpose:     DCT to POSTGRESQL creation script
#! Author:      Copyright © 1999-2999 by Roberto Artigas Jr
#!              All rights reserved world wide.
#! Changes:
#! 2011.04.09   Roberto Artigas
#!  *   If there is no primary key, DO NOT output a sort order. (Ex. Temporary Work Files).
#!      Added for the VIEWS sort order. For the tables remove EMULATEAUTONUMBER on the options.
#! 2010.09.28   Roberto Artigas
#!  *   There is a mismatched count condition that happens when a parent file with one key links
#!      to a child file with two keys (Duke Dictionary). For example (invoice -> invoice+lineitem).
#!      This causes mismatched keys items which are a problem with postgreSQL in the RELATIONS.
#!      Solved using the lesser of the count for matching keys. For the above example I used only
#!      one key relating (invoice -> invoice) which works correctly (for the purposes intended).
#!  *   The one relation problem that is ---NOT--- solved yet, is the one for the relation of the
#!      lookup key. One of the sides has no key. This creates a count of 0 which produces ---NO---
#!      relation. The correct solution is to make both keys equal and this is ---NOT--- done yet.
#!      I will ponder the coding approach to this. At this time, I need a break from this template.
#!  *   SELF NOTE: I do not have this problem on my dictionary because of the design decisions I made.
#!      I assigned unique keys to all the relations so I could track "PK" and "FK" constraints easily.
#!      I also avoid file validation lookups via the relations. This area might need enhancement.
#!  *   The Duke Dictionary is one that will really test any template that does DCT to SQL conversions.
#! 2010.09.25   Roberto Artigas
#!  *   Enhanced "SchemaRelat" to deal with EXTERNAL file, key, and field names.
#!      NOTE: There are some "Duke" dictionary conditions that cause errors (on the RELATION side).
#!  *   Enhanced "SchemaTrigr" to deal with EXTERNAL file, key, and field names.
#!  *   Enhanced "SchemaGrant" to deal with EXTERNAL file, key, and field names.
#!  *   Enhanced "SchemaValid" to deal with EXTERNAL file, key, and field names.
#! 2010.09.17   Roberto Artigas
#!  *   TO DO: Other "Schema*" need to be changed to deal with the EXTERNAL name for tables, keys, and columns.
#!  *   Duke DCT moved to PostgreSQL with the TABLES, KEYS and FIELDS.
#!  *   Enhanced "SchemaIndex" to deal with EXTERNAL file, key, and field names.
#!  *   Enhanced "SchemaViews" to deal with EXTERNAL file, key, and field names.
#! 2010.09.13   Roberto Artigas
#!  *   Enhanced template for EXTERNAL table, key, and field names.
#!  *   Added messages to show field that are ARRAYS that are not being processed processed.
#!  *   Decision to leave array key showing to that the DDL errors out unless RASQL(NO).
#! 2010.09.10   Roberto Artigas
#!  *   Changed the location of the 'databases_and_schemas.txt' file to the dictionary directory.
#! 2009.04.11   Roberto Artigas
#!  *   Adjusted logic for numeric processing to handle the picture '@N-_13.8' and
#!      get the correct number of digits and decimal places.
#!  *   Now uses the dictionary options or the 'databases_and_schemas.txt' file
#!      for the database names and schema names.
#! 2009.03.28   Roberto Artigas
#!  *   Adjusted the search_path to include public. Additional custom procedures and aggregates
#!      where added to public and are used in views, so I need to be able to find them.
#! 2009.03.09   Roberto Artigas
#!  *   Adjusted the logic for data type REAL and DOUBLE PRECISION so
#!      it would generate correctly for the backend.
#! 2009.02.25   Roberto Artigas
#!  *   Group all schema processing blocks for all sections.
#!  *   Implemented option 3 for generating single database-schema.
#! 2009.02.21   Roberto Artigas
#!  *   Change sequence from FILE NAME to FILE PREFIX for smaller size.
#! 2009.02.19   Roberto Artigas
#!  *   Continue adding schema logic for option 2 of the case statement. VALIDATION, TRIGGER, VIEW.
#! 2009.02.18   Roberto Artigas
#!  *   Continue adding schema logic for option 2 of the case statement. INDEX, RELATION.
#! 2009.01.27   Roberto Artigas
#!  *   Begin adding schema for option 2 of the case statement. TABLE, GRANT.
#! 2009.01.20   Roberto Artigas
#!  *   Table creation option now generating schema only when there is a table.
#!      The schema drop still generates for everything just in case of errors.
#!  *   Put the following options in the correct place in the case statement:
#!      grant, index, relat, valid, trigr, views.
#! 2009.01.01   Roberto Artigas
#!  *   Create new variant to add multi-database, multi-schema features.
#!  *   Got case statement working correctly for create option.
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%MITLicenseD2PGRERA)
#TAB('D2PGRERA'),PROP(PROP:FontStyle,700)
  #BOXED('MIT License'),AT(,,278),PROP(PROP:FontStyle,700)
    #DISPLAY('')
    #DISPLAY('Copyright © 1999 by Roberto Artigas y Soler.'),PROP(PROP:FontStyle,700)
    #DISPLAY('')
    #DISPLAY('Permission is hereby granted, free of charge, to any person ')
    #DISPLAY('obtaining a copy of this software and associated documentation ')
    #DISPLAY('files (the "Software"), to deal in the software without ')
    #DISPLAY('restriction, including without limitation the rights to use, ')
    #DISPLAY('copy, modify, merge, publish, distribute, sublicense, and/or sell ')
    #DISPLAY('copies of the Software, and to permit persons to whom the Software ')
    #DISPLAY('is furnished to do so, subject to the following conditions: ')
    #DISPLAY('')
    #DISPLAY('The above copyright notice and this permission notice shall be '),PROP(PROP:FontStyle,700)
    #DISPLAY('included in all copies or substantial portions of the Software.'),PROP(PROP:FontStyle,700)
    #DISPLAY('')
    #DISPLAY('THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, ')
    #DISPLAY('EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF ')
    #DISPLAY('MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND ')
    #DISPLAY('NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT ')
    #DISPLAY('HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, ')
    #DISPLAY('WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ')
    #DISPLAY('OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER ')
    #DISPLAY('DEALINGS IN THE SOFTWARE.')
  #ENDBOXED
#ENDTAB
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#UTILITY(Dct2PostgreSQL_RobertArtigas, '2016.02.27: Dictionary to POSTGRESQL script (SCHEMA Version)')
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#BOXED('Hidden Variables'),HIDE
  #PROMPT('DictName: '    ,@S40 ),%DictName
  #PROMPT('DictPath: '    ,@S80 ),%DictPath
  #PROMPT('nLoc1: '       ,@N4  ),%nLoc1
  #PROMPT('nLoc1a: '      ,@N4  ),%nLoc1a                       #! RA.2009.04.11
  #PROMPT('nLoc2: '       ,@N4  ),%nLoc2
  #PROMPT('aFileUser: '   ,@s40 ),%aFileUser                    #! RA.2008.09.17
  #PROMPT('aFileOpt1: '   ,@s40 ),%aFileOpt1                    #! RA.2008.09.17
  #PROMPT('aFileOpt2: '   ,@s40 ),%aFileOpt2                    #! RA.2008.09.17
  #PROMPT('aFileOpt3: '   ,@s40 ),%aFileOpt3                    #! RA.2008.09.17
  #PROMPT('aFileOpt4: '   ,@s40 ),%aFileOpt4                    #! RA.2008.09.17
  #PROMPT('DCTSCH: '      ,@S120),%dctsch                       #! RA.2010.09.10
  #PROMPT('OutTableName: ',@S120),%OutTableName
  #PROMPT('OutGrantName: ',@S120),%OutGrantName
  #PROMPT('OutIndexName: ',@S120),%OutIndexName
  #PROMPT('OutRelatName: ',@S120),%OutRelatName
  #PROMPT('OutValidName: ',@S120),%OutValidName
  #PROMPT('OutTrigrName: ',@S120),%OutTrigrName
  #PROMPT('OutViewsName: ',@S120),%OutViewsName
#ENDBOXED
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#PREPARE
#!----------------------------------------------------------------!
#! RA.2010.09.10 - Copied this code to the front of the template. !
#!----------------------------------------------------------------!
#SET(%nLoc1,INSTRING('\',%DictionaryFile,1,1))
#LOOP,WHILE(%nLoc1)
  #SET(%nLoc2,%nLoc1)
  #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,%nLoc1+1))
#ENDLOOP
#SET(%DictName,UPPER(SUB(%DictionaryFile,%nLoc2+1,LEN(%DictionaryFile)-%nLoc2-4)))
#SET(%DictPath,UPPER(SUB(%DictionaryFile,1,%nLoc2)))
#!
#SET(%SQLDirectory,%DictPath)
#SET(%SQLTableName,%DictName & '_01_PG.SQL')
#SET(%SQLGrantName,%DictName & '_02_PG.SQL')
#SET(%SQLIndexName,%DictName & '_03_PG.SQL')
#SET(%SQLRelatName,%DictName & '_04_PG.SQL')
#SET(%SQLValidName,%DictName & '_05_PG.SQL')
#SET(%SQLTrigrName,%DictName & '_06_PG.SQL')
#SET(%SQLViewsName,%DictName & '_07_PG.SQL')
#!
#!--------------------------------------------------------!
#! RA.2009.01.01 - Created this in the front of template. !
#!--------------------------------------------------------!
#DECLARE(%dctUserOptions)
#DECLARE(%dctDatabaseID)
#DECLARE(%dctDatabase)
#DECLARE(%dctSchemaID)
#DECLARE(%dctSchema)
#!
#DECLARE(%dctOptions)
#DECLARE(%dctOpt01)
#DECLARE(%dctOpt02)
#DECLARE(%dctOpt03)
#DECLARE(%dctOpt04)
#!
#! #EQUATE(%dctsch,'databases_and_schemas.txt')                 #! RA.2009.04.11
#EQUATE(%dctschRec,'')                                          #! RA.2009.04.11
#DECLARE(%A1,LONG)                                              #! RA.2009.04.11
#DECLARE(%A2,LONG)                                              #! RA.2009.04.11
#DECLARE(%A3,LONG)                                              #! RA.2009.04.11
#SET(%dctsch, %DictPath & 'databases_and_schemas.txt')          #! RA.2010.09.10
#!
#DECLARE(%dctDB),MULTI,UNIQUE
#DECLARE(%DBid,%dctDB)
#DECLARE(%DBname,%dctDB)
#DECLARE(%DBtext,%dctDB)
#!
#DECLARE(%dctSC),MULTI,UNIQUE
#DECLARE(%SCid,%dctSC)
#DECLARE(%SCname,%dctSC)
#DECLARE(%SCtext,%dctSC)
#!
#DECLARE(%P,LONG)
#DECLARE(%L,LONG)
#SET(%dctUserOptions,%DictionaryUserOptions)
#!-----------------------------------------------------------------------------------!
#DECLARE(%multiOpt)                                             #! RA.2009.01.01
#SET(%multiOpt,1)                                               #! RA.2009.01.01
#! DATABASE: ALL, SCHEMA: ALL : %multiOpt = 1
#! DATABASE: <*>, SCHEMA: ALL : %multiOpt = 2
#! DATABASE: <*>, SCHEMA: <*> : %multiOpt = 3
#! DATABASE: ALL, SCHEMA: <*> : %multiOpt = 4
#!-----------------------------------------------------------------------------------!
#! RA.2009.04.11 - See the procedure that loads the options from a file.             !
#!-----------------------------------------------------------------------------------!
#! RA.2009.03.29 - There is a limit to the amount of data the dictionary options     !
#! will hold (size of record) and I have reached it. I might need in the future to   !
#! to load these DATABASE_ and SCHEMA_ options from external files.                  !
#!-----------------------------------------------------------------------------------!
#SET(%dctDatabaseID, 0)
#ADD(%dctDB,  'ALL')
#SET(%DBid,   %dctDatabaseID)
#SET(%DBname, 'ALL')
#SET(%DBtext, 'Create ALL databases')
#!--------------------------------------------------------------------
#SET(%dctDatabaseID, 1)
#SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctDatabase))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctDatabase, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctDatabase, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctDatabase, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctDB,  %dctOpt02)
    #SET(%DBid,   %dctDatabaseID)
    #SET(%DBname, %dctOpt02)
    #SET(%DBtext, %dctOpt03)
  #ENDIF
  #SET(%dctDatabaseID, %dctDatabaseID + 1)
  #SET(%dctDatabase, 'DATABASE_' & FORMAT(%dctDatabaseID,@N02))
#ENDLOOP
#!--------------------------------------------------------------------
#SET(%dctSchemaID, 0)
#ADD(%dctSC,    'ALL')
#SET(%SCid,     %dctSchemaID)
#SET(%SCname,   'ALL')
#SET(%SCtext,   'Create all schemas')
#!--------------------------------------------------------------------
#SET(%dctSchemaID, 1)
#SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#LOOP
  #SET(%dctOptions, EXTRACT(%dctUserOptions, %dctSchema))
  #IF(NOT %dctOptions)
    #BREAK
  #ENDIF
  #SET(%dctOpt01, EXTRACT(%dctUserOptions, %dctSchema, 1))
  #SET(%dctOpt02, EXTRACT(%dctUserOptions, %dctSchema, 2))
  #SET(%dctOpt03, EXTRACT(%dctUserOptions, %dctSchema, 3))
  #IF(UPPER(SUB(%dctOpt01,1,1)) <> 'N')
    #ADD(%dctSC,    %dctOpt02)
    #SET(%SCid,     %dctSchemaID)
    #SET(%SCname,   %dctOpt02)
    #SET(%SCtext,   %dctOpt03)
  #ENDIF
  #SET(%dctSchemaID, %dctSchemaID + 1)
  #SET(%dctSchema, 'SCHEMA_' & FORMAT(%dctSchemaID,@N03))
#ENDLOOP
#!-----------------------------------------------------------------------------------!
#! RA.2009.04.11 - This is procedure that loads the options from a file.             !
#!-----------------------------------------------------------------------------------!
#IF(FILEEXISTS(%dctsch))                                        #! RA.2009.04.11
#!                                                              #! RA.2009.04.11
#OPEN(%dctsch),READ
#LOOP
  #READ(%dctschRec)
  #IF(%dctschRec = %EOF)
    #BREAK
  #ELSE
#!
    #SET(%dctOpt01, '')
    #SET(%A1, 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (01) %A1, %A2, %A3
    #SET(%dctOpt01, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt02, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, INSTRING('|', %dctschRec, 1, %A1))
    #SET(%A3, %A2 - %A1)
#!! (02) %A1, %A2, %A3
    #SET(%dctOpt02, SUB(%dctschRec, %A1, %A3))
#!
    #SET(%dctOpt03, '')
    #SET(%A1, %A2 + 1)
    #SET(%A2, LEN(%dctschRec) + 1)
    #SET(%A3, %A2 - %A1)
#!! (03) %A1, %A2, %A3
    #SET(%dctOpt03, SUB(%dctschRec, %A1, %A3))
#!
    #CASE(UPPER(%dctOpt01))
    #OF('DATABASE')
      #FIND(%DBname,%dctOpt02)
      #IF(%DBName = '')
        #SET(%dctDatabaseID, ITEMS(%dctDB) + 1)
        #ADD(%dctDB,  %dctOpt02)
        #SET(%DBid,   %dctDatabaseID)
        #SET(%DBname, %dctOpt02)
        #SET(%DBtext, %dctOpt03)
      #ENDIF
    #OF('SCHEMA')
      #FIND(%SCname,%dctOpt02)
      #IF(%SCName = '')
        #SET(%dctSchemaID, ITEMS(%dctSC) + 1)
        #ADD(%dctSC,  %dctOpt02)
        #SET(%SCid,   %dctSchemaID)
        #SET(%SCname, %dctOpt02)
        #SET(%SCtext, %dctOpt03)
      #ENDIF
    #ENDCASE
  #ENDIF
#ENDLOOP
#CLOSE(%dctsch),READ
#!                                                              #! RA.2009.04.11
#ENDIF                                                          #! RA.2009.04.11
#!-----------------------------------------------------------------------------------!
#!-----------------------------------------------------------------------------------!
#!
#!-----------------------------------------------------------------------------------!
#! RA.2008.09.17 - Created this in the front of template.                            !
#! This will create the correct tables list for the SPECIFIC table grant area.       !
#!-----------------------------------------------------------------------------------!
#DECLARE(%GrantFile),MULTI,UNIQUE                               #! RA.2008.09.17
#FOR(%File)                                                     #! RA.2008.09.17
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%aFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%aFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%aFileOpt1,EXTRACT(%aFileUser,'RASQL',1))
  #SET(%aFileOpt2,EXTRACT(%aFileUser,'RASQL',2))
  #SET(%aFileOpt3,EXTRACT(%aFileUser,'RASQL',3))
  #SET(%aFileOpt4,EXTRACT(%aFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%aFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #ADD(%GrantFile,%File)                                        #! RA.2008.09.17
#ENDFOR                                                         #! RA.2008.09.17
#ENDPREPARE
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#BOXED('POSTGRESQL SCRIPT CREATOR')
  #DISPLAY('')
  #DISPLAY('The POSTGRESQL Script Creator.')
  #DISPLAY('Copyright 2002-2015 © by Roberto Artigas Jr.')
  #DISPLAY('All Rights Reserved World Wide.')
  #DISPLAY('')
#ENDBOXED
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#SHEET,HSCROLL,AT(,,288)
 #INSERT(%MITLicenseD2PGRERA)
 #TAB('Multi-Process')
  #BOXED(''),AT(,,278)
   #DISPLAY('Allowable options are:')
   #DISPLAY('')
   #DISPLAY('1) DATABASE: ALL, SCHEMA: ALL')
   #DISPLAY('Default option. Everything generated in public'),AT(20)
   #DISPLAY('unless other options change the behavior.'),AT(20)
   #DISPLAY('')
   #DISPLAY('2) DATABASE: <*>, SCHEMA: ALL')
   #DISPLAY('Specific database and all schemas generated.'),AT(20)
   #DISPLAY('')
   #DISPLAY('3) DATABASE: <*>, SCHEMA: <*>')
   #DISPLAY('Specific database and specific schema generated.'),AT(20)
   #DISPLAY('')
   #DISPLAY('4) DATABASE: ALL, SCHEMA: <*>')
   #DISPLAY('All databases and specific schema generated.'),AT(20)
   #DISPLAY('')
   #DISPLAY('')
   #DISPLAY('')
   #PROMPT('DATABASE: ' ,FROM(%dctDB)),%multiDB,AT(82,,100),DEFAULT('ALL')
   #DISPLAY('')
   #PROMPT('SCHEMA: '   ,FROM(%dctSC)),%multiSC,AT(82,,100),DEFAULT('ALL')
   #!VALIDATE((%multiSC = 'ALL') AND (%multiDB <> 'ALL'), 'This option is NOT suported.')
  #ENDBOXED
 #ENDTAB
 #!
 #TAB('General')
  #BOXED(''),AT(,,278)
   #DISPLAY('')
   #PROMPT('Directory:'  ,@S80 ),%SQLDirectory,AT(66,,210)
   #DISPLAY('')
   #PROMPT('Generate CREATE?'   ,CHECK),%SQLTable,DEFAULT(%TRUE),AT(10)
   #PROMPT('CREATE Script:'     ,@S40 ),%SQLTableName,AT(96,,180)
   #!DISPLAY('')
   #PROMPT('Generate GRANT? '   ,CHECK),%SQLGrant,DEFAULT(%FALSE),AT(10)
   #PROMPT('GRANT Script:'      ,@S40 ),%SQLGrantName,AT(96,,180)
   #!DISPLAY('')
   #PROMPT('Generate KEYS?'     ,CHECK),%SQLIndex,DEFAULT(%TRUE),AT(10)
   #PROMPT('KEYS Script:'       ,@S40 ),%SQLIndexName,AT(96,,180)
   #!DISPLAY('')
   #PROMPT('Generate RELATION?' ,CHECK),%SQLRelat,DEFAULT(%FALSE),AT(10)
   #ENABLE(%SQLRelat)
     #PROMPT('Allow for Deferrable Constraints?',CHECK),%SQLRelatDefer,DEFAULT(%FALSE),AT(20)
   #ENDENABLE
   #PROMPT('RELATION Script:'   ,@S40 ),%SQLRelatName,AT(96,,180)
   #!DISPLAY('')
   #PROMPT('Generate VALIDATE?' ,CHECK),%SQLValid,DEFAULT(%FALSE),AT(10)
   #ENABLE(%SQLValid)
     #PROMPT('Generate CHECK?' ,CHECK),%SQLValidCheck,DEFAULT(%FALSE),AT(20)
   #ENDENABLE
   #PROMPT('VALIDATE Script:'   ,@S40 ),%SQLValidName,AT(96,,180)
   #!DISPLAY('')
   #PROMPT('Generate TRIGGER?' ,CHECK),%SQLTrigr,DEFAULT(%FALSE),AT(10)
   #ENABLE(%SQLTrigr)
     #PROMPT('Connect TRIGGER?' ,CHECK),%SQLTrigrConnect,DEFAULT(%FALSE),AT(20)
   #ENDENABLE
   #PROMPT('TRIGGER Script:'   ,@S40 ),%SQLTrigrName,AT(96,,180)
   #!DISPLAY('')
   #PROMPT('Generate VIEWS?'   ,CHECK),%SQLViews,DEFAULT(%TRUE),AT(10)
   #PROMPT('VIEWS Script:'     ,@S40 ),%SQLViewsName,AT(96,,180)
  #ENDBOXED
 #ENDTAB
 #!----------------------------------------------------------!
 #! RA.2008.06.29 - Added enhancements to the GRANT options. !
 #!----------------------------------------------------------!
 #TAB('Grant')
   #BOXED(''),AT(,,278)
    #PROMPT('Grant ALL priviledges ', CHECK), %optGrantAll, DEFAULT(0), AT(10)
    #ENABLE(%optGrantAll)
      #PROMPT('Grant ALL user name: ', @S40), %optGrantAllUser, DEFAULT('postgres')
    #ENDENABLE
    #DISPLAY('')
    #!#DISPLAY('Grants for ALL tables')
    #PROMPT('Generate grants for ALL tables ', CHECK), %optGrantDoit, DEFAULT(1), AT(10)
    #BUTTON('Tables: User or Groups'), MULTI(%optGrant, %optGrantType & '  ' & %optGrantName & '  ' & (%optGrantSelect + %optGrantInsert + %optGrantUpdate + %optGrantDelete)), INLINE, AT(,,,100)
      #PROMPT('Type of Grant: ',OPTION), %optGrantType, AT(,,100), DEFAULT('User'), REQ
      #PROMPT('&User', RADIO)
      #PROMPT('&Group', RADIO)
      #PROMPT('User or Group Name: ', @S40 ), %optGrantName, DEFAULT('public'), REQ
      #PROMPT('Select', CHECK), %optGrantSelect, DEFAULT(1)
      #PROMPT('Insert', CHECK), %optGrantInsert, DEFAULT(1)
      #PROMPT('Update', CHECK), %optGrantUpdate, DEFAULT(1)
      #PROMPT('Delete', CHECK), %optGrantDelete, DEFAULT(1)
    #ENDBUTTON
    #DISPLAY('')
    #!#DISPLAY('Grants for SPECIFIC tables')
    #PROMPT('Generate grants for SPECIFIC tables ', CHECK), %opt2GrantDoit, DEFAULT(0), AT(10)
    #BUTTON('Table: User or Groups'), MULTI(%opt2Grant, %opt2GrantTable & '  ' & %opt2GrantType & '  ' & %opt2GrantName & '  ' & (%opt2GrantSelect + %opt2GrantInsert + %opt2GrantUpdate + %opt2GrantDelete)), INLINE, AT(,,,100)
      #PROMPT('Table: ', FROM (%GrantFile)), %opt2GrantTable, AT(,,100), DEFAULT(''), REQ
      #PROMPT('Type of Grant: ',OPTION), %opt2GrantType, AT(,,100), DEFAULT('User'), REQ
      #PROMPT('&User', RADIO)
      #PROMPT('&Group', RADIO)
      #PROMPT('User or Group Name: ', @S40 ), %opt2GrantName, DEFAULT('public'), REQ
      #PROMPT('Select', CHECK), %opt2GrantSelect, DEFAULT(1)
      #PROMPT('Insert', CHECK), %opt2GrantInsert, DEFAULT(1)
      #PROMPT('Update', CHECK), %opt2GrantUpdate, DEFAULT(1)
      #PROMPT('Delete', CHECK), %opt2GrantDelete, DEFAULT(1)
    #ENDBUTTON
   #ENDBOXED
 #ENDTAB
 #PREPARE
 #IF(~ITEMS(%optGrant))
   #ADD(%optGrant,'User')
 #ENDIF
 #ENDPREPARE
 #!----------------------------------------------------------------------!
 #! RA.2007.07.17 - Added ignore reserved words and schema name options. !
 #!----------------------------------------------------------------------!
 #TAB('Options')
   #BOXED('General'),AT(,,278)
     #PROMPT('Ignore NOT NULL for all keys ',CHECK),%IgnoreNotNullKeys,AT(10),DEFAULT(%TRUE)
     #PROMPT('Ignore NOT NULL for all fields ',CHECK),%IgnoreNotNullFields,AT(10),DEFAULT(%TRUE)
     #DISPLAY('')
     #PROMPT('Use SEQUENCE for auto-increment ',CHECK),%UseSerial,AT(10),DEFAULT(%TRUE)
     #PROMPT('Key fields type INT to BIGINT ', CHECK),%MakeIntBigint,AT(10),DEFAULT(%True)              #! RA.2008.07.01
     #DISPLAY('')
     #PROMPT('Ignore reserved words ',CHECK),%IgnoreReserved,AT(10),DEFAULT(%TRUE)
     #DISPLAY('')
     #PROMPT('Create table and column names in lowercase',CHECK),%UseLowerCase,AT(10),Default(%True)    #! MAG 02.21.08
     #DISPLAY('')
#!     #PROMPT('Generate OWNER for tables ',CHECK),%UseOwner,AT(10),DEFAULT(0)
#!     #ENABLE(%UseOwner)
#!       #PROMPT('Owner Name:',@S40),%OwnerName,AT(82,,100),DEFAULT('postgres')
#!     #ENDENABLE
#!     #DISPLAY('')
     #PROMPT('Use schema name ',CHECK),%UseSchemaName,AT(10),DEFAULT(%FALSE)
     #ENABLE(%UseSchemaName)
       #PROMPT('Schema Name:',@S40),%SchemaName,AT(82,,100),DEFAULT('public')
     #ENDENABLE
   #ENDBOXED
   #BOXED('Prefixes'),AT(,,278)
     #PROMPT('Prefix Options ',OPTION),%UsePrefix,DEFAULT('None')
     #PROMPT('None',RADIO),AT(15)
     #PROMPT('All',RADIO),AT(15)
     #PROMPT('Some',RADIO),AT(15)
     #ENABLE(%UsePrefix='Some')
       #PROMPT('Use file prefix for table names ',CHECK),%PrefixTables,AT(10),DEFAULT(%False)
       #PROMPT('Use file prefix for column names ',CHECK),%PrefixColumns,AT(10),DEFAULT(%False)
       #PROMPT('Use file prefix for key names ',CHECK),%PrefixKeys,AT(10),DEFAULT(%False)
       #PROMPT('Use file prefix for relation names ',CHECK),%PrefixRelations,AT(10),DEFAULT(%False)
     #ENDENABLE
   #ENDBOXED
   #BOXED('Comments'),AT(,,278)
     #PROMPT('Generate database comments ',CHECK),%CommentsDB,AT(10),DEFAULT(%True)
     #PROMPT('Generate SQL script comments ',CHECK),%CommentsSQL,AT(10),DEFAULT(%True)
   #ENDBOXED
 #ENDTAB
#!$$------------------------------------------------!
#!$$ DEJ.2007.05.08 - Use External Field Name
#!$$------------------------------------------------!
 #TAB('External/Arrays')                                                                    #!$$
  #BOXED('External'),AT(,,278)                                                              #!$$
   #DISPLAY('The default is to generate a create script that uses')                         #!$$
   #DISPLAY('any EXTERNAL names defined in your dictionary.')                               #!$$
   #DISPLAY('In addition, Postgres will create the column names in')                        #!$$
   #DISPLAY('lowercase unless the name is generated within quotes.')                        #!$$
   #DISPLAY('')                                                                             #!$$
   #PROMPT('Generate EXTERNAL Table Name',CHECK),%UseExtTableName,AT(10),DEFAULT(0)         #! RA.2010.09.13
   #PROMPT('Generate EXTERNAL Key Name',CHECK),%UseExtKeyName,AT(10),DEFAULT(0)             #! RA.2010.09.13
   #ENABLE(%UseExtKeyName)                                                                  #!$$
    #PROMPT('Generate Key in Quotes',CHECK),%UseExtKeyQuote,AT(25),DEFAULT(0)               #!$$
   #ENDENABLE                                                                               #!$$
   #PROMPT('Generate EXTERNAL Column Name',CHECK),%UseExtFieldName,AT(10),DEFAULT(0)        #!$$
   #ENABLE(%UseExtFieldName)                                                                #!$$
    #PROMPT('Generate Column in Quotes',CHECK),%UseExtFieldQuote,AT(25),DEFAULT(0)          #!$$
   #ENDENABLE                                                                               #!$$
  #ENDBOXED                                                                                 #!$$
  #BOXED('Arrays'),AT(,,278)
   #DISPLAY('There are two ways to handle arrays:')
   #DISPLAY('')
   #DISPLAY('1) You defined a group with all the fields of the array')
   #DISPLAY('inside this group. Then you put the array OVER the')
   #DISPLAY('group. If you set up your arrays in this manner, then')
   #DISPLAY('LEAVE the checkbox below OFF.')
   #DISPLAY('')
   #DISPLAY('2) You define your arrays as actual fields using no')
   #DISPLAY('groups whatsoever. If you set up your arrays this way,')
   #DISPLAY('then TURN ON the checkbox bellow.')
   #DISPLAY('')
   #PROMPT('I DO NOT HAVE ARRAYS OVER GROUPS. ',CHECK),%NoArrayOver,AT(10),DEFAULT(0)
  #ENDBOXED
 #ENDTAB                                                                                    #!$$
#!$$------------------------------------------------!
#!$$ End of Use External Name
#!$$------------------------------------------------!
#! #TAB('Arrays')
#!  #BOXED('')
#!   #DISPLAY('There are two ways to handle arrays:')
#!   #DISPLAY('')
#!   #DISPLAY('1) You defined a group with all the fields of the array')
#!   #DISPLAY('inside this group. Then you put the array OVER the')
#!   #DISPLAY('group. If you set up your arrays in this manner, then')
#!   #DISPLAY('LEAVE the checkbox below OFF.')
#!   #DISPLAY('')
#!   #DISPLAY('2) You define your arrays as actual fields using no')
#!   #DISPLAY('groups whatsoever. If you set up your arrays this way,')
#!   #DISPLAY('then TURN ON the checkbox bellow.')
#!   #DISPLAY('')
#!   #PROMPT('I DO NOT HAVE ARRAYS OVER GROUPS. ',CHECK),%NoArrayOver,AT(10),DEFAULT(0)
#!  #ENDBOXED
#! #ENDTAB
 #TAB('Varchar/Picture')
  #BOXED('Varchar'),AT(,,278)
   #DISPLAY('PostgreSQL supports two primary character types.')
   #DISPLAY('  char(n)    - fixed length, blank padded')
   #DISPLAY('  varchar(n) - variable length with limit')
   #DISPLAY('')
   #DISPLAY('The storage requirement for varchar(n) is four bytes plus the')
   #DISPLAY('actual string with a maximum limit of n characters.')
   #DISPLAY('So, if you expect a string to be less than max characters')
   #DISPLAY('minus 4 bytes for more than half of the records, you should')
   #DISPLAY('probably turn it into a varchar.')
   #DISPLAY('To optimaly tune this, you have to edit the script produced by')
   #DISPLAY('the template on a field to field basis.')
   #DISPLAY('')
   #PROMPT('Varchar special processing ', CHECK), %VarCharSpecial, AT(10),DEFAULT(0)
   #DISPLAY('')
   #ENABLE(%VarCharSpecial)
     #PROMPT('Varchar for strings >= : ', @N4),%VarcharLen,AT(,,30,10),DEFAULT(256)
   #ENDENABLE
  #ENDBOXED
  #BOXED('Picture'),AT(,,278)
   #DISPLAY('You may convert PICTURE-fields to CHAR(n) by')
   #DISPLAY('checking this option.')
   #DISPLAY('')
   #DISPLAY('If not, the fields are showing up as ***PICTURE***')
   #DISPLAY('and you have to edit the generated script for this')
   #DISPLAY('fieldtype.')
   #DISPLAY('')
   #PROMPT('Make PICTURES as CHAR(n). ',CHECK),%PicAsChar,AT(10),DEFAULT(0)
  #ENDBOXED
 #ENDTAB
#! #TAB('Picture')
#!  #BOXED('')
#!   #DISPLAY('You may convert PICTURE-fields to CHAR(n) by')
#!   #DISPLAY('checking this option.')
#!   #DISPLAY('')
#!   #DISPLAY('If not, the fields are showing up as ***PICTURE***')
#!   #DISPLAY('and you have to edit the generated script for this')
#!   #DISPLAY('fieldtype.')
#!   #DISPLAY('')
#!   #PROMPT('Make PICTURES as CHAR(n). ',CHECK),%PicAsChar,AT(10),DEFAULT(0)
#!   #DISPLAY('')
#!  #ENDBOXED
#! #ENDTAB
 #TAB('UUID Processing')
   #BOXED(''),AT(,,278)
    #DISPLAY('PostGreSQL 8.3.x now supports UUID/GUID data types.')
    #DISPLAY('')
    #DISPLAY('For this to work in these templates the contrib module')
    #DISPLAY('uuid-ossp must be installed in the database - PostGreSQL')
    #DISPLAY('manual - Appendix F')
    #DISPLAY('')
    #DISPLAY('You can also set up to call a default algorithm just like')
    #DISPLAY('an auto-incremented column.')
    #DISPLAY('')
    #DISPLAY('This is accomplished by using the field options in the')
    #DISPLAY('dictionary as follows:')
    #DISPLAY('')
    #DISPLAY('RASQL(,UUID) will generate the UUID with no default')
    #DISPLAY('UUID')
    #DISPLAY('')
    #DISPLAY('RASQL(,UUID1) will generate the statement')
    #DISPLAY('UUID DEFAULT uuid_generate_v1()')
    #DISPLAY('')
    #DISPLAY('RASQL(,UUID2) will generate the statement')
    #DISPLAY('UUID DEFAULT uuid_generate_v1mc()')
    #DISPLAY('')
    #DISPLAY('RASQL(,UUID3) will generate the statement')
    #DISPLAY('UUID DEFAULT uuid_generate_v4()')
    #DISPLAY('')
    #DISPLAY('On the Clarion dictionary side this needs to be defined')
    #DISPLAY('as a CSTRING(37).')
   #ENDBOXED
  #ENDTAB
#ENDSHEET
#! #BOXED('Hidden Variables'),HIDE
#!  #PROMPT('Force BOOLEAN validation to [Y,N] choices? ',CHECK),%ForceBoolYN,AT(10),DEFAULT(1)
#!  #PROMPT('Do KEYFIELD-FILE list to create relations? ',CHECK),%DoFieldFile,AT(10),DEFAULT(0)
#!  #PROMPT('True Value (Y,T,1): ',@S1),%TrueValue,REQ,DEFAULT('Y')
#!  #PROMPT('False Value (N,F,0): ',@S1),%FalseValue,REQ,DEFAULT('N')
#! #ENDBOXED
#EQUATE(%ForceBoolYN, 1)    #! RA.2012.02.22
#EQUATE(%DoFieldFile, 0)    #! RA.2012.02.22
#EQUATE(%TrueValue, 'Y')    #! RA.2012.02.22
#EQUATE(%FalseValue, 'N')   #! RA.2012.02.22
#!---------------------------------------------------------------------
#! #PREPARE
#! #!
#! #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,1))
#! #LOOP,WHILE(%nLoc1)
#!   #SET(%nLoc2,%nLoc1)
#!   #SET(%nLoc1,INSTRING('\',%DictionaryFile,1,%nLoc1+1))
#! #ENDLOOP
#! #SET(%DictName,UPPER(SUB(%DictionaryFile,%nLoc2+1,LEN(%DictionaryFile)-%nLoc2-4)))
#! #SET(%DictPath,UPPER(SUB(%DictionaryFile,1,%nLoc2)))
#! #!
#! #SET(%SQLDirectory,%DictPath)
#! #SET(%SQLTableName,%DictName & '_01_PG.SQL')
#! #SET(%SQLGrantName,%DictName & '_02_PG.SQL')
#! #SET(%SQLIndexName,%DictName & '_03_PG.SQL')
#! #SET(%SQLRelatName,%DictName & '_04_PG.SQL')
#! #SET(%SQLValidName,%DictName & '_05_PG.SQL')
#! #SET(%SQLTrigrName,%DictName & '_06_PG.SQL')
#! #SET(%SQLViewsName,%Name & '_07_PG.SQL')
#! #!
#! #ENDPREPARE
#!---------------------------------------------------------------------
#! SQL specific options
#DECLARE(%NFileOpt0)                    #! File option 0  - EMULATEAUTONUMKEY(TRUE)
#DECLARE(%NFieldOpt0)                   #! Field option 0 - IsIdentity(TRUE)
#DECLARE(%NComment)                     #! Generate comments with QUOTE'd strings
#DECLARE(%WorkIt)                       #! Temporary variable
#!
#DECLARE(%NFileUser)                    #! File user options [RASQL]
#DECLARE(%NFileOpt1)                    #! File option 1 [NO]
#DECLARE(%NFileOpt2)                    #! File option 2 [EXTERNAL table name]
#DECLARE(%NFileOpt3)                    #! File option 3
#DECLARE(%NFileOpt4)                    #! File option 4
#!
#DECLARE(%NFieldUser)                   #! Field user options [RASQL]
#DECLARE(%NFieldOpt1)                   #! Field option 1 [NO]
#DECLARE(%NFieldOpt2)                   #! Field option 2 [<backend database type override>]
#DECLARE(%NFieldOpt3)                   #! Field option 3 [<backend database default value>]
#DECLARE(%NFieldOpt4)                   #! Field option 4
#!
#DECLARE(%NKeyUser)                     #! Key user options [RASQL]
#DECLARE(%NKeyOpt1)                     #! Key option 1 [NO]
#DECLARE(%NKeyOpt2)                     #! Key option 2 [EXTERNAL key name]
#DECLARE(%NKeyOpt3)                     #! Key option 3
#DECLARE(%NKeyOpt4)                     #! Key option 4
#!
#DECLARE(%NRelationUser)                #! Relation user options [RASQL]
#DECLARE(%NRelationOpt1)                #! Relation option 1 [NO]
#DECLARE(%NRelationOpt2)                #! Relation option 2
#DECLARE(%NRelationOpt3)                #! Relation option 3
#DECLARE(%NRelationOpt4)                #! Relation option 4
#!
#DECLARE(%NFileName)                    #! File Name
#DECLARE(%NFilePrefix)                  #! File Prefix - RA.2008.07.19
#DECLARE(%NFileSequence)                #! SQL CREATE SEQUENCE - RA.2010.09.13
#DECLARE(%NFileType)                    #! TYPE=???
#DECLARE(%NFileRowFormat)               #! ROW_FORMAT=???
#!
#DECLARE(%NFieldPKey)                   #! Field is Primary Key?
#DECLARE(%NFieldLine)                   #! Field line
#DECLARE(%NFieldName)                   #! Field Name
#DECLARE(%NFieldTSql)                   #! Field SQL type
#DECLARE(%NFieldTDef)                   #! Field SQL default
#DECLARE(%NFieldType)                   #! Field type
#DECLARE(%NFieldDef)                    #! Field default
#DECLARE(%NFieldCheck)                  #! Field CHECK(...) constraint
#DECLARE(%NFieldCheckOver)              #! Field CHECK(...) constraint override
#DECLARE(%NFieldAuto)                   #! Field AUTO_INCREMENT
#DECLARE(%NFieldNN)                     #! Field NOT NULL
#DECLARE(%NFieldSize  ,LONG)            #! Field decimal size
#DECLARE(%NFieldDec   ,LONG)            #! Field decimal places
#DECLARE(%NLeadZero   ,LONG)            #! Have a leading zero
#DECLARE(%NFNameAuto)                   #! Field Name Auto Increment
#DECLARE(%NVarcharLen ,LONG)            #! Length before turning to VARCHAR
#SET(%NVarcharLen, %VarcharLen)         #! Turn the input field to a long
#!
#DECLARE(%NKeyName)                     #! Key name
#DECLARE(%NKeyFields)                   #! Key building line
#DECLARE(%NKeyField)                    #! Key field current
#DECLARE(%NKeyField1)                   #! Key field current (from)
#DECLARE(%NKeyField2)                   #! Key field current (to)
#DECLARE(%NKeyFieldCount)               #! Number of key fields
#DECLARE(%PrimaryCount)                 #! Primary key exists
#DECLARE(%SecondaryCount)               #! Secondary key exists
#DECLARE(%AutoIncrementCount)           #! Auto-Increment key exists
#!
#DECLARE(%NRelateSequence)              #! Unique relation sequence number                  #! RA.2010.09.25
#SET(%NRelateSequence, 0)                                                                   #! RA.2010.09.25
#DECLARE(%NRelateSave)                  #! Save the current relationship                    #! RA.2010.09.25
#DECLARE(%FileKeyFieldSave)             #! Save the current file-key-field                  #! RA.2010.09.25
#DECLARE(%NRelateItem)                  #! Working item number
#DECLARE(%NRelateCount)                 #! Total items to work
#DECLARE(%NRelateComma)                 #! Number of commas
#DECLARE(%NRelateFile)                  #! Related file
#DECLARE(%NRelateField1)                #! Related origin field
#DECLARE(%NRelateField2)                #! Related relate field
#DECLARE(%RelationField1Count)          #! Count of origin file key items
#DECLARE(%RelationField2Count)          #! Count of relate file key items
#DECLARE(%RelationField1)               #! The origin file keys
#DECLARE(%RelationField2)               #! The relate file keys
#DECLARE(%RelationUpdate)               #! ON UPDATE ?
#DECLARE(%RelationDelete)               #! ON DELETE ?
#DECLARE(%NRelateSchema1)               #! Related origin schema
#DECLARE(%NRelateSchema2)               #! Related relate schema
#!
#!#DECLARE(%nLoc1       ,LONG)            #! Location 1
#!#DECLARE(%nLoc2       ,LONG)            #! Location 2
#DECLARE(%TheCount    ,LONG)            #! Count posible relations
#DECLARE(%CStringLen)                   #! Length of types shortened by one
#DECLARE(%LastField)                    #! Last field processed
#DECLARE(%InnerGroup)                   #! Inner group level processed
#DECLARE(%FieldComma)                   #! Number of fields - 1
#!
#DECLARE(%ChoiceLine)                   #! Build ENUM field type line
#DECLARE(%ChoiceComma)                  #! Count ENUM values - 1
#!
#DECLARE(%DocVar)                       #! Documentation Variable
#DECLARE(%TableCount, 0)                #! Count of tables
#DECLARE(%AutoCount, 0)                 #! Count of Auto-Increment Keys
#DECLARE(%PKeyCount, 0)                 #! Count of primary keys (From Keys)
#DECLARE(%PKeyOption, 0)                #! Count of primary keys (From Options)
#DECLARE(%KeyOthers, 0)                 #! Count of secondary keys
#DECLARE(%KeyCount, 0)                  #! Count of all keys combined
#DECLARE(%FieldCount, 0)                #! Count of fields
#DECLARE(%RelCount, 0)                  #! Relationship Counts
#DECLARE(%FieldTable),MULTI,UNIQUE      #! List of unique fields
#DECLARE(%FieldUnique, 0)               #! Count of unique fields
#!
#DECLARE(%TheDate)                      #! Display current date
#DECLARE(%TheTime)                      #! Display current time
#SET(%TheDate,FORMAT(TODAY(),@D010))    #! Set current date
#SET(%TheTime,FORMAT(CLOCK(),@T06))     #! Set current time
#!
#DECLARE(%DimCount          ,LONG)      #! Number of dimensions
#DECLARE(%FldArray          ,STRING)    #! Created field name from array
#DECLARE(%FD1S              ,STRING)    #! Number for dimension 1
#DECLARE(%FD2S              ,STRING)    #! Number for dimension 2
#DECLARE(%FD3S              ,STRING)    #! Number for dimension 3
#DECLARE(%FD4S              ,STRING)    #! Number for dimension 4
#DECLARE(%FD1I              ,LONG)      #! Looping in Dimension 1
#DECLARE(%FD2I              ,LONG)      #! Looping in Dimension 2
#DECLARE(%FD3I              ,LONG)      #! Looping in Dimension 3
#DECLARE(%FD4I              ,LONG)      #! Looping in Dimension 4
#DECLARE(%FD1L              ,LONG)      #! Set to %FieldDimension1
#DECLARE(%FD2L              ,LONG)      #! Set to %FieldDimension2
#DECLARE(%FD3L              ,LONG)      #! Set to %FieldDimension3
#DECLARE(%FD4L              ,LONG)      #! Set to %fieldDimension4
#!
#DECLARE(%ValTypeDCT        ,STRING)    #! Original type from dictionary
#DECLARE(%ValType           ,STRING)    #! Validation type for backend
#DECLARE(%ValLength         ,LONG)      #! String length
#DECLARE(%ValNumeric        ,LONG)      #! Length of entry box
#DECLARE(%ValDecimal        ,LONG)      #! Number of decimal places
#DECLARE(%ValTrue           ,STRING)    #! TRUE Value
#DECLARE(%ValFalse          ,STRING)    #! FALSE Value
#DECLARE(%ValI              ,LONG)      #! Index into list of values
#DECLARE(%ValList),MULTI,UNIQUE         #! List of Values
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#DECLARE(%optGrantCount     ,LONG)      #! Number of options created                #! RA.2008.06.29
#DECLARE(%optGrantTotal     ,LONG)      #! Number of options checked on             #! RA.2008.06.29
#DECLARE(%optGrantLine      ,STRING)    #! Grant option line                        #! RA.2008.06.29
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#DECLARE(%TriggerBefore     ,LONG)                                                  #! RA.2008.06.30
#DECLARE(%TriggerAfter      ,LONG)                                                  #! RA.2008.06.30
#DECLARE(%TriggerList),MULTI                                                        #! RA.2008.06.30
#DECLARE(%TriggerWhen   ,%TriggerList)                                              #! RA.2008.06.30
#DECLARE(%TriggerOp     ,%TriggerList)                                              #! RA.2008.06.30
#DECLARE(%TriggerStmt   ,%TriggerList)                                              #! RA.2008.06.30
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#DECLARE(%ProcFileFound, LONG)          #! RA.2009.01.20
#DECLARE(%ProcFile),MULTI,UNIQUE        #! RA.2007.11.25
#DECLARE(%ProcFileName,%ProcFile)       #! RA.2009.01.01
#DECLARE(%ProcFileDB,%ProcFile)         #! RA.2009.01.01
#DECLARE(%ProcFileSC,%ProcFile)         #! RA.2009.01.01
#FOR(%File)
  #ADD(%ProcFile,%File)
  #SET(%ProcFileName,%File)             #! RA.2009.01.01
  #!
  #SET(%dctOpt01, '')
  #SET(%dctOpt02, '')
  #SET(%dctOpt03, '')
  #SET(%dctOpt04, '')
  #SET(%dctOpt01, EXTRACT(%FileUserOptions, 'DATABASE', 1))
  #SET(%dctOpt02, EXTRACT(%FileUserOptions, 'DATABASE', 2))
  #SET(%dctOpt03, EXTRACT(%FileUserOptions, 'SCHEMA'  , 1))
  #SET(%dctOpt04, EXTRACT(%FileUserOptions, 'SCHEMA'  , 2))
  #!
  #IF(NOT %dctOpt02)
    #SET(%dctOpt02, '?')
  #ELSE
    #FIND(%DBname, %dctOpt02)
    #IF(NOT %DBname)
      #SET(%dctOpt02, '*BAD*')
    #ENDIF
  #ENDIF
  #IF(NOT %dctOpt04)
    #SET(%dctOpt04, 'public')
  #ELSE
    #IF(%dctOpt04 <> 'public')
      #FIND(%SCname, %dctOpt04)
      #IF(NOT %SCname)
        #SET(%dctOpt04, '*BAD*')
      #ENDIF
    #ENDIF
  #ENDIF
  #!
  #SET(%ProcFileDB,%dctOpt02)           #! RA.2009.01.01
  #SET(%ProcFileSC,%dctOpt04)           #! RA.2009.01.01
#ENDFOR
#!--------------------------------------------------------------!
#! List of table, key and rows names found in reserved list.    !
#!--------------------------------------------------------------!
#DECLARE(%ReservedFieldList),MULTI,UNIQUE
#EQUATE (%FoundFileName     ,'File Name:          ')
#EQUATE (%FoundFileField    ,'File Field Name:    ')
#EQUATE (%FoundAIKeyName    ,'AI Key Name:        ')
#EQUATE (%FoundKeyName      ,'Key Name:           ')
#EQUATE (%FoundKeyField     ,'Key Field Name:     ')
#EQUATE (%FoundRelatedName  ,'Related File Name:  ')
#EQUATE (%FoundRelatedField ,'Related Field Name: ')
#!-------------------------------------------------------------------------!
#! RA.2001.12.15 - Table of field-table to be able to create relations.    !
#!-------------------------------------------------------------------------!
#DECLARE(%FieldTableList),MULTI,UNIQUE
#!---------------------------------------------------------------------
#DECLARE(%LFieldInKey),MULTI,UNIQUE     #! Field list that are used in keys
#DECLARE(%IFieldInKey)                  #! Field item to search for in list
#DECLARE(%LFieldInKeyCount)             #! How many fields are in keys?
#FREE(%LFieldInKey)
#FOR(%ProcFile)                         #! RA.2007.11.25
  #FIX(%File,%ProcFile)                 #! RA.2007.11.25
  #IF(ITEMS(%Key))
    #FOR(%Key)
      #FOR(%KeyField)
        #ADD(%LFieldInKey,%KeyField)
      #ENDFOR
    #ENDFOR
  #ENDIF
#ENDFOR
#SET(%LFieldInKeyCount,ITEMS(%LFieldInKey))
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#INSERT(%ClarionReservedWords)
#INSERT(%SqlReservedWords)
#FOR(%ClarionWordList)
  #ADD(%SqlWordList,%ClarionWordList)
#ENDFOR
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#SET(%TableCount, 0)                    #! Count of tables
#SET(%AutoCount, 0)                     #! Count of Auto-Increment Keys
#SET(%PKeyCount, 0)                     #! Count of primary keys (From Keys)
#SET(%PKeyOption, 0)                    #! Count of primary keys (From Options)
#SET(%KeyOthers, 0)                     #! Count of secondary keys
#SET(%KeyCount, 0)                      #! Count of all keys combined
#SET(%FieldCount, 0)                    #! Count of fields
#SET(%RelCount, 0)                      #! Relationship Counts
#SET(%FieldUnique, 0)                   #! Count of unique fields
#!---------------------------------------------------------------------
#! RA.2009.01.01 - Set the multi-database, multi-schema options now.
#!---------------------------------------------------------------------
#IF   (%multiDB <> 'ALL' AND %multiSC  = 'ALL')
  #SET(%multiOpt, 2)                                            #! RA.2009.01.01 - <*>,ALL
#ELSIF(%multiDB <> 'ALL' AND %multiSC <> 'ALL')
  #SET(%multiOpt, 3)                                            #! RA.2009.01.01 - <*>,<*>
#ELSIF(%multiDB  = 'ALL' AND %multiSC <> 'ALL')
  #SET(%multiOpt, 4)                                            #! RA.2009.01.01 - ALL,<*>
#ELSE
  #SET(%multiOpt, 1)                                            #! RA.2009.01.01 - ALL,ALL
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLTable)
#CASE(%multiOpt)
#OF(2)                                                          #! RA.2009.01.01 - <*>,ALL
  #SET(%SQLTableName,%DictName & '__' & %multiDB & '__01_PG.SQL')
  #SET(%OutTableName,%SQLDirectory & %SQLTableName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,ALL]',0)
  #MESSAGE('Creating: ' & %SQLTableName,1)
  #CREATE(%OutTableName)
--
-- BOF: %OutTableName
--
-- SQL script creator for POSTGRESQL database %multiDB [TABLE]
-- Created: %TheDate - %TheTime
--
  #FIND(%DBname,%multiDB)
COMMENT ON DATABASE %DBname IS '%DBtext' ;

  #FOR(%dctSC),WHERE(%SCid > 0)
DROP SCHEMA IF EXISTS %SCname CASCADE ;
CREATE SCHEMA %SCname ;
COMMENT ON SCHEMA %SCname IS '%SCtext' ;

  #ENDFOR
  #FOR(%dctSC),WHERE(%SCid > 0)
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaTable)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR

--
-- EOF: %OutTableName
--
  #CLOSE(%OutTableName)
  #RUN('NOTEPAD.EXE "' & %OutTableName & '"')
#OF(3)                                                          #! RA.2009.01.01 - <*>,<*>
  #SET(%SQLTableName,%DictName & '__' & %multiDB & '__' & %multiSC & '__01_PG.SQL')
  #SET(%OutTableName,%SQLDirectory & %SQLTableName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,<*>]',0)
  #MESSAGE('Creating: ' & %SQLTableName,1)
  #CREATE(%OutTableName)
--
-- BOF: %OutTableName
--
-- SQL script creator for POSTGRESQL database %multiDB [TABLE]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE((%SCid > 0) AND (%SCname = %multiSC))
  #MESSAGE('The POSTGRESQL Script Creator [<*>,<*>]',0)
DROP SCHEMA IF EXISTS %SCname CASCADE ;
CREATE SCHEMA %SCname ;
COMMENT ON SCHEMA %SCname IS '%SCtext' ;

  #ENDFOR
  #FOR(%dctSC),WHERE((%SCid > 0) AND (%SCname = %multiSC))
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaTable)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR

--
-- EOF: %OutTableName
--
  #CLOSE(%OutTableName)
  #RUN('NOTEPAD.EXE "' & %OutTableName & '"')
#OF(4)                                                          #! RA.2009.01.01 - ALL,<*>
  #MESSAGE('The POSTGRESQL Script Creator [ALL,<*>]',0)
#ELSE                                                           #! RA.2009.01.01 - ALL,ALL
  #MESSAGE('The POSTGRESQL Script Creator [ALL,ALL]',0)
  #SET(%OutTableName,%SQLDirectory & %SQLTableName)
  #CREATE(%OutTableName)
!  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLTableName,1)
--
-- BOF: %OutTableName
--
-- SQL script creator for POSTGRESQL database [TABLE]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
DROP SCHEMA IF EXISTS %SchemaName CASCADE ;
CREATE SCHEMA %SchemaName ;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #!
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%RAModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%FilePrefix:%File) %NFileName [DATABASE: %ProcFileDB, SCHEMA: %ProcFileSC]
--

  #ENDIF                                                        #! RA.2008.08.13
  #!------------------------------------------------------------------------!
  #! IF it IS a primary key, AND it is an integer, AND NOT auto-increment,  !
  #! AND there is one item in the key (only thing I can be sure about),     !
  #! THEN assume that it IS an auto-increment handled by the SQL backend.   !
  #!------------------------------------------------------------------------!
  #SET(%NFNameAuto,'')
  #SET(%AutoIncrementCount,0)
  #IF(ITEMS(%Key))
    #FOR(%Key)
#!---- Key        = %Key
      #IF(%KeyPrimary <> 1)
        #CYCLE
      #ENDIF
#!---- KeyPrimary = %KeyPrimary
      #IF(%KeyAuto = 1)
        #CYCLE
      #ENDIF
#!---- KeyAuto    = %KeyAuto
#!
      #IF(ITEMS(%KeyField) > 1)
        #CYCLE
      #ENDIF
#!
      #FOR(%KeyField)
#!---- KeyField   = %KeyField
        #FIX(%Field,%KeyField)
#!---- Field      = %Field
#!---- FieldType  = %FieldType
        #CASE(%FieldType)
        #OF('LONG')
          #SET(%NFNameAuto, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
          #!-------------------------------------------!
          #! RA.2010.09.13 - EXTERNAL name processing. !
          #!-------------------------------------------!
          #FIX(%Field,%KeyField)                                                                #! RA.2010.09.17
          #IF(%UseExtFieldName AND %FieldName)                                                  #! RA.2010.09.13
            #IF(%UseExtFieldQuote)                                                              #! RA.2010.09.13 - Generate External Name w/ Quotes
              #SET(%NFNameAuto, %FieldName)                                                     #! RA.2010.09.13
            #ELSE                                                                               #! RA.2010.09.13
              #SET(%NFNameAuto, SUB(%FieldName,2,LEN(%FieldName)-2))                            #! RA.2010.09.13 - Remove Quotes in External Name
            #ENDIF                                                                              #! RA.2010.09.13
          #ENDIF                                                                                #! RA.2010.09.13
          #!-------------------------------------------!
          #!-------------------------------------------!
        #ENDCASE
      #ENDFOR
#!
      #IF(%NFNameAuto)
#!---- NFNameAuto = %NFNameAuto
        #SET(%AutoIncrementCount,%AutoIncrementCount + 1)
        #SET(%AutoCount, %AutoCount + 1)
#!        #SET(%NFNameAuto, SUB(%KeyAuto, INSTRING(':',%KeyAuto,1,1) + 1 , 50))
        #IF(%UsePrefix='All' OR %PrefixColumns)                                     #! RA.2008.08.11
          #SET(%NFNameAuto, %FilePrefix & '_' & %NFNameAuto)
        #ENDIF
        #!---------------------------------------------!
        #! RA.2007.10.10 - Behave according to option. !
        #!---------------------------------------------!
        #IF(NOT %IgnoreReserved)
          #SET(%SqlWordItem, UPPER(%NFNameAuto))
          #FIND(%SqlWordList, %SqlWordItem)
          #IF(%SqlWordList)
            #ADD(%ReservedFieldList, %FoundAIKeyName & %FilePrefix & ':' & %NFNameAuto)
            #SET(%NFNameAuto, %NFNameAuto & '_')
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDFOR
    #IF(%AutoIncrementCount = 0)
#!-- WARNING: %File(%FilePrefix) has no AUTO-INCREMENT KEY defined.
    #ENDIF
  #ENDIF
#!
#!PRINT '%NFileName'
#!
  #IF(%nFileOpt0)
--
-- DRIVER:  %FileDriver
-- OPTIONS: %FileDriverParameter
-- OWNER:   %FileOwner
-- NAME:    %FileName
--
  #ENDIF
#!
CREATE TABLE %NFileName (
#INSERT(%PGSQLField)                                            #! Process fields
)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%FileDescription))                        #! RA.2008.08.12
COMMENT ON TABLE %NFileName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13
#INSERT(%RASQLFieldComment)                                     #! Process fields comments

#!  #IF (%UseOwner)
#!ALTER TABLE %NFileName OWNER TO %OwnerName
#!;
#!
#!  #ENDIF
  #!----------------------------------------------------------------!
  #! RA.2007.09.20 - If the ISIDENTITY() is set to TRUE this is     !
  #! an auto increment field. This is best descrived as a SERIAL    !
  #! (or BIG serial). SERIAL or BIGSERIAL sets up the equivalent    !
  #! in PostgreSQL of:                                              !
  #!                                                                !
  #!  CREATE TABLE pg_name (                                        !
  #!    auto_id INT NOT NULL ,                                      !
  #!    first_name CHAR(30) NOT NULL ,                              !
  #!    middle_name CHAR(30) NULL ,                                 !
  #!    last_name CHAR(30) NOT NULL ,                               !
  #!    last_name_father CHAR(30) NULL ,                            !
  #!    last_name_mother CHAR(30) NULL                              !
  #!  )                                                             !
  #!  ;                                                             !
  #!                                                                !
  #!  ALTER TABLE pg_name                                           !
  #!    ADD CONSTRAINT pg01_key0_pk PRIMARY KEY (auto_id)           !
  #!  ;                                                             !
  #!                                                                !
  #!  CREATE INDEX pg01_key1                                        !
  #!    ON pg_name (last_name)                                      !
  #!  ;                                                             !
  #!                                                                !
  #!  CREATE SEQUENCE pg_name_id_seq                                !
  #!      INCREMENT BY 1                                            !
  #!      CACHE 1                                                   !
  #!  ;                                                             !
  #!                                                                !
  #!  ALTER SEQUENCE pg_name_id_seq OWNED BY pg_name.auto_id        !
  #!  ;                                                             !
  #!                                                                !
  #!  ALTER TABLE pg_name ALTER COLUMN auto_id SET DEFAULT          !
  #!       nextval('pg_name_id_seq'::regclass)                      !
  #!  ;                                                             !
  #!                                                                !
  #!----------------------------------------------------------------!
  #IF(%nFileOpt0)                                               #! You have to have it set up in the dictionary
    #IF(%UseSerial)                                             #! And you have to want it in the template
      #!--------------------------------------!
      #! RA.2010.09.13 - EXTERNAL table name. !
      #!--------------------------------------!
      #SET(%NFileSequence, %NFilePrefix)                        #! RA.2010.09.13
      #IF(%UseExtTableName AND %NFileOpt2)                      #! RA.2010.09.13
        #SET(%NFileSequence,LOWER(%NFileOpt2))                  #! RA.2010.09.13
      #ENDIF                                                    #! RA.2010.09.13
      #!--------------------------------------!
      #!--------------------------------------!
CREATE SEQUENCE %NFileSequence_id_seq
  INCREMENT BY 1
  CACHE 1
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%FileDescription))                        #! RA.2008.08.12
COMMENT ON SEQUENCE %NFileSequence_id_seq IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

ALTER SEQUENCE %NFileSequence_id_seq
  OWNED BY %NFileName.%NFNameAuto
;

ALTER TABLE %NFileName ALTER COLUMN %NFNameAuto
  SET DEFAULT nextval('%NFileSequence_id_seq'::regclass)
;
    #ENDIF

  #ENDIF
#ENDFOR
--
-- EOF: %OutTableName
--
  #CLOSE(%OutTableName)
  #RUN('NOTEPAD.EXE "' & %OutTableName & '"')
#ENDCASE
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLGrant)
#CASE(%multiOpt)
#OF(2)                                                          #! RA.2009.01.27 - <*>,ALL
  #MESSAGE('The POSTGRESQL Script Creator [<*>,ALL]',0)
  #SET(%SQLGrantName,%DictName & '__' & %multiDB & '__02_PG.SQL')
  #SET(%OutGrantName,%SQLDirectory & %SQLGrantName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,ALL]',0)
  #MESSAGE('Creating: ' & %SQLGrantName,1)
  #CREATE(%OutGrantName)
--
-- BOF: %OutGrantName
--
-- SQL script creator for POSTGRESQL database %multiDB [GRANT]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE(%SCid > 0)
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaGrant)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
#INSERT(%SchemaGrantSingle)                                     #! RA.2009.02.25

--
-- EOF: %OutGrantName
--
  #CLOSE(%OutGrantName)
  #RUN('NOTEPAD.EXE "' & %OutGrantName & '"')
#OF(3)                                                          #! RA.2009.01.01 - <*>,<*>
  #SET(%SQLGrantName,%DictName & '__' & %multiDB & '__' & %multiSC & '__02_PG.SQL')
  #SET(%OutGrantName,%SQLDirectory & %SQLGrantName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,<*>]',0)
  #MESSAGE('Creating: ' & %SQLGrantName,1)
  #CREATE(%OutGrantName)
--
-- BOF: %OutGrantName
--
-- SQL script creator for POSTGRESQL database %multiDB [GRANT]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE((%SCid > 0) AND (%SCname = %multiSC))
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaGrant)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
#INSERT(%SchemaGrantSingle)                                     #! RA.2009.02.25

--
-- EOF: %OutGrantName
--
  #CLOSE(%OutGrantName)
  #RUN('NOTEPAD.EXE "' & %OutGrantName & '"')
#OF(4)                                                          #! RA.2009.01.01 - ALL,<*>
  #MESSAGE('The POSTGRESQL Script Creator [ALL,<*>]',0)
#ELSE                                                           #! RA.2009.01.01 - ALL,ALL
  #MESSAGE('The POSTGRESQL Script Creator [ALL,ALL]',0)
  #SET(%OutGrantName,%SQLDirectory & %SQLGrantName)
  #CREATE(%OutGrantName)
#!  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLGrantName,1)
--
-- BOF: %OutGrantName
--
-- SQL script creator for POSTGRESQL database [GRANT]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, public, pg_catalog
;

#ENDIF
#IF(%optGrantAll)
GRANT ALL TO %optGrantAllUser WITH GRANT OPTION
;

#ENDIF
#!
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #IF(NOT %optGrantDoit)                                        #! RA.2008.09.17
    #CYCLE                                                      #! RA.2008.09.17
  #ENDIF                                                        #! RA.2008.09.17
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%RAModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
  #FOR(%optGrant)
    #SET(%optGrantTotal     , %optGrantSelect + %optGrantInsert + %optGrantUpdate + %optGrantDelete)
    #SET(%optGrantCount     , 0)
    #SET(%optGrantLine      , '')
#!-- TOTAL: %optGrantTotal
    #CASE(%optGrantTotal)
    #OF(4)
      #SET(%optGrantLine, 'GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE ' & %NFileName)
      #SET(%optGrantCount, 4)
    #OF(3)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(2)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(1)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #ENDCASE
%optGrantLine
    #IF(%optGrantType = 'User')
  TO %optGrantName
    #ELSE
  TO GROUP %optGrantName
    #ENDIF
;
  #ENDFOR

#ENDFOR
#!
#IF(%opt2GrantDoit AND ITEMS(%opt2Grant))

--
-- SQL script creator for POSTGRESQL database [GRANT] - Specific Tables
-- Created: %TheDate - %TheTime
--

  #FOR(%opt2Grant)
    #FIX(%File          , %opt2GrantTable)
#INSERT(%RAModifyNameTable)
    #MESSAGE('Table of: ' & %File,2)
#!
    #IF(%CommentsSQL)                                           #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

    #ENDIF                                                      #! RA.2008.08.13
#!
    #SET(%optGrantType  , %opt2GrantType)
    #SET(%optGrantName  , %opt2GrantName)
    #SET(%optGrantSelect, %opt2GrantSelect)
    #SET(%optGrantInsert, %opt2GrantInsert)
    #SET(%optGrantUpdate, %opt2GrantUpdate)
    #SET(%optGrantDelete, %opt2GrantDelete)
#!
    #SET(%optGrantTotal     , %optGrantSelect + %optGrantInsert + %optGrantUpdate + %optGrantDelete)
    #SET(%optGrantCount     , 0)
    #SET(%optGrantLine      , '')
#!-- TOTAL: %optGrantTotal
    #CASE(%optGrantTotal)
    #OF(4)
      #SET(%optGrantLine, 'GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE ' & %NFileName)
      #SET(%optGrantCount, 4)
    #OF(3)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(2)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(1)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #ENDCASE
%optGrantLine
    #IF(%optGrantType = 'User')
  TO %optGrantName
    #ELSE
  TO GROUP %optGrantName
    #ENDIF
;

  #ENDFOR
#ENDIF

--
-- EOF: %OutGrantName
--
  #CLOSE(%OutGrantName)
  #RUN('NOTEPAD.EXE "' & %OutGrantName & '"')
#ENDCASE
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLIndex)
#CASE(%multiOpt)
#OF(2)                                                          #! RA.2009.01.01 - <*>,ALL
  #SET(%SQLIndexName,%DictName & '__' & %multiDB & '__03_PG.SQL')
  #SET(%OutIndexName,%SQLDirectory & %SQLIndexName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,ALL]',0)
  #MESSAGE('Creating: ' & %SQLIndexName,1)
  #CREATE(%OutIndexName)
--
-- BOF: %OutIndexName
--
-- SQL script creator for POSTGRESQL database %multiDB [INDEX]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE(%SCid > 0)
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaIndex)                                           #! RA.2009.02.25
    #ENDFOR

  #ENDFOR
--
-- EOF: %OutIndexName
--
  #CLOSE(%OutIndexName)
  #RUN('NOTEPAD.EXE "' & %OutIndexName & '"')
#OF(3)                                                          #! RA.2009.01.01 - <*>,<*>
  #SET(%SQLIndexName,%DictName & '__' & %multiDB & '__' & %multiSC & '__03_PG.SQL')
  #SET(%OutIndexName,%SQLDirectory & %SQLIndexName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,<*>]',0)
  #MESSAGE('Creating: ' & %SQLIndexName,1)
  #CREATE(%OutIndexName)
--
-- BOF: %OutIndexName
--
-- SQL script creator for POSTGRESQL database %multiDB [INDEX]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE((%SCid > 0) AND (%SCname = %multiSC))
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaIndex)                                           #! RA.2009.02.25
    #ENDFOR

  #ENDFOR
--
-- EOF: %OutIndexName
--
  #CLOSE(%OutIndexName)
  #RUN('NOTEPAD.EXE "' & %OutIndexName & '"')
#OF(4)                                                          #! RA.2009.01.01 - ALL,<*>
  #MESSAGE('The POSTGRESQL Script Creator [ALL,<*>]',0)
#ELSE                                                           #! RA.2009.01.01 - ALL,ALL
  #MESSAGE('The POSTGRESQL Script Creator [ALL,ALL]',0)
  #SET(%OutIndexName,%SQLDirectory & %SQLIndexName)
  #CREATE(%OutIndexName)
#!  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLIndexName,1)
--
-- BOF: %OutIndexName
--
-- SQL script creator for POSTGRESQL database [KEYS]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, public, pg_catalog
;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%RAModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
#!PRINT '%NFileName'
  #SET(%PrimaryCount,0)                                         #! Primary key exists
  #SET(%SecondaryCount,0)                                       #! Secondary key exists
  #IF(ITEMS(%Key))
    #FOR(%Key)
      #IF(NOT ITEMS(%KeyField))                                 #! Key has fields? No!
        #CYCLE                                                  #! Then go to the next
      #ENDIF                                                    #! key to be processed
#!
      #SET(%nLoc1,INSTRING('RASQL(',%KeyUserOptions,1,1))
      #SET(%nLoc2,INSTRING(')',%KeyUserOptions,1,%nLoc1))
      #SET(%nKeyUser,UPPER(SUB(%KeyUserOptions,%nLoc1,%nLoc2)))
      #!SET(%NKeyUser,UPPER(EXTRACT(%KeyUserOptions,'RASQL')))
      #SET(%NKeyOpt1,EXTRACT(%NKeyUser,'RASQL',1))
      #SET(%NKeyOpt2,EXTRACT(%NKeyUser,'RASQL',2))
      #SET(%NKeyOpt3,EXTRACT(%NKeyUser,'RASQL',3))
      #SET(%NKeyOpt4,EXTRACT(%NKeyUser,'RASQL',4))
#!%NKeyUser, %NKeyOpt1, %NKeyOpt2, %NKeyOpt3, %NKeyOpt4
      #!------------------------------------------------------------!
      #! The first option RASQL(NO) controls if a key is processed. !
      #!------------------------------------------------------------!
      #IF(SUB(%NKeyOpt1,1,1)='N')
        #CYCLE
      #ENDIF
#!
#! -- FileName 00: %NFileName
#INSERT(%RAModifyNameKey00)
#! -- FileName 01: %NFileName
#!
      #SET(%NKeyFields,'')
      #SET(%NKeyFieldCount,0)
      #FOR(%KeyField)
        #SET(%NKeyField, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
        #!-------------------------------------------------------------------------!
        #! RA.2001.12.15 - Table of keyfield-table to be able to create relations. !
        #!-------------------------------------------------------------------------!
        #IF(%DoFieldFile)
          #ADD(%FieldTableList, %NKeyField & ' ==> ' & %File)
        #ENDIF
        #!-----------------------------------------!
        #! RA.2010.09.17 - Check for external name !
        #!-----------------------------------------!
        #FIX(%Field,%KeyField)
        #IF(%UseExtFieldName AND %FieldName)                                                    #! RA.2010.09.13
          #IF(%UseExtFieldQuote)                                                                #! RA.2010.09.13 - Generate External Name w/ Quotes
            #SET(%NKeyField, %FieldName)                                                        #! RA.2010.09.13
          #ELSE                                                                                 #! RA.2010.09.13
            #SET(%NKeyField, SUB(%FieldName,2,LEN(%FieldName)-2))                               #! RA.2010.09.13 - Remove Quotes in External Name
          #ENDIF                                                                                #! RA.2010.09.13
        #ENDIF                                                                                  #! RA.2010.09.13
        #!-----------------------------------------!
        #!-----------------------------------------!
        #!
        #IF(%UsePrefix='All' OR %PrefixColumns)                                 #! RA.2008.08.11
          #SET(%NKeyField, %FilePrefix & '_' & %NKeyField)
        #ENDIF
        #!----------------------------------!
        #! RA.2007.12.26 - Obey the option. !
        #!----------------------------------!
        #IF(NOT %IgnoreReserved)
          #SET(%SqlWordItem, UPPER(%NKeyField))
#!-- SqlWordItem = '%SqlWordItem'
          #FIND(%SqlWordList, %SqlWordItem)
#!-- SqlWordList = '%SqlWordList'
          #IF(%SqlWordList)
            #ADD(%ReservedFieldList, %FoundKeyField & %FilePrefix & ':' & %NKeyField)
            #SET(%NKeyField, %NKeyField & '_')
          #ENDIF
        #ENDIF
        #SET(%NKeyFieldCount,%NKeyFieldCount + 1 )
        #IF(%NKeyFieldCount = 1)
          #SET(%NKeyFields,%NKeyField)
        #ELSE
          #SET(%NKeyFields, %NKeyFields & ', ' & %NKeyField)
        #ENDIF
      #ENDFOR
      #IF(%KeyPrimary)
        #SET(%PrimaryCount, 1)
        #SET(%PKeyCount, %PKeyCount + 1)
        #SET(%KeyCount, %KeyCount + 1)
#!-- 01
ALTER TABLE %NFileName
  ADD CONSTRAINT %NKeyName PRIMARY KEY (%NKeyFields)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON CONSTRAINT %NKeyName ON %NFileName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

      #ELSIF(NOT %KeyPrimary)
        #SET(%KeyOthers, %KeyOthers + 1)
        #SET(%KeyCount, %KeyCount + 1)
        #IF(%KeyDuplicate)
          #CASE(%KeyIndex)
          #OF  ('KEY')
#!-- 02
CREATE INDEX %NKeyName
 #IF(%UseLowerCase)                                             #! MAG 02.21.08
   #!-----------------------------------------------------------------!
   #! RA.2010.09.17 - Problem with multiple fields (some not string). !
   #! For this to work it has to be one field and string.             !
   #!-----------------------------------------------------------------!
   #IF(ITEMS(%KeyField) = 1)                                    #! RA.2010.09.17
     #SET(%NKeyFields,lower(%NKeyFields))                       #! MAG 02.21.08 - Needs generalization
   #ENDIF                                                       #! RA.2010.09.17
 #ENDIF                                                         #! MAG 02.21.08
  ON %NFileName (%NKeyFields)
;
#IF(%UseLowerCase)                                              #! MAG 02.21.08
 #SET(%NKeyName,lower(%NKeyName))                               #! MAG 02.21.08
#ENDIF                                                          #! MAG 02.21.08
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

          #OF  ('INDEX')
          #OROF('DYNAMIC')
#IF(%UseLowerCase)                                              #! MAG 02.21.08
 #SET(%NKeyName, lower(%NKeyName))                              #! MAG 02.21.08
 #SET(%NKeyFields, lower(%NKeyFields))                          #! MAG 02.21.08
#ENDIF                                                          #! MAG 02.21.08
#!-- 03
CREATE INDEX %NKeyName
  ON %NFileName (%NKeyFields)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

          #ENDCASE
        #ELSE
          #CASE(%KeyIndex)
          #OF  ('KEY')
#!-- 04
CREATE UNIQUE INDEX %NKeyName
#IF(%UseLowerCase)                                      #! MAG 02.21.08
  #SET(%NKeyFields,Lower(%NKeyFields))                  #! RA.2008.03.22 - Correction
#ENDIF                                                  #! MAG 02.21.08
  ON %NFileName (%NKeyFields)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

          #OF  ('INDEX')
          #OROF('DYNAMIC')
#!-- 05
CREATE UNIQUE INDEX %NKeyName
  #IF(%UseLowerCase)                                            #! MAG 02.21.08
  ON %NFileName (lower(%NKeyFields))
  #ELSE                                                         #! MAG 02.21.08
  ON %NFileName (%NKeyFields)
  #ENDIF                                                        #! MAG 02.21.08
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
#ENDIF                                                          #! RA.2008.08.13

          #ENDCASE
        #ENDIF
      #ENDIF
    #ENDFOR
    #IF(NOT %PrimaryCount)
--
-- WARNING: %File(%FilePrefix) has no PRIMARY KEY defined.
--
    #ENDIF
  #ELSE
--
-- WARNING: %File(%FilePrefix) has no KEYS defined.
--
  #ENDIF
  #! +++++ RA.2008.08.06 - Special indexes from options here
#ENDFOR
--
-- EOF: %OutIndexName
--
  #CLOSE(%OutIndexName)
  #RUN('NOTEPAD.EXE "' & %OutIndexName & '"')
#ENDCASE
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLRelat)
#CASE(%multiOpt)
#OF(2)                                                          #! RA.2009.01.01 - <*>,ALL
  #SET(%SQLRelatName,%DictName & '__' & %multiDB & '__04_PG.SQL')
  #SET(%OutRelatName,%SQLDirectory & %SQLRelatName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,ALL]',0)
  #MESSAGE('Creating: ' & %SQLRelatName,1)
  #CREATE(%OutRelatName)
--
-- BOF: %OutRelatName
--
-- SQL script creator for POSTGRESQL database %multiDB [RELATION]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE(%SCid > 0)
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #SET(%RelCount, 0)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaRelat)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
--
-- EOF: %OutRelatName
--
  #CLOSE(%OutRelatName)
  #RUN('NOTEPAD.EXE "' & %OutRelatName & '"')
#OF(3)
  #SET(%SQLRelatName,%DictName & '__' & %multiDB & '__' & %multiSC & '__04_PG.SQL')
  #SET(%OutRelatName,%SQLDirectory & %SQLRelatName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,<*>]',0)
  #MESSAGE('Creating: ' & %SQLRelatName,1)
  #CREATE(%OutRelatName)
--
-- BOF: %OutRelatName
--
-- SQL script creator for POSTGRESQL database %multiDB [RELATION]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE((%SCid > 0) AND (%SCname = %multiSC))
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #SET(%RelCount, 0)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaRelat)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
--
-- EOF: %OutRelatName
--
  #CLOSE(%OutRelatName)
  #RUN('NOTEPAD.EXE "' & %OutRelatName & '"')
#OF(4)                                                          #! RA.2009.01.01 - ALL,<*>
  #MESSAGE('The POSTGRESQL Script Creator [ALL,<*>]',0)
#ELSE                                                           #! RA.2009.01.01 - ALL,ALL
  #MESSAGE('The POSTGRESQL Script Creator [ALL,ALL]',0)
  #SET(%OutRelatName,%SQLDirectory & %SQLRelatName)
  #CREATE(%OutRelatName)
#!  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLRelatName,1)
--
-- BOF: %OutRelatName
--
-- SQL script creator for POSTGRESQL database [RELATIONS]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, public, pg_catalog
;

#ENDIF
#!
  #SET(%RelCount, 0)
  #FOR(%ProcFile)                           #! RA.2007.11.25
    #FIX(%File,%ProcFile)                   #! RA.2007.11.25
    #CASE(%FileDriver)
      #OF('ASCII')
    #OROF('BASIC')
    #OROF('DOS')
    #OROF('IN-MEMORY')
        #CYCLE
    #ENDCASE
#!
    #CASE(%FileType)
    #OF  ('VIEW')
#!------------------------------------------------------------!
#! RA.2001.07.22 - Need to deal with aliases for the purpose  !
#! of discovering additional key relationships that can not   !
#! be done with a single file from Clarion. In specific       !
#!                                                            !
#! Tables                                                     !
#!  Party_Table         Party_Relationship_Table              !
#!  Party_Id            Party_Id_From                         !
#!                      Party_Id_To                           !
#! Relations                                                  !
#!  Party_Id    <->>    Party_Id_From                         !
#!  Party_Id    <->>    Party_Id_To                           !
#!                                                            !
#! Clarion would need an alias of Party_Relationship_Table to !
#! deal with the second relationship. There would be no way   !
#! to use the second table again since Clarion restricts that !
#! specific operation.                                        !
#!                                                            !
#! SQL handles these type of relationships correctly and they !
#! need to be generated as an original file relationship.     !
#!------------------------------------------------------------!
#!  #OROF('ALIAS')
        #CYCLE
    #ENDCASE
#!
#INSERT(%RAModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
    #SET(%TheCount, 0)
    #IF(ITEMS(%Relation))
      #FOR(%Relation)
        #SET(%nLoc1,INSTRING('RASQL(',%RelationUserOptions,1,1))
        #SET(%nLoc2,INSTRING(')',%RelationUserOptions,1,%nLoc1))
        #SET(%nRelationUser,UPPER(SUB(%RelationUserOptions,%nLoc1,%nLoc2)))
        #!SET(%NRelationUser,UPPER(EXTRACT(%RelationUserOptions,'RASQL')))
        #SET(%NRelationOpt1,EXTRACT(%NRelationUser,'RASQL',1))
        #SET(%NRelationOpt2,EXTRACT(%NRelationUser,'RASQL',2))
        #SET(%NRelationOpt3,EXTRACT(%NRelationUser,'RASQL',3))
        #SET(%NRelationOpt4,EXTRACT(%NRelationUser,'RASQL',4))
#!-- %FileRelationType
#!-- %NFileName  <=  %NRelateFile [ %FileType ] %AliasFile : %Relation  ==  %RelationAlias
#!-- %NRelationUser, %NRelationOpt1, %NRelationOpt2, %NRelationOpt3, %NRelationOpt4
        #!-----------------------------------------------------------------!
        #! The first option RASQL(NO) controls if a relation is processed. !
        #!-----------------------------------------------------------------!
        #IF(SUB(%NRelationOpt1,1,1)='N')
          #CYCLE
        #ENDIF
#!
        #!--------------------------------------------------------------------!
        #! RA.2007.10.02 - References always go from the child to the parent. !
        #!--------------------------------------------------------------------!
        #IF(%FileRelationType = 'MANY:1')
          #SET(%Relationfield1, '')
          #SET(%Relationfield2, '')
#INSERT(%RAModifyNameKey01)
          #!
#INSERT(%RAModifyNameRelTable)
#!-- [%FileRelationType] %NFileName  <=  %NRelateFile [ %FileType ] %AliasFile : %Relation  ==  %RelationAlias
          #!
          #SET(%RelationField1Count, ITEMS(%FileKeyField))
          #SET(%RelationField2Count, ITEMS(%RelationKeyField))
          #!
          #SET(%NRelateCount, %RelationField1Count)
          #SET(%NRelateComma, %NRelateCount - 1)
          #SET(%NRelateItem, 0)
          #FOR(%FileKeyField)
            #IF(%NRelateItem > %NRelateCount)
              #BREAK
            #ENDIF
            #SET(%FileKeyFieldSave,%FileKeyField)                                                   #! RA.2010.09.25
            #SET(%NRelateItem, %NRelateItem + 1)
            #SET(%NRelateField1, SUB(%FileKeyField,INSTRING(':',%FileKeyField,1,1)+1,50))
            #SET(%NRelateField2, SUB(%FileKeyFieldLink,INSTRING(':',%FileKeyFieldLink,1,1)+1,50))
            #!
#INSERT(%RAModifyNameRelField1)
            #!
#INSERT(%RAModifyNameRelField2)
            #!
            #SET(%RelationField1, %RelationField1 & %NRelateField1)
            #SET(%RelationField2, %RelationField2 & %NRelateField2)
            #IF(%NRelateComma)
              #SET(%NRelateComma, %NRelateComma - 1)
              #SET(%RelationField1, %RelationField1 & ', ')
              #SET(%RelationField2, %RelationField2 & ', ')
            #ENDIF
          #ENDFOR
          #!-------------------------------------------!
          #! RA.2001.01.20 - Added this feature.       !
          #! Has syntax errors, so commented out.      !
          #!-------------------------------------------!
          #! Added to the comments so programmer is at !
          #! aware that other relationships may exist. !
          #!-------------------------------------------!
          #SET(%RelationUpdate,%RelationConstraintUpdate)       #! ON UPDATE ?
          #SET(%RelationDelete,%RelationConstraintDelete)       #! ON DELETE ?
          #!-------------------------------------------!
          #IF(%Relationfield1)
            #MESSAGE('Relation of: ' & %File,2)
            #SET(%RelCount, %RelCount + 1)
            #!----------------------------------------------------------!
            #! RA.2001.07.22 - The alias name gets changed to the real  !
            #! name to generate the SQL statement for the relationship. !
            #!----------------------------------------------------------!
            #IF(%FileType = 'ALIAS')
              #SET(%NFileName,%AliasFile)
              #FIX(%File, %AliasFile)
              #IF(%UsePrefix='All' OR %PrefixTables)                        #! RA.2008.08.11
                #SET(%NFileName,%FilePrefix & '_' & %File)
              #ENDIF
            #ENDIF
            #IF(%TheCount = 0)
#!PRINT '%NFileName'
            #ENDIF
            #SET(%TheCount,%TheCount+1)
ALTER TABLE %NFileName
   ADD CONSTRAINT rel_%NKeyField
   FOREIGN KEY (%Relationfield1)
   REFERENCES %NRelateFile (%Relationfield2)
   #!--------------------------------------------------------!
   #! MG.2008.07.17 - Completed work on the Relationships.   !
   #! RA.2007.10.03 - Work on this - PostgreSQL supports it. !
   #!--------------------------------------------------------!
            #IF(%RelationUpdate)
              #CASE(%RelationUpdate)
              #OF('RESTRICT_SERVER')
   ON UPDATE RESTRICT
              #OF('CASCADE_SERVER')
   ON UPDATE CASCADE
              #OF('CLEAR_SERVER')
              #OROF('CLEAR')
   ON UPDATE SET NULL
              #OF('NONE')
              #OROF('NONE_SERVER')
              #ELSE
   ON UPDATE %RelationUpdate
              #ENDCASE
            #ENDIF
            #IF(%RelationDelete)
              #CASE(%RelationDelete)
              #OF('RESTRICT_SERVER')
   ON DELETE RESTRICT
              #OF('CASCADE_SERVER')
   ON DELETE CASCADE
              #OF('CLEAR_SERVER')
              #OROF('CLEAR')
   ON DELETE SET NULL
              #OF('NONE')
              #OROF('NONE_SERVER')
            #ELSE
   ON DELETE %RelationDelete
              #ENDCASE
            #ENDIF
            #IF(%SQLRelatDefer)
              #IF(SUB(%NRelationOpt3,1,1) = 'Y')
   DEFERRABLE
   INITIALLY DEFERRED
             #ENDIF
           #ENDIF
;
  #IF(%CommentsDB)                                                                                              #! RA.2008.08.13
#SET(%NComment, 'Relation from table (FK) ' & %NFileName & ' to table (PK) ' & %NRelateFile & ' constraint.')   #! RA.2008.08.13
#SET(%NComment, QUOTE(%NComment))                                                                               #! RA.2008.08.13
COMMENT ON CONSTRAINT rel_%NKeyField ON TABLE %NFileName IS
'%NComment'
;
  #ENDIF                                                                                                        #! RA.2008.08.13

          #ENDIF
        #ENDIF
      #ENDFOR
    #ENDIF
  #ENDFOR
--
-- EOF: %OutRelatName
--
  #CLOSE(%OutRelatName)
  #RUN('NOTEPAD.EXE "' & %OutRelatName & '"')
#ENDCASE
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLValid)
#CASE(%multiOpt)
#OF(2)                                                          #! RA.2009.01.01 - <*>,ALL
  #SET(%SQLValidName,%DictName & '__' & %multiDB & '__05_PG.SQL')
  #SET(%OutValidName,%SQLDirectory & %SQLValidName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,ALL]',0)
  #MESSAGE('Creating: ' & %SQLValidName,1)
  #CREATE(%OutValidName)
--
-- BOF: %OutValidName
--
-- SQL script creator for POSTGRESQL database %multiDB [VALIDATION]
-- Created: %TheDate - %TheTime
--
CREATE LANGUAGE plpgsql ;
  #FOR(%dctSC),WHERE(%SCid > 0)
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaValid)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
--
-- EOF: %OutValidName
--
  #CLOSE(%OutValidName)
  #RUN('NOTEPAD.EXE "' & %OutValidName & '"')
#OF(3)                                                          #! RA.2009.01.01 - <*>,<*>
  #SET(%SQLValidName,%DictName & '__' & %multiDB & '__' & %multiSC & '__05_PG.SQL')
  #SET(%OutValidName,%SQLDirectory & %SQLValidName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,<*>]',0)
  #MESSAGE('Creating: ' & %SQLValidName,1)
  #CREATE(%OutValidName)
--
-- BOF: %OutValidName
--
-- SQL script creator for POSTGRESQL database %multiDB [VALIDATION]
-- Created: %TheDate - %TheTime
--
CREATE LANGUAGE plpgsql ;
  #FOR(%dctSC),WHERE((%SCid > 0) AND (%SCname = %multiSC))
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaValid)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
--
-- EOF: %OutValidName
--
  #CLOSE(%OutValidName)
  #RUN('NOTEPAD.EXE "' & %OutValidName & '"')
#OF(4)                                                          #! RA.2009.01.01 - ALL,<*>
  #MESSAGE('The POSTGRESQL Script Creator [ALL,<*>]',0)
#ELSE                                                           #! RA.2009.01.01 - ALL,ALL
  #MESSAGE('The POSTGRESQL Script Creator [ALL,ALL]',0)
  #SET(%OutValidName,%SQLDirectory & %SQLValidName)
  #CREATE(%OutValidName)
#!  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLValidName,1)
--
-- BOF: %OutValidName
--
-- SQL script creator for POSTGRESQL database [VALIDATIONS]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, public, pg_catalog
;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%RAModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
  #FOR(%Field)
    #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
    #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
    #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
    #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
    #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
    #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
    #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
    #!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
    #!--------------------------------------------------------------!
    #! The first option RASQL(NO) controls if a field is processed. !
    #!--------------------------------------------------------------!
    #IF(SUB(%NFieldOpt1,1,1)='N')
      #CYCLE
    #ENDIF
    #!------------------------------------------------!
    #! Begin removal of types that are not processed. !
    #!------------------------------------------------!
    #IF(%FieldType='GROUP')
      #CYCLE
    #ENDIF
    #IF(%FieldType='END')
      #CYCLE
    #ENDIF
    #!--------------------------------------------!
    #! RA.2007.10.03 - Simple name for functions. !
    #!--------------------------------------------!
    #SET(%NFieldName, %FieldID)                                     #! Field Name
    #!
    #SET(%ValTypeDCT        ,UPPER(%FieldType))                     #! Original type from dictionary
    #SET(%ValType           ,'')                                    #! Validation type for backend
    #SET(%ValLength         ,%FieldMemoSize)                        #! Length in characters
    #SET(%ValNumeric        ,%FieldFormatWidth)                     #! Numer of characters in entry control
    #SET(%ValDecimal        ,%FieldPlaces)                          #! Number of decimal places
    #SET(%ValTrue           ,%FieldTrueValue)                       #! TRUE Value
    #SET(%ValFalse          ,%FieldFalseValue)                      #! FALSE Value
    #FREE(%ValList)                                                 #! INLIST values
    #!------------------------------------------------------!
    #! RA.2007.10.04 - Figure type of variable for backend. !
    #!------------------------------------------------------!
    #CASE(%ValTypeDCT)
    #OF('BLOB')                                                     #! This should not make it thru
      #SET(%ValType,'bytea')                                        #! since it is binary data
    #OF('MEMO')
      #SET(%ValType,'text')
    #OF('CSTRING')
      #SET(%ValLength,%ValLength - 1)                               #! Adjust for null terminator
    #ENDCASE
    #!=============================================================!
    #! In some cases it is more accurate to check the display mask !
    #! to determine the web type. Dates can be a LONG or a DATE    !
    #! dictionary type, and the first part of the display mask is  !
    #! going to always be a '@D.                                   !
    #!=============================================================!
    #CASE(SUB(UPPER(%FieldDisplayPicture),1,2))
    #OF('@D')
      #SET(%ValType,'date')
    #OF('@T')
      #SET(%ValType,'time without time zone')
    #OF('@S')
      #SET(%ValType,'text')
      #IF(%ValLength > 255)
        #SET(%ValType,'text')
      #ENDIF
    #OF('@N')
      #SET(%ValType,'integer')
      #IF(%ValDecimal > 0)
        #SET(%ValType,'numeric')
      #ENDIF
    #ENDCASE
    #!================================!
    #!================================!
    #IF(ITEMS(%FieldValues) > 0)
      #FOR(%FieldValues)
        #CASE(%ValType)
        #OF('text')
          #ADD(%ValList,'''' & %FieldValues & '''')
        #ELSE
          #ADD(%ValList,%FieldValues)
        #ENDCASE
      #ENDFOR
    #ENDIF
    #!=================================!
    #! Description setup happens here. !
    #!=================================!
    #CASE(%FieldValidation)                                         #! PREFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
CREATE OR REPLACE FUNCTION %NFileName_%NFieldName_description (param %ValType)
  RETURNS text AS $$
DECLARE
BEGIN
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! LOGIC
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
-- INFILE
    #OF  ('BOOLEAN')
-- BOOLEAN
  RETURN CASE(LOWER(TRIM(param)))
    WHEN 'y' THEN 'Yes'
    WHEN '1' THEN 'Yes'
    WHEN 't' THEN 'Yes'
    WHEN 'n' THEN 'No'
    WHEN '0' THEN 'No'
    WHEN 'f' THEN 'No'
    ELSE ''
  END;
    #OF  ('INRANGE')
-- INRANGE
    #OF  ('INLIST')
-- INLIST
      #CASE(%ValType)
      #OF('text')
  IF LENGTH(param) > %ValLength THEN
    RETURN '';
  END IF;
      #ENDCASE
      #LOOP,FOR(%ValI,1,ITEMS(%ValList))
        #SELECT(%FieldValues, %ValI)
        #SELECT(%FieldChoices, %ValI)
-- %FieldValues = %FieldChoices
      #ENDLOOP
      #IF(ITEMS(%ValList) > 0)
  RETURN CASE param
      #LOOP,FOR(%ValI,1,ITEMS(%ValList))
        #SELECT(%FieldValues, %ValI)
        #SELECT(%FieldChoices, %ValI)
        #CASE(%ValType)
        #OF('text')
    WHEN '%FieldValues' THEN '%FieldChoices'
        #ELSE
    WHEN %FieldValues THEN '%FieldChoices'
        #ENDCASE
      #ENDLOOP
    ELSE ''
  END;
      #ENDIF
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! POSTFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
  RETURN '';
END;
$$ LANGUAGE plpgsql
;
  #IF(%CommentsDB)                                                                  #! RA.2008.08.13
#SET(%NComment, 'TABLE ' & %NFileName & ' FIELD ' & %NFieldName & ' DESCRIPTION.')  #! RA.2008.08.12
#SET(%NComment, QUOTE(%NComment))                                                   #! RA.2008.08.12
COMMENT ON FUNCTION %NFileName_%NFieldName_description (param %ValType) IS
'%NComment'
;
  #ENDIF                                                                            #! RA.2008.08.13

    #ENDCASE
    #!================================!
    #! Validation setup happens here. !
    #!================================!
    #CASE(%FieldValidation)                                         #! PREFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
CREATE OR REPLACE FUNCTION %NFileName_%NFieldName_validate (param %ValType)
  RETURNS boolean AS $$
DECLARE
BEGIN
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! LOGIC
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
-- INFILE
    #OF  ('BOOLEAN')
-- BOOLEAN
      #CASE(%ValType)
      #OF('text')
        #SET(%ValTrue, '''' & %ValTrue & '''')
        #SET(%ValFalse, '''' & %ValFalse & '''')
  IF LENGTH(param) > %ValLength THEN
    RETURN FALSE;
  END IF;
      #ENDCASE
  IF    param = %ValTrue THEN RETURN TRUE;
  ELSIF param = %ValFalse THEN RETURN TRUE;
  END IF;
    #OF  ('INRANGE')
-- INRANGE
    #OF  ('INLIST')
-- INLIST
      #CASE(%ValType)
      #OF('text')
  IF LENGTH(param) > %ValLength THEN
    RETURN FALSE;
  END IF;
      #ENDCASE
      #LOOP,FOR(%ValI,1,ITEMS(%ValList))
        #SELECT(%FieldValues, %ValI)
        #SELECT(%FieldChoices, %ValI)
-- %FieldValues = %FieldChoices
      #ENDLOOP
      #IF(ITEMS(%ValList) > 0)
  RETURN CASE param
        #FOR(%ValList)
    WHEN %ValList THEN TRUE
        #ENDFOR
    ELSE FALSE
  END;
      #ENDIF
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! POSTFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql
;
  #IF(%CommentsDB)                                                                  #! RA.2008.08.13
#SET(%NComment, 'TABLE ' & %NFileName & ' FIELD ' & %NFieldName & ' VALIDATION.')   #! RA.2008.08.12
#SET(%NComment, QUOTE(%NComment))                                                   #! RA.2008.08.12
COMMENT ON FUNCTION %NFileName_%NFieldName_validate (param %ValType) IS
'%NComment'
;
  #ENDIF                                                                            #! RA.2008.08.13

      #IF(%SQLValidCheck)
ALTER TABLE %NFileName ADD CONSTRAINT bad_%NFileName_%NFieldName
  CHECK (%NFileName_%NFieldName_validate(%NFieldName))
;

      #ENDIF
    #ENDCASE
  #ENDFOR
#ENDFOR
--
-- EOF: %OutValidName
--
  #CLOSE(%OutValidName)
  #RUN('NOTEPAD.EXE "' & %OutValidName & '"')
#ENDCASE
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLTrigr)
#CASE(%multiOpt)
#OF(2)                                                          #! RA.2009.01.01 - <*>,ALL
  #SET(%SQLTrigrName,%DictName & '__' & %multiDB & '__06_PG.SQL')
  #SET(%OutTrigrName,%SQLDirectory & %SQLTrigrName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,ALL]',0)
  #MESSAGE('Creating: ' & %SQLTrigrName,1)
  #CREATE(%OutTrigrName)
--
-- BOF: %OutTrigrName
--
-- SQL script creator for POSTGRESQL database %multiDB [TRIGGER]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE(%SCid > 0)
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaTrigr)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
--
-- EOF: %OutTrigrName
--
  #CLOSE(%OutTrigrName)
  #RUN('NOTEPAD.EXE "' & %OutTrigrName & '"')
#OF(3)                                                          #! RA.2009.01.01 - <*>,<*>
  #SET(%SQLTrigrName,%DictName & '__' & %multiDB & '__' & %multiSC & '__06_PG.SQL')
  #SET(%OutTrigrName,%SQLDirectory & %SQLTrigrName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,<*>]',0)
  #MESSAGE('Creating: ' & %SQLTrigrName,1)
  #CREATE(%OutTrigrName)
--
-- BOF: %OutTrigrName
--
-- SQL script creator for POSTGRESQL database %multiDB [TRIGGER]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE((%SCid > 0) AND (%SCname = %multiSC))
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaTrigr)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
--
-- EOF: %OutTrigrName
--
  #CLOSE(%OutTrigrName)
  #RUN('NOTEPAD.EXE "' & %OutTrigrName & '"')
#OF(4)                                                          #! RA.2009.01.01 - ALL,<*>
  #MESSAGE('The POSTGRESQL Script Creator [ALL,<*>]',0)
#ELSE                                                           #! RA.2009.01.01 - ALL,ALL
  #MESSAGE('The POSTGRESQL Script Creator [ALL,ALL]',0)
  #SET(%OutTrigrName,%SQLDirectory & %SQLTrigrName)
  #CREATE(%OutTrigrName)
#!  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLTrigrName,1)
--
-- BOF: %OutTrigrName
--
-- SQL script creator for POSTGRESQL database [TRIGGER]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, public, pg_catalog
;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%RAModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
  #FREE(%TriggerList)                                           #! TRIGGER list
  #SET(%TriggerBefore       , 0)                                #! RA.2008.06.30
  #SET(%TriggerAfter        , 0)                                #! RA.2008.06.30
#!
  #FOR(%Field)
    #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
    #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
    #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
    #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
    #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
    #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
    #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
    #!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
    #!--------------------------------------------------------------!
    #! The first option RASQL(NO) controls if a field is processed. !
    #!--------------------------------------------------------------!
    #IF(SUB(%NFieldOpt1,1,1)='N')
      #CYCLE
    #ENDIF
    #!------------------------------------------------!
    #! Begin removal of types that are not processed. !
    #!------------------------------------------------!
    #IF(%FieldType='GROUP')
      #CYCLE
    #ENDIF
    #IF(%FieldType='END')
      #CYCLE
    #ENDIF
    #!--------------------------------------------!
    #! RA.2007.10.03 - Simple name for functions. !
    #!--------------------------------------------!
    #SET(%NFieldName, %FieldID)                                     #! Field Name
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLBEFOREINSERT'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLBEFOREINSERT',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'BEFORE')
      #SET(%TriggerOp       , 'INSERT')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerBefore   , %TriggerBefore + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLBEFOREUPDATE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLBEFOREUPDATE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'BEFORE')
      #SET(%TriggerOp       , 'UPDATE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerBefore   , %TriggerBefore + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLBEFOREDELETE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLBEFOREDELETE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'BEFORE')
      #SET(%TriggerOp       , 'DELETE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerBefore   , %TriggerBefore + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLAFTERINSERT'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLAFTERINSERT',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'AFTER')
      #SET(%TriggerOp       , 'INSERT')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerAfter    , %TriggerAfter + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLAFTERUPDATE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLAFTERUPDATE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'AFTER')
      #SET(%TriggerOp       , 'UPDATE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerAfter    , %TriggerAfter + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLAFTERDELETE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLAFTERDELETE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'AFTER')
      #SET(%TriggerOp       , 'DELETE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerAfter    , %TriggerAfter + 1)
    #ENDIF
  #ENDFOR
#!
  #IF(ITEMS(%TriggerList))
    #FOR(%TriggerList)
--        == %TriggerWhen == %TriggerOp == %TriggerStmt ==
    #ENDFOR
  #ENDIF
#!
  #IF(ITEMS(%TriggerList))
CREATE OR REPLACE FUNCTION %NFileName_trigger()
  RETURNS "trigger"
AS $$
BEGIN

IF    (TG_WHEN = 'BEFORE') THEN
  IF    (TG_OP = 'INSERT') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'BEFORE' AND %TriggerOp = 'INSERT')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'UPDATE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'BEFORE' AND %TriggerOp = 'UPDATE')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'DELETE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'BEFORE' AND %TriggerOp = 'DELETE')
    %TriggerStmt
    #ENDFOR
  END IF;
  RETURN NEW;
ELSIF (TG_WHEN = 'AFTER') THEN
  IF    (TG_OP = 'INSERT') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'AFTER' AND %TriggerOp = 'INSERT')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'UPDATE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'AFTER' AND %TriggerOp = 'UPDATE')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'DELETE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'AFTER' AND %TriggerOp = 'DELETE')
    %TriggerStmt
    #ENDFOR
  END IF;
  RETURN OLD;
END IF;

END $$
LANGUAGE plpgsql VOLATILE
;
    #IF(%SQLTrigrConnect)
      #IF(%TriggerBefore)
CREATE TRIGGER trigger_%NFileName_before
  BEFORE INSERT OR UPDATE OR DELETE ON %NFileName
  FOR EACH ROW EXECUTE PROCEDURE %NFileName_trigger()
;
      #ENDIF
      #IF(%TriggerAfter)
CREATE TRIGGER trigger_%NFileName_after
  AFTER INSERT OR UPDATE OR DELETE ON %NFileName
  FOR EACH ROW EXECUTE PROCEDURE %NFileName_trigger()
;
      #ENDIF
    #ENDIF

  #ENDIF
  #FREE(%TriggerList)                                               #! TRIGGER list
#ENDFOR
--
-- EOF: %OutTrigrName
--
  #CLOSE(%OutTrigrName)
  #RUN('NOTEPAD.EXE "' & %OutTrigrName & '"')
#ENDCASE
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#IF(%SQLViews)
#CASE(%multiOpt)
#OF(2)                                                          #! RA.2009.01.01 - <*>,ALL
  #SET(%SQLViewsName,%DictName & '__' & %multiDB & '__07_PG.SQL')
  #SET(%OutViewsName,%SQLDirectory & %SQLViewsName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,ALL]',0)
  #MESSAGE('Creating: ' & %SQLViewsName,1)
  #CREATE(%OutViewsName)
--
-- BOF: %OutViewsName
--
-- SQL script creator for POSTGRESQL database %multiDB [VIEWS]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE(%SCid > 0)
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaViews)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
--
-- EOF: %OutViewsName
--
  #CLOSE(%OutViewsName)
  #RUN('NOTEPAD.EXE "' & %OutViewsName & '"')
#OF(3)                                                          #! RA.2009.01.01 - <*>,<*>
  #SET(%SQLViewsName,%DictName & '__' & %multiDB & '__' & %multiSC & '__07_PG.SQL')
  #SET(%OutViewsName,%SQLDirectory & %SQLViewsName)
  #MESSAGE('The POSTGRESQL Script Creator [<*>,<*>]',0)
  #MESSAGE('Creating: ' & %SQLViewsName,1)
  #CREATE(%OutViewsName)
--
-- BOF: %OutViewsName
--
-- SQL script creator for POSTGRESQL database %multiDB [VIEWS]
-- Created: %TheDate - %TheTime
--
  #FOR(%dctSC),WHERE((%SCid > 0) AND (%SCname = %multiSC))
    #SET(%ProcFileFound, %FALSE)
    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#!--00-- ProcFile='%ProcFile', ProcFileDB='%ProcFileDB', ProcFileSC='%ProcFileSC'
      #SET(%ProcFileFound, %TRUE)
      #BREAK
    #ENDFOR
    #IF(NOT %ProcFileFound)
      #CYCLE
    #ENDIF

SET search_path TO %SCname, public, pg_catalog ;

    #FOR(%ProcFile),WHERE((%ProcFileDB = %multiDB) AND (%ProcFileSC = %SCname))
#INSERT(%SchemaViews)                                           #! RA.2009.02.25
    #ENDFOR
  #ENDFOR
--
-- EOF: %OutViewsName
--
  #CLOSE(%OutViewsName)
  #RUN('NOTEPAD.EXE "' & %OutViewsName & '"')
#OF(4)                                                          #! RA.2009.01.01 - ALL,<*>
  #MESSAGE('The POSTGRESQL Script Creator [ALL,<*>]',0)
#ELSE                                                           #! RA.2009.01.01 - ALL,ALL
  #MESSAGE('The POSTGRESQL Script Creator [ALL,ALL]',0)
  #SET(%OutViewsName,%SQLDirectory & %SQLViewsName)
  #CREATE(%OutViewsName)
#!  #MESSAGE('The POSTGRESQL Script Creator',0)
  #MESSAGE('Creating: ' & %SQLViewsName,1)
--
-- BOF: %OutViewsName
--
-- SQL script creator for POSTGRESQL database [VIEWS]
-- Created: %TheDate - %TheTime
--

#IF(%UseSchemaName)
SET search_path TO %SchemaName, public, pg_catalog
;

#ENDIF
#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%RAModifyNameTable)
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

  #ENDIF                                                        #! RA.2008.08.13
  #!------------------------------------------------------------------------!
  #! IF it IS a primary key, AND it is an integer, AND NOT auto-increment,  !
  #! AND there is one item in the key (only thing I can be sure about),     !
  #! THEN assume that it IS an auto-increment handled by the SQL backend.   !
  #!------------------------------------------------------------------------!
  #SET(%NFNameAuto,'')
  #SET(%AutoIncrementCount,0)
  #IF(ITEMS(%Key))
    #FOR(%Key)
#!---- Key        = %Key
      #IF(%KeyPrimary <> 1)
        #CYCLE
      #ENDIF
#!---- KeyPrimary = %KeyPrimary
      #IF(%KeyAuto = 1)
        #CYCLE
      #ENDIF
#!---- KeyAuto    = %KeyAuto
#!
      #IF(ITEMS(%KeyField) > 1)
        #CYCLE
      #ENDIF
#!
      #FOR(%KeyField)
#!---- KeyField   = %KeyField
        #FIX(%Field,%KeyField)
#!---- Field      = %Field
#!---- FieldType  = %FieldType
        #CASE(%FieldType)
        #OF('LONG')
          #SET(%NFNameAuto, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
          #!-------------------------------------------!
          #! RA.2010.09.13 - EXTERNAL name processing. !
          #!-------------------------------------------!
          #FIX(%Field,%KeyField)                                                                #! RA.2020.09.17
          #IF(%UseExtFieldName AND %FieldName)                                                  #! RA.2010.09.13
            #IF(%UseExtFieldQuote)                                                              #! RA.2010.09.13 - Generate External Name w/ Quotes
              #SET(%NFNameAuto, %FieldName)                                                     #! RA.2010.09.13
            #ELSE                                                                               #! RA.2010.09.13
              #SET(%NFNameAuto, SUB(%FieldName,2,LEN(%FieldName)-2))                            #! RA.2010.09.13 - Remove Quotes in External Name
            #ENDIF                                                                              #! RA.2010.09.13
          #ENDIF                                                                                #! RA.2010.09.13
          #!-------------------------------------------!
          #!-------------------------------------------!
        #ENDCASE
      #ENDFOR
#!
      #IF(%NFNameAuto)
#!---- NFNameAuto = %NFNameAuto
        #SET(%AutoIncrementCount,%AutoIncrementCount + 1)
        #SET(%AutoCount, %AutoCount + 1)
#!        #SET(%NFNameAuto, SUB(%KeyAuto, INSTRING(':',%KeyAuto,1,1) + 1 , 50))
        #IF(%UsePrefix='All' OR %PrefixColumns)                                 #! RA.2008.08.11
          #SET(%NFNameAuto, %FilePrefix & '_' & %NFNameAuto)
        #ENDIF
        #!---------------------------------------------!
        #! RA.2007.10.10 - Behave according to option. !
        #!---------------------------------------------!
        #IF(NOT %IgnoreReserved)
          #SET(%SqlWordItem, UPPER(%NFNameAuto))
          #FIND(%SqlWordList, %SqlWordItem)
          #IF(%SqlWordList)
            #ADD(%ReservedFieldList, %FoundAIKeyName & %FilePrefix & ':' & %NFNameAuto)
            #SET(%NFNameAuto, %NFNameAuto & '_')
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDFOR
    #IF(%AutoIncrementCount = 0)
#!-- WARNING: %File(%FilePrefix) has no AUTO-INCREMENT KEY defined.
    #ENDIF
  #ENDIF
#!--
#!-- '%NFilePrefix' = '%NFileName' = '%NFNameAuto'
#!--
CREATE OR REPLACE VIEW list_%NFileName_00 AS
SELECT %NFilePrefix.*
FROM %NFileName AS %NFilePrefix
  #!-------------------------------------------------------------------------!
  #! RA.2011.04.09 - If there is no primary key, DO NOT output a sort order. !
  #!-------------------------------------------------------------------------!
  #IF(%NFNameAuto)
ORDER BY %NFilePrefix.%NFNameAuto
  #ENDIF
;
  #IF(%CommentsDB)                                                                              #! RA.2008.08.13
    #IF(%NFNameAuto)
#SET(%NComment, 'LIST (' & %NFilePrefix & ') ' & %FileDescription & ' ORDER BY primary id.')    #! RA.2008.08.12
    #ELSE
#SET(%NComment, 'LIST (' & %NFilePrefix & ') ' & %FileDescription & ' (NO ORDER).')             #! RA.2011.04.09
    #ENDIF
#SET(%NComment, QUOTE(%NComment))                                                               #! RA.2008.08.12
COMMENT ON VIEW list_%NFileName_00 IS
'%NComment'
;
  #ENDIF                                                                                        #! RA.2088.0813

#ENDFOR
--
-- EOF: %OutViewsName
--
  #CLOSE(%OutViewsName)
  #RUN('NOTEPAD.EXE "' & %OutViewsName & '"')
#ENDCASE
#ENDIF
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA MARKER - SEARCH FOR ME
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%RASQLField)
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#! Dump the fields here for a PostgreSQL database back end.           !
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#SET(%InnerGroup, 0)
#SET(%FieldComma, ITEMS(%Field) - 1)
#!
#FOR(%Field)
#! FieldComma='%FieldComma'
  #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
  #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
  #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
  #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
  #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
  #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
#!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
  #!--------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a field is processed. !
  #!--------------------------------------------------------------!
  #! WARNING: The last field can NOT be an ommited field.         !
  #!--------------------------------------------------------------!
  #! And if the last field happens to be and 'END', you will need !
  #! to add a RASQL(END) to the last field before the 'END'. This !
  #! will suppress the last comma. Reality sometimes happens.     !
  #!--------------------------------------------------------------!
  #IF(SUB(%NFieldOpt1,1,1)='N')
    #SET(%FieldComma, %FieldComma - 1)
    #CYCLE
  #ENDIF
#!
  #!------------------------------------------------!
  #! Begin removal of types that are not processed. !
  #!------------------------------------------------!
  #IF(%FieldType='GROUP')
    #SET(%InnerGroup, %InnerGroup + 1)
    #IF(INSTRING('OVER(',%FieldStatement,1,1))
      #!SET(%FieldCount, %FieldCount + 1)                       #! RA.2001.01.15
      #!SET(%FieldComma, %FieldComma - 1)                       #! RA.2001.01.12
    #ENDIF
    #SET(%FieldComma, %FieldComma - 1)                          #! RA.2001.01.12
    #CYCLE
  #ENDIF
  #IF(%FieldType='END')
    #SET(%InnerGroup, %InnerGroup - 1)
    #SET(%FieldComma, %FieldComma - 1)
    #CYCLE
  #ENDIF
  #!------------------------------------------------!
  #! Ended removal of types that are not processed. !
  #!------------------------------------------------!
  #SET(%NFieldType,     '')                                     #! Field type
  #SET(%NFieldName,     '')                                     #! Field name
  #SET(%NFieldTSql,     '')                                     #! Field SQL type
  #SET(%NFieldTDef,     '')                                     #! Field SQL default
  #SET(%NFieldDef,      '')                                     #! Field default
  #SET(%NFieldAuto,     '')                                     #! Field AUTO_INCREMENT
  #SET(%NFieldNN,       '')                                     #! Field NOT NULL
  #SET(%NFieldSize,     0)                                      #! Field decimal size
  #SET(%NFieldDec,      0)                                      #! Field decimal places
  #!
  #!--------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL option identifying SERIAL field type (YES,NO). !
  #!--------------------------------------------------------------------!
  #SET(%nFieldOpt0,'')
  #SET(%nLoc1,INSTRING('ISIDENTITY(',UPPER(%FieldUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
  #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
  #SET(%nFieldOpt0,EXTRACT(%nFieldUser,'ISIDENTITY',1))
  #!
#INSERT(%RAModifyNameField)
  #!
  #SET(%FD1L,%FieldDimension1)                                  #! Name 1 made shorter
  #SET(%FD2L,%FieldDimension2)                                  #! Name 2 made shorter
  #SET(%FD3L,%FieldDimension3)                                  #! Name 3 made shorter
  #SET(%FD4L,%FieldDimension4)                                  #! Name 4 made shorter
  #IF(%FD1L>0)                                                  #! IF we got array field,
-- Found "%NFieldName" that is an ARRAY field --
    #IF(NOT %NoArrayOver)                                       #! AND we got groups,
      #SET(%FieldComma, %FieldComma - 1)                        #! THEN ignore the array
      #CYCLE                                                    #! field since the fields
    #ENDIF                                                      #! in the group are going
  #ENDIF                                                        #! to define the array.
#!
  #SET(%FieldCount, %FieldCount + 1)                            #! Add to field count
#!
  #!----------------------------------------------------------------!
  #! The second option RASQL(,<FieldType>) overrides the field type !
  #! in the dictionary. This allows conversion of data types that   !
  #! have no existance in the dictionary but exist in the SQL.      !
  #!----------------------------------------------------------------!
  #SET(%NFieldType, %FieldType)
  #IF(%NFieldOpt2)
    #SET(%NFieldType, %NFieldOpt2)
  #ENDIF
#!
  #!----------------------------------------------------!
  #! Calculate decimal size and places for some fields. !
  #! Only DECIMAL fields have characters and decimals.  !
  #! Everything else that needs it, is figured out from !
  #! the display mask used.                             !
  #!----------------------------------------------------!
  #! RAS.2001.01.12 - Added additional MySQL types.     !
  #!----------------------------------------------------!
  #SET(%NLeadZero, 0)                                           #! NO leading zero
  #SET(%NFieldSize, %FieldMemoSize)                             #! Field decimal size
  #SET(%NFieldDec, %FieldPlaces)                                #! Field decimal places
  #CASE(%NFieldType)
  #OF  ('DEC')                                                  #! NFieldOpt2: MySQL
  #OROF('NUMERIC')                                              #! NFieldOpt2: MySQL
  #OROF('SREAL')
  #OROF('BFLOAT4')
  #OROF('FLOAT')                                                #! NFieldOpt2: MySQL
  #OROF('FLOAT4')                                               #! NFieldOpt2: MySQL
  #OROF('REAL')
  #OROF('BFLOAT8')
  #OROF('DOUBLE')                                               #! NFieldOpt2: MySQL
  #OROF('FLOAT8')                                               #! NFieldOpt2: MySQL
    #SET(%nLoc1,INSTRING('-',%FieldDisplayPicture,1,1))
    #SET(%nLoc1a,INSTRING('_',UPPER(%FieldDisplayPicture),1,1)) #! RA.2009.04.11
    #IF(%nLoc1a > %nLoc1)                                       #! RA.2009.04.11
      #SET(%nLoc1,%nLoc1a)                                      #! RA.2009.04.11
    #ENDIF                                                      #! RA.2009.04.11
    #!#IF(NOT %nLoc1)
    #!  #SET(%nLoc1,INSTRING('_',UPPER(%FieldDisplayPicture),1,1))
    #!#ENDIF
    #IF(NOT %nLoc1)
      #SET(%nLoc1,INSTRING('N',UPPER(%FieldDisplayPicture),1,1))
    #ENDIF
    #SET(%nLoc2,INSTRING('.',%FieldDisplayPicture,1,1))
    #SET(%NFieldSize,SUB(%FieldDisplayPicture,(%nLoc1+1),(%nLoc2-1)))
    #SET(%NFieldDec,SUB(%FieldDisplayPicture,(%nLoc2+1),LEN(%FieldDisplayPicture)))
  #!--------------------------------------------------------!
  #! RAS.2001.10.23 - Parse sizes for non-decimal numerics. !
  #! And set the leading zero flag if you find the need.    !
  #!--------------------------------------------------------!
  #OF  ('LONG')
  #OROF('ULONG')
  #OROF('SHORT')
  #OROF('USHORT')
  #OROF('BYTE')
    #SET(%nLoc1,INSTRING('-',%FieldDisplayPicture,1,1))
    #SET(%nLoc1a,INSTRING('_',UPPER(%FieldDisplayPicture),1,1)) #! RA.2009.04.11
    #IF(%nLoc1a > %nLoc1)                                       #! RA.2009.04.11
      #SET(%nLoc1,%nLoc1a)                                      #! RA.2009.04.11
    #ENDIF                                                      #! RA.2009.04.11
    #!#IF(NOT %nLoc1)
    #!  #SET(%nLoc1,INSTRING('_',UPPER(%FieldDisplayPicture),1,1))
    #!#ENDIF
    #IF(NOT %nLoc1)
      #SET(%nLoc1,INSTRING('N',UPPER(%FieldDisplayPicture),1,1))
    #ENDIF
    #SET(%nLoc2,(LEN(%FieldDisplayPicture) - %nLoc1 + 1))
    #SET(%NFieldSize,SUB(%FieldDisplayPicture,(%nLoc1+1),(%nLoc2-1)))
    #SET(%NLeadZero,INSTRING('N0',UPPER(%FieldDisplayPicture),1,1))
  #ENDCASE
#!-- "%FieldDisplayPicture", %nLoc1, %nLoc2, (%NFieldSize, %NFieldDec), %NLeadZero
  #!------------------------------------------------------!
  #! Deal with the dictionary field type conversion here. !
  #!------------------------------------------------------!
  #CASE(%NFieldType)
  #OF  ('UUID')
    #SET(%NFieldTSQL, 'UUID')
    #SET(%NFieldTDef, 'UUID')                                   #! RA.2008.08.19
  #OF ('UUID1')
    #SET(%NFieldTSQL, 'UUID DEFAULT uuid_generate_v1()')
    #SET(%NFieldTDef, 'UUID')                                   #! RA.2008.08.19
  #OF ('UUID2')
    #SET(%NFieldTSQL, 'UUID DEFAULT uuid_generate_v1mc()')
    #SET(%NFieldTDef, 'UUID')                                   #! RA.2008.08.19
  #OF ('UUID3')
    #SET(%NFieldTSQL, 'UUID DEFAULT uuid_generate_v4()')
    #SET(%NFieldTDef, 'UUID')                                   #! RA.2008.08.19
  #OF  ('BLOB')
    #IF(%VarCharSpecial)                                        #! RA.2007.10.24
      #IF(%FieldMemoSize < %NVarcharLen)
        #SET(%NFieldTSql, 'CHAR(' & %FieldMemoSize & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ELSE
        #SET(%NFieldTSql, 'VARCHAR(' & %FieldMemoSize & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ENDIF
    #ELSE                                                       #! RA.2007.10.24
      #SET(%NFieldTSql, 'VARCHAR(' & %FieldMemoSize & ')' )     #! RA.2007.10.24
      #SET(%NFieldTDef, 'CHAR')                                 #! RA.2007.10.27
    #ENDIF                                                      #! RA.2007.10.24
#!
    #SET(%NFieldTSql, 'BYTEA')                                  #! RA.2008.08.06
    #SET(%NFieldTDef, 'BYTEA')                                  #! RA.2008.08.06
  #OF  ('MEMO')
    #SET(%NFieldTSql, 'TEXT')                                   #! RA.2008.08.06
    #SET(%NFieldTDef, 'TEXT')                                   #! RA.2008.08.06
  #OF  ('STRING')
    #IF(%VarCharSpecial)                                        #! RA.2007.10.24
      #IF(%FieldMemoSize < %NVarcharLen)
        #SET(%NFieldTSql, 'CHAR(' & %FieldMemoSize & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ELSE
        #SET(%NFieldTSql, 'VARCHAR(' & %FieldMemoSize & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ENDIF
    #ELSE                                                       #! RA.2007.10.24
      #SET(%NFieldTSql, 'CHAR(' & %FieldMemoSize & ')' )        #! RA.2007.10.24
      #SET(%NFieldTDef, 'CHAR')                                 #! RA.2007.10.27
    #ENDIF                                                      #! RA.2007.10.24
  #OF  ('CSTRING')
  #OROF('PSTRING')
    #SET(%CStringLen, %FieldMemoSize - 1)
    #IF(%VarCharSpecial)                                        #! RA.2007.10.24
      #IF(%CStringLen < %NVarcharLen)
        #SET(%NFieldTSql, 'CHAR(' & %CStringLen & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ELSE
        #SET(%NFieldTSql, 'VARCHAR(' & %CStringLen & ')' )
        #SET(%NFieldTDef, 'CHAR')                               #! RA.2007.10.27
      #ENDIF
    #ELSE                                                       #! RA.2007.10.24
      #SET(%NFieldTSql, 'VARCHAR(' & %CStringLen & ')' )        #! RA.2007.10.24
      #SET(%NFieldTDef, 'CHAR')                                 #! RA.2007.10.27
    #ENDIF                                                      #! RA.2007.10.24
  #OF  ('PICTURE')
    #IF(%PicAsChar)
      #SET(%NFieldTSql, 'CHAR(' & %FieldMemoSize & ')' )
      #SET(%NFieldTDef, 'CHAR')                                 #! RA.2007.10.27
    #ELSE
      #SET(%NFieldTSql,'***' & %NFieldType & '***')
    #ENDIF
  #OF  ('LONG')
  #OROF('INT')
  #OROF('INT4')
  #OROF('INTEGER')
      #!------------------------------------------------------!
      #! RA.2008.03.22 - This will have to be further tested. !
      #! It might not be necessary since the SERIAL overide   !
      #! exists at the field level. There are complications.  !
      #!------------------------------------------------------!
      #!#IF(%nFieldOpt0)
      #!  #IF (NOT %UseSerial)
      #!    #SET(%NFieldTSqL, 'SERIAL')
      #!  #ELSE
      #!    #SET(%NFieldTSql, 'INT')
      #!  #ENDIF
      #!#ELSE
        #SET(%NFieldTSql, 'INT')
      #!#ENDIF
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
    #IF(INSTRING('@D',UPPER(%FieldRecordPicture),1,1))
      #SET(%NFieldTSql, 'DATE')
      #SET(%NFieldTDef, 'DATE')                                 #! RA.2007.10.27
    #ENDIF
    #IF(INSTRING('@D',UPPER(%FieldDisplayPicture),1,1))
      #SET(%NFieldTSql, 'DATE')
      #SET(%NFieldTDef, 'DATE')                                 #! RA.2007.10.27
    #ENDIF
    #IF(INSTRING('@T',UPPER(%FieldRecordPicture),1,1))
      #SET(%NFieldTSql, 'TIME')
      #SET(%NFieldTSql, 'TIME WITHOUT TIME ZONE')               #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTDef, 'TIME')                                 #! RA.2007.10.27
    #ENDIF
    #IF(INSTRING('@T',UPPER(%FieldDisplayPicture),1,1))
      #SET(%NFieldTSql, 'TIME')
      #SET(%NFieldTSql, 'TIME WITHOUT TIME ZONE')               #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTDef, 'TIME')                                 #! RA.2007.10.27
    #ENDIF
  #OF  ('BYTE')
  #OROF('UTINYINT')
  #OROF('UINT1')
      #SET(%NFieldTSql, 'SMALLINT: --BYTE-- NOT SUPPORTED CHANGE YOUR DICTIONARY')
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
  #OF  ('SHORT')
  #OROF('SMALLINT')
  #OROF('INT2')
      #SET(%NFieldTSql, 'SMALLINT')
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
  #OF  ('ULONG')
  #OROF('UINT')
  #OROF('UINT4')
      #SET(%NFieldTSql, 'INT')
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
  #OF  ('USHORT')
  #OROF('USMALLINT')
  #OROF('UINT2')
      #SET(%NFieldTSql, 'SMALLINT')
      #SET(%NFieldTDef, 'NUMBER')                               #! RA.2007.10.27
  #OF  ('DECIMAL')
  #OROF('PDECIMAL')
  #OROF('DEC')
  #OROF('NUMERIC')
      #SET(%NFieldTSql, 'DECIMAL(' & %NFieldSize & ',' & %NFieldDec & ')')
      #SET(%NFieldTDef, 'NUMBER')                                               #! RA.2007.10.27
  #!---------------------------------------------------------------------!
  #! RAS.2001.01.09 - IMPORTANT - READ THIS NOW.                         !
  #!---------------------------------------------------------------------!
  #! There is a very big assumption here that your doing a business type !
  #! application so you want to convert binary inaccurate formats to the !
  #! totally binary (financial) accurate format of DECIMAL.              !
  #!---------------------------------------------------------------------!
  #! I get tired of those hours of time spent on penny off errors on     !
  #! financial screens and reports with a calculator to finally come up  !
  #! with the solution of "It is a rounding error!" due to the binary    !
  #! inaccurate format representation of "floats" and "doubles" that     !
  #! are often used to represent money amounts with an actual fractional !
  #! point part for the cents. This happens often in older applications  !
  #! written in languages that did not have a decimal type and with      !
  #! people that did not have experience or knowledge enough to save     !
  #! those financial amounts as whole pennies and adjust their formulas. !
  #!---------------------------------------------------------------------!
  #! If you need the SREAL (4 bytes) and REAL (8 bytes) left alone then  !
  #! move them somewhere else.                                           !
  #!---------------------------------------------------------------------!
  #OF  ('SREAL')
  #OROF('BFLOAT4')
  #OROF('FLOAT')
  #OROF('FLOAT4')
  #OROF('REAL')
      #SET(%NFieldTSql, 'DECIMAL(' & %NFieldSize & ',' & %NFieldDec & ')')
      #SET(%NFieldTDef, 'NUMBER')                                               #! RA.2007.10.27
      #IF(%NFieldOpt2)                                                          #! RA.2009.03.09
        #SET(%NFieldTSql, %NFieldOpt2)                                          #! RA.2009.03.09
      #ENDIF                                                                    #! RA.2009.03.09
  #OF  ('BFLOAT8')
  #OROF('DOUBLE')
  #OROF('FLOAT8')
  #OROF('DOUBLE PRECISION')
      #SET(%NFieldTSql, 'DECIMAL(' & %NFieldSize & ',' & %NFieldDec & ')')
      #SET(%NFieldTDef, 'NUMBER')                                               #! RA.2007.10.27
      #IF(%NFieldOpt2)                                                          #! RA.2009.03.09
        #SET(%NFieldTSql, %NFieldOpt2)                                          #! RA.2009.03.09
      #ENDIF                                                                    #! RA.2009.03.09
  #OF  ('DATE')
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, 'DATE')                                                 #! RA.2007.10.27
  #OF  ('TIME')
      #SET(%NFieldTSql, 'TIME WITHOUT TIME ZONE')
      #SET(%NFieldTDef, 'TIME')                                                 #! RA.2007.10.27
  #OF  ('TIME WITHOUT TIME ZONE')                                               #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTSql, 'TIME WITHOUT TIME ZONE')                               #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTDef, 'TIME')                                                 #! RA.2007.10.27
  #OF  ('TIMETZ')                                                               #! RA.2007.07.16 - PostgreSQL
  #OROF('TIME WITH TIME ZONE')                                                  #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTSql, 'TIME WITH TIME ZONE')
      #SET(%NFieldTDef, 'TIMEZ')                                                #! RA.2007.10.27
  #OF  ('TIMESTAMP')                                                            #! RA.2007.07.16 - PostgreSQL
  #OROF('TIMESTAMP WITHOUT TIME ZONE')                                          #! RA.2007.09.28 - PostgreSQL
  #OROF('TIMESTAMPTZ')                                                          #! RA.2007.07.16 - PostgreSQL
  #OROF('TIMESTAMP WITH TIME ZONE')                                             #! RA.2007.09.28 - PostgreSQL
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, '')
  #OF  ('SERIAL')                                                               #! RA.2007.07.16 - PostgreSQL
  #OROF('SERIAL4')                                                              #! RA.2007.07.16 - PostgreSQL
  #OROF('BIGSERIAL')                                                            #! RA.2007.07.16 - PostgreSQL
  #OROF('SERIAL8')                                                              #! RA.2007.07.16 - PostgreSQL
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, 'NUMBER')                                               #! RA.2007.10.27
  #OF  ('BIGINT')                                                               #! RA.2007.07.16 - PostgreSQL
  #OROF('INT8')                                                                 #! RA.2007.07.16 - PostgreSQL
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, 'NUMBER')                                               #! RA.2007.10.27
  #OF  ('BOOLEAN')                                                              #! RA.2007.07.16 - PostgreSQL
  #OROF('BOOL')                                                                 #! RA.2007.07.16 - PostgreSQL
      #SET(%NFieldTSql, %NFieldType)
      #SET(%NFieldTDef, 'BOOL')                                                 #! RA.2007.10.27
#!
  #ELSE
      #!---------------------------------------------!
      #! This is a field type not currently handled. !
      #! Time to do some more template programming.  !
      #!---------------------------------------------!
      #SET(%NFieldTSql,'***' & %NFieldType & '***')
  #ENDCASE
  #!-----------------------------------------------------------------!
  #! RA.2007.10.27 - Deal with the initial values in the dictionary. !
  #! Basically for string and numerics only.                         !
  #!-----------------------------------------------------------------!
  #SET(%NFieldDef, '')
  #!
  #! RA.2007.10.27 - NOTHING HAS BEEN DONE FROM THE DICTIONARY YET.
  #!
  #!-----------------------------------------------------------------!
  #! RA.2007.10.27 - Override the initial values in the dictionary.  !
  #!-----------------------------------------------------------------!
  #! If the third field option has a 'YES', then we figure on the    !
  #! SQL type definition to default to something coherent.           !
  #! Otherwise, we just default to whatever in in the option.        !
  #!-----------------------------------------------------------------!
  #IF(%NFieldOpt3)
    #IF(SUB(%NFieldOpt3,1,3)='YES')
      #!------------------------------------------!
      #! We got a 'YES', figure out what we got.  !
      #!------------------------------------------!
      #! This is mostly used to default the date  !
      #! and time fields using backend functions. !
      #!------------------------------------------!
      #CASE(%nFieldTDef)
      #OF  ('DATE')
        #SET(%NFieldDef, 'DEFAULT current_date')
      #OF  ('TIMEZ')
        #SET(%NFieldDef, 'DEFAULT current_time')
      #OF  ('TIME')
        #SET(%NFieldDef, 'DEFAULT localtime')
      #OF  ('CHAR')
        #SET(%NFieldDef, 'DEFAULT ''''')
      #OF  ('NUMBER')
        #SET(%NFieldDef, 'DEFAULT 0')
      #OF  ('BOOL')
        #SET(%NFieldDef, 'DEFAULT false')
      #ENDCASE
    #ELSE
      #!--------------------------------------!
      #! We got something other than a 'YES'. !
      #! Default whatever we find there.      !
      #!--------------------------------------!
        #SET(%NFieldDef, 'DEFAULT ' & %NFieldOpt3)
    #ENDIF
  #ENDIF
  #!----------------------------------------------------------!
  #! Deal with field validation parameters in the dictionary. !
  #!----------------------------------------------------------!
#!
#!    #FOR(%FieldScreenControl)
#!-- %FieldID: FSC(%FieldValidation): %FieldScreenControl
#!    #ENDFOR
#!
  #!----------------------------------------------------------!
  #! RA.2007.10.03 - Now we check specifically for NONZERO.   !
  #! If you are validating something, that means it's going   !
  #! to have some value. Mark it as NOT NULL.                 !
  #!----------------------------------------------------------!
  #SET(%NFieldCheck,    '')                                     #! Field CHECK(...) constraint
  #SET(%NFieldCheckOver,'')                                     #! Field CHECK(...) constraint override
  #SET(%NFieldNN,       '')
  #CASE(%FieldValidation)
  #OF  ('NONZERO')
    #!------------------------------------------------------------!
    #! RA.2007.10.31 - Ignore NOT NULL on fields to avoid clarion !
    #! pre-insert of a blank record validation errors by backend. !
    #!------------------------------------------------------------!
    #IF(NOT %IgnoreNotNullFields)
      #SET(%NFieldNN,   'NOT NULL')                             #! RA.2007.10.03 - Specific check
    #ENDIF
  #OF  ('INFILE')
  #OF  ('BOOLEAN')
    #IF(NUMERIC(%FieldFalseValue) AND NUMERIC(%FieldTrueValue))
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' IN (' & %FieldFalseValue & ',' & %FieldTrueValue & '))')
    #ELSE
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' IN (''' & %FieldFalseValue & ''',''' & %FieldTrueValue & '''))')
    #ENDIF
  #OF  ('INRANGE')
    #IF(%FieldRangeLow AND %FieldRangeHigh)
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' BETWEEN ' & %FieldRangeLow & ' AND ' & %FieldRangeHigh & ')')
    #ELSIF(%FieldRangeLow)
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' > ' & %FieldRangeLow & ')')
    #ELSE
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' < ' & %FieldRangeHigh & ')')
    #ENDIF
  #OF  ('INLIST')
    #SET(%ChoiceLine, '')
    #IF(ITEMS(%FieldValues))
      #SET(%ChoiceComma,ITEMS(%FieldValues) - 1)
      #FOR(%FieldValues)
        #CASE(%NFieldTDef)
        #OF('NUMBER')
          #SET(%ChoiceLine,%ChoiceLine & %FieldValues)
        #ELSE
          #SET(%ChoiceLine,%ChoiceLine & '''' & %FieldValues & '''')
        #ENDCASE
        #IF(%ChoiceComma > 0)
          #SET(%ChoiceLine,%ChoiceLine & ',')
          #SET(%ChoiceComma,%ChoiceComma - 1)
        #ENDIF
      #ENDFOR
    #ELSIF(ITEMS(%FieldChoices))
      #SET(%ChoiceComma,ITEMS(%FieldChoices) - 1)
      #FOR(%FieldChoices)
        #CASE(%NFieldTDef)
        #OF('NUMBER')
          #SET(%ChoiceLine,%ChoiceLine & %FieldChoices)
        #ELSE
          #SET(%ChoiceLine,%ChoiceLine & '''' & %FieldChoices & '''')
        #ENDCASE
        #IF(%ChoiceComma > 0)
          #SET(%ChoiceLine,%ChoiceLine & ',')
          #SET(%ChoiceComma,%ChoiceComma - 1)
        #ENDIF
      #ENDFOR
    #ENDIF
    #IF(%ChoiceLine)
      #SET(%NFieldCheck,'CHECK(' & %NFieldName & ' IN (' & %ChoiceLine & '))')
    #ENDIF
  #ENDCASE
  #!-------------------------------------------------------------------------!
  #! RA.2008.06.24 - Is used as an override even if you have something else. !
  #! RA.2008.06.20 - Fixed RASQLCHECK option to handle IN ('','','','').     !
  #! RA.2008.03.14 - Added RASQLCHECK option to template at the field level. !
  #!-------------------------------------------------------------------------!
  #!SET(%nLoc1,INSTRING('RASQLCHECK(',%FieldUserOptions,1,1))
  #!SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
  #!SET(%nFieldUser,SUB(%FieldUserOptions,%nLoc1,%nLoc2))
  #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLCHECK'))
  #SET(%NFieldCheckOver,EXTRACT(%NFieldUser,'RASQLCHECK',1))
  #IF(%NFieldCheckOver)
    #SET(%NFieldCheck, 'CHECK(' & %NFieldCheckOver & ')')
  #ENDIF
#!-- %NFieldUser, %NFieldCheck
#!-- %NFieldUser, %NFieldCheckOver
#!
  #ADD(%FieldTable,   %FieldID)
#!
  #!---------------------------------------------------------!
  #! RA.2007.10.27 - Ignore making NOT NULL every key field. !
  #!---------------------------------------------------------!
  #IF(NOT %IgnoreNotNullKeys)
    #SET(%IFieldInKey,%Field)                                   #! Field Name
    #FIND(%LFieldInKey,%IFieldInKey)                            #! Field In Key list lookup
    #IF(%LFieldInKey)                                           #! Found? Yes, part of key.
      #SET(%NFieldNN,   'NOT NULL')                             #! Primary keys fields can
    #ENDIF                                                      #! not be NULL. Make it so!
  #ENDIF
#!
  #!------------------------------------------------------------------!
  #! RA.2008.07.01 - Make the transition to BIGINT's easier when they !
  #! become part of the clarion dictionary. Test feasibility.         !
  #!------------------------------------------------------------------!
  #IF(%MakeIntBigint)
    #IF(%NFieldTSql='INT')
      #SET(%IFieldInKey,%Field)                                 #! Field Name
      #FIND(%LFieldInKey,%IFieldInKey)                          #! Field In Key list lookup
      #IF(%LFieldInKey)                                         #! Found? Yes, part of key.
        #SET(%NFieldTSql,'BIGINT')                              #! Chances are this is a relation field
      #ENDIF                                                    #! for a SERIAL. Make it a BIGINT.
    #ENDIF
  #ENDIF
#!
  #!----------------------------------------------------------------------------!
  #!----------------------------------------------------------------------------!
  #! This is the actual SQL field data line creation.                           !
  #!----------------------------------------------------------------------------!
  #!----------------------------------------------------------------------------!
#!
  #IF(%FD1L>0)                                                  #! We GOT array field
  #!----------------------------------------------------------------------------!
  #! If we got an array field at this point, we do not have arrays over groups. !
  #! We have simple array fields and must add additional fields to the table.   !
  #!----------------------------------------------------------------------------!
    #SET(%FldArray,'')                                          #! Clear created name
    #SET(%FD1S,'')                                              #! Number dimension 1
    #SET(%FD2S,'')                                              #! Number dimension 2
    #SET(%FD3S,'')                                              #! Number dimension 3
    #SET(%FD4S,'')                                              #! Number dimension 4
    #!
    #SET(%DimCount,1)                                           #! Got dimension 1
    #IF(%FD2L>0)                                                #! Dimension 2?
      #SET(%DimCount,%DimCount+1)                               #! Got dimension 2
      #IF(%FD3L>0)                                              #! Dimension 3?
        #SET(%DimCount,%DimCount+1)                             #! Got dimension 3
        #IF(%FD4L>0)                                            #! Dimension 4?
          #SET(%DimCount,%DimCount+1)                           #! Got dimension 4
        #ENDIF                                                  #! Dimension 4?
      #ENDIF                                                    #! Dimension 3?
    #ENDIF                                                      #! Dimension 2?
    #!
    #CASE(%DimCount)                                            #! Logic on dimension
    #OF(1)                                                      #! A 1 dimension array
      #LOOP,FOR(%FD1I,1,%FD1L)
        #SET(%FD1S,'_' & %FD1I)
        #SET(%FldArray,%NFieldName & %FD1S)
        #SET(%NFieldLine,   '')
        #SET(%NFieldLine,   %NFieldLine & ''  & %FldArray)
        #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)
        #IF(%NFieldAuto)
          #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)
        #ENDIF
        #IF(%NFieldNN)
          #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)
        #ENDIF
        #IF(%NFieldDef)
          #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)
        #ENDIF
        #IF(%NFieldCheck)
          #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)
        #ENDIF
        #IF(%FD1I=%FD1L)                                        #! Last field?
#!-- %FldArray
          #IF(%FieldComma > 0)
            #SET(%FieldComma, %FieldComma - 1)
            #IF(SUB(%NFieldOpt1,1,1)='E')                       #! RASQL(END)
  %NFieldLine
            #ELSE
  %NFieldLine ,
            #ENDIF
          #ELSE
  %NFieldLine
          #ENDIF
        #ELSE                                                   #! Not last field
  %NFieldLine ,
        #ENDIF                                                  #! Just dump stuff
      #ENDLOOP
    #OF(2)                                                      #! A 2 dimension array
      #LOOP,FOR(%FD1I,1,%FD1L)
        #SET(%FD1S,'_' & %FD1I)
        #LOOP,FOR(%FD2I,1,%FD2L)
          #SET(%FD2S,'_' & %FD2I)
          #SET(%FldArray,%NFieldName & %FD1S & %FD2S)
          #SET(%NFieldLine,   '')
          #SET(%NFieldLine,   %NFieldLine & ''  & %FldArray)
          #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)
          #IF(%NFieldAuto)
            #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)
          #ENDIF
          #IF(%NFieldNN)
            #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)
          #ENDIF
          #IF(%NFieldDef)
            #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)
          #ENDIF
          #IF(%NFieldCheck)
            #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)
          #ENDIF
          #IF((%FD1I=%FD1L)AND(%FD2I=%FD2L))                    #! Last field?
#!-- %FldArray
            #IF(%FieldComma > 0)
              #SET(%FieldComma, %FieldComma - 1)
              #IF(SUB(%NFieldOpt1,1,1)='E')                     #! RASQL(END)
  %NFieldLine
              #ELSE
  %NFieldLine ,
              #ENDIF
            #ELSE
  %NFieldLine
            #ENDIF
          #ELSE                                                 #! Not last field
  %NFieldLine ,
          #ENDIF                                                #! Just dump stuff
        #ENDLOOP
      #ENDLOOP
    #OF(3)                                                      #! A 3 dimension array
      #LOOP,FOR(%FD1I,1,%FD1L)
        #SET(%FD1S,'_' & %FD1I)
        #LOOP,FOR(%FD2I,1,%FD2L)
          #SET(%FD2S,'_' & %FD2I)
          #LOOP,FOR(%FD3I,1,%FD3L)
            #SET(%FD3S,'_' & %FD3I)
            #SET(%FldArray,%NFieldName & %FD1S & %FD2S & %FD3S)
            #SET(%NFieldLine,   '')
            #SET(%NFieldLine,   %NFieldLine & ''  & %FldArray)
            #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)
            #IF(%NFieldAuto)
              #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)
            #ENDIF
            #IF(%NFieldNN)
              #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)
            #ENDIF
            #IF(%NFieldDef)
              #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)
            #ENDIF
            #IF(%NFieldCheck)
              #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)
            #ENDIF
            #IF((%FD1I=%FD1L)AND(%FD2I=%FD2L)AND(%FD3I=%FD3L))  #! Last field?
#!-- %FldArray
              #IF(%FieldComma > 0)
                #SET(%FieldComma, %FieldComma - 1)
                #IF(SUB(%NFieldOpt1,1,1)='E')                   #! RASQL(END)
  %NFieldLine
                #ELSE
  %NFieldLine ,
                #ENDIF
              #ELSE
  %NFieldLine
              #ENDIF
            #ELSE                                               #! Not last field
  %NFieldLine ,
            #ENDIF                                              #! Just dump stuff
          #ENDLOOP
        #ENDLOOP
      #ENDLOOP
    #OF(4)                                                      #! A 4 dimension array
      #LOOP,FOR(%FD1I,1,%FD1L)
        #SET(%FD1S,'_' & %FD1I)
        #LOOP,FOR(%FD2I,1,%FD2L)
          #SET(%FD2S,'_' & %FD2I)
          #LOOP,FOR(%FD3I,1,%FD3L)
            #SET(%FD3S,'_' & %FD3I)
            #LOOP,FOR(%FD4I,1,%FD4L)
              #SET(%FD4S,'_' & %FD4I)
              #SET(%FldArray,%NFieldName & %FD1S & %FD2S & %FD3S & %FD4S)
              #SET(%NFieldLine,   '')
              #SET(%NFieldLine,   %NFieldLine & ''  & %FldArray)
              #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)
              #IF(%NFieldAuto)
                #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)
              #ENDIF
              #IF(%NFieldNN)
                #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)
              #ENDIF
              #IF(%NFieldDef)
                #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)
              #ENDIF
              #IF(%NFieldCheck)
                #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)
              #ENDIF
              #IF((%FD1I=%FD1L)AND(%FD2I=%FD2L)AND(%FD3I=%FD3L)AND(%FD4I=%FD4L)) #! Last field?
#!-- %FldArray
                #IF(%FieldComma > 0)
                  #SET(%FieldComma, %FieldComma - 1)
                  #IF(SUB(%NFieldOpt1,1,1)='E')                 #! RASQL(END)
  %NFieldLine
                  #ELSE
  %NFieldLine ,
                  #ENDIF
                #ELSE
  %NFieldLine
                #ENDIF
              #ELSE                                             #! Not last field
  %NFieldLine ,
              #ENDIF                                            #! Just dump stuff
            #ENDLOOP
          #ENDLOOP
        #ENDLOOP
      #ENDLOOP
    #ENDCASE
#!
  #ELSE                                                         #! We GOT normal field
  #!----------------------------------------------------------------------------!
  #! This processes the normal fields that are NOT an array.                    !
  #!----------------------------------------------------------------------------!
    #SET(%NFieldLine,   '')
    #SET(%NFieldLine,   %NFieldLine & ''  & %NFieldName)        #! Field Name
    #SET(%NFieldLine,   %NFieldLine & ' ' & %NFieldTSql)        #! SQL Type
    #IF(%NFieldAuto)
      #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldAuto)        #! AUTO_INCREMENT
    #ENDIF
    #IF(%NFieldNN)
      #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldNN)          #! NOT NULL
    #ENDIF
    #IF(%NFieldDef)
      #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldDef)         #! DEFAULT
    #ENDIF
    #IF(%NFieldCheck)
      #SET(%NFieldLine, %NFieldLine & ' ' & %NFieldCheck)       #! CHECK(...)
    #ENDIF
    #!
    #IF(%FieldComma > 0)
      #SET(%FieldComma, %FieldComma - 1)
      #IF(SUB(%NFieldOpt1,1,1)='E')                             #! RASQL(END)
  %NFieldLine
      #ELSE
  %NFieldLine ,
      #ENDIF
    #ELSE
  %NFieldLine
    #ENDIF
  #ENDIF
#!
  #!----------------------------------------------------------------------------!
  #!----------------------------------------------------------------------------!
#!
#ENDFOR
#!---------------------------------------------------------------------
#GROUP(%RASQLFieldEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%RASQLFieldComment)
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
#!--------------------------------------------------------------------!
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#FOR(%Field)
  #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
  #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
  #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
  #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
  #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
  #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
#!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
  #!--------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a field is processed. !
  #!--------------------------------------------------------------!
  #IF(SUB(%NFieldOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #!------------------------------------------------!
  #! Begin removal of types that are not processed. !
  #!------------------------------------------------!
  #IF(%FieldType='GROUP')
    #CYCLE
  #ENDIF
  #IF(%FieldType='END')
     #CYCLE
  #ENDIF
#!
#INSERT(%RAModifyNameField)
#!
#SET(%NComment, QUOTE(%FieldDescription))                       #! RA.2008.08.12
COMMENT ON COLUMN %NFileName.%NFieldName IS
'%NComment'
;
#ENDFOR
  #ENDIF                                                        #! RA.2008.08.13
#!---------------------------------------------------------------------
#GROUP(%RASQLFieldCommentEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2008.07.19 - Added logic to handle %NFilePrefix (for %FilePrefix)
#! RA.2007.07.14 - The options to modify a column, table, and key name
#! became real complicated in postgreSQL so I group them into one place
#! and inserted them where needed.
#!---------------------------------------------------------------------
#GROUP(%RAModifyNameTable)
  #SET(%NFileName,%File)
  #SET(%NFilePrefix,%FilePrefix)                                #! RA.2008.07.19
  #!
  #!--------------------------------------!
  #! RA.2010.09.13 - EXTERNAL table name. !
  #!--------------------------------------!
  #IF(%UseExtTableName AND %NFileOpt2)                          #! RA.2010.09.13
    #SET(%NFileName,LOWER(%NFileOpt2))                          #! RA.2010.09.13
  #ENDIF                                                        #! RA.2010.09.13
  #!--------------------------------------!
  #!--------------------------------------!
  #!
  #SET(%NRelateSchema1, EXTRACT(%FileUserOptions, 'SCHEMA', 2)) #! RA.2009.02.18
  #!
  #IF(%UsePrefix='All' OR %PrefixTables)                        #! RA.2008.08.11
    #SET(%NFileName,%NFilePrefix & '_' & %File)                 #! RA.2008.07.19
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NFileName))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundFileName & %NFileName)
      #SET(%NFileName, %NFileName & '_')
    #ENDIF
  #ENDIF
  #IF(%UseSchemaName)
    #SET(%NFileName, %SchemaName & '.' & %NFileName)
  #ENDIF
  #! Added check to see if lowercase wanted
  #IF(%UseLowerCase)                                            #! MAG 02.21.08
    #SET(%NFileName,Lower(%NFileName))                          #! MAG 02.21.08
    #SET(%NFilePrefix,LOWER(%NFilePrefix))                      #! RA.2008.07.19
    #SET(%NFNameAuto,LOWER(%NFNameAuto))                        #! RA.2008.07.19
  #ENDIF                                                        #! MAG 02.21.08
#!---------------------------------------------------------------------
#GROUP(%RAModifyNameField)
#!$$------------------------------------------------!
#!$$ DEJ.2007.05.08 - Use External Field Name
#!$$------------------------------------------------!
  #IF(%UseExtFieldName AND %FieldName)                                                  #!$$ Using External Field Names
    #IF(%UseExtFieldQuote)                                                              #!$$ Generate External Name w/ Quotes
      #SET(%NFieldName, %FieldName)                                                     #!$$
    #ELSE                                                                               #!$$
      #SET(%NFieldName, SUB(%FieldName,2,LEN(%FieldName)-2))                            #!$$ Remove Quotes in External Name
    #ENDIF                                                                              #!$$
  #ELSE                                                                                 #!$$
    #SET(%NFieldName, %FieldID)                                                         #!$$ Use Field Label
  #ENDIF                                                                                #!$$
#!$$  #SET(%NFieldName, %FieldID)                                                       #! Field Name
#!$$------------------------------------------------!
#!$$ End of Use External Field Name
#!$$------------------------------------------------!
  #IF(%UsePrefix='All' OR %PrefixColumns)                                               #! RA.2008.08.11
    #SET(%NFieldName, %FilePrefix & '_' & %FieldID)                                     #! RA.2001.10.24
  #ENDIF                                                                                #! RA.2001.12.01
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NFieldName))                                              #! Set up search of
    #FIND(%SqlWordList, %SqlWordItem)                                                   #! SQL reserved words
    #IF(%SqlWordList)                                                                   #! Found? Yes! We add
      #ADD(%ReservedFieldList, %FoundFileField & %FilePrefix & ':' & %NFieldName)
      #SET(%NFieldName, %NFieldName & '_')                                              #! trailing underscore
    #ENDIF                                                                              #! to get it through
  #ENDIF
  #! Added check to see if lowercase wanted
  #IF(%UseLowerCase)                                       #! MAG 02.21.08
    #Set(%NFieldName, Lower(%NFieldName))                  #! MAG 02.21.08
  #ENDIF                                                   #! MAG 02.21.08
#!---------------------------------------------------------------------
#GROUP(%RAModifyNameKey00)
  #SET(%NKeyName,%KeyID)
  #!
  #!------------------------------------!
  #! RA.2010.09.13 - EXTERNAL key name. !
  #!------------------------------------!
  #IF(%UseExtKeyName AND %KeyName)                                                      #! RA.2010.09.13
    #IF(%UseExtKeyQuote)                                                                #! RA.2010.09.13 - Generate External Name w/ Quotes
      #SET(%NKeyName, %KeyName)                                                         #! RA.2010.09.13
    #ELSE                                                                               #! RA.2010.09.13
      #SET(%NKeyName, SUB(%KeyName,2,LEN(%KeyName)-2))                                  #! RA.2010.09.13 - Remove Quotes in External Name
    #ENDIF                                                                              #! RA.2010.09.13
  #ENDIF                                                                                #! RA.2010.09.13
  #!------------------------------------!
  #!------------------------------------!
  #!
  #! #IF(%UsePrefix='All')                                                              #! dgh added additional test
  #IF(%UsePrefix='All' OR %PrefixKeys)                                                  #! dgh
    #SET(%NKeyName,%FilePrefix & '_' & %KeyID)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NKeyName))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundKeyName & %FilePrefix & ':' & %NKeyName)
      #SET(%NKeyName, %NKeyName & '_')
    #ENDIF
  #ENDIF
  #IF(%UseLowerCase)                                        #! MAG 02.21.08
    #SET(%NKeyName, Lower(%NKeyName))                       #! MAG 02.21.08
  #ENDIF                                                    #! MAG 02.21.08
#!---------------------------------------------------------------------
#GROUP(%RAModifyNameKey01)
  #SET(%NKeyField1, SUB(%FileKey, INSTRING(':',%FileKey,1,1) + 1 , 50))
  #IF(NOT %NKeyField1)
    #SET(%NKeyField1, SUB(%RelationKey, INSTRING(':',%RelationKey,1,1) + 1 , 50))
  #ELSE
    #!----------------------------------------------------------!
    #! RA.2007.07.17 - Additional logic to give both key names. !
    #!----------------------------------------------------------!
    #SET(%NKeyField2, SUB(%RelationKey, INSTRING(':',%RelationKey,1,1) + 1 , 50))
    #SET(%NKeyField, %NKeyField1 & '_to_' & %NKeyField2)
  #ENDIF
  #IF(%UsePrefix='All' OR %PrefixRelations)                 #! RA.2008.08.11
    #SET(%NKeyField, %FilePrefix & '_' & %NKeyField1 & '_to_' & %RelationPrefix & '_' & %NKeyField2)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NKeyField))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundKeyField & %FilePrefix & ':' & %NKeyField)
      #SET(%NKeyField, %NKeyField & '_')
    #ENDIF
  #ENDIF
  #IF(%UseLowerCase)                                        #! MAG 02.21.08
    #SET(%NKeyField, Lower(%NKeyField))                     #! MAG 02.21.08
  #ENDIF                                                    #! MAG 02.21.08
#!---------------------------------------------------------------------
#GROUP(%RAModifyNameRelTable)
  #SET(%NRelateFile, %Relation)
  #IF(%RelationAlias)                                               #! RA.2007.10.21 - Relation to ALIAS are
    #SET(%NRelateFile, %RelationAlias)                              #! RA.2007.10.21 - replaced with the real file name
  #ENDIF                                                            #! RA.2007.10.21 - Aliases do not exist in backend
  #!
  #FIX(%File,%NRelateFile)                                          #! RA.2009.02.18
  #SET(%NRelateSchema2, EXTRACT(%FileUserOptions, 'SCHEMA', 2))     #! RA.2009.02.18
  #FIX(%File,%NFileName)                                            #! RA.2009.02.18
  #!
  #! =================== NEED TO GET THE EXTERNAL NAME HERE ======================================
  #!
  #IF(%UsePrefix='All' OR %PrefixTables)                            #! RA.2008.08.11
    #SET(%NRelateFile, %RelationPrefix & '_' & %Relation)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NRelateFile))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundRelatedName & %NRelateFile)
      #SET(%NRelateFile, %NRelateFile & '_')
    #ENDIF
  #ENDIF
  #IF(%UseSchemaName)
    #SET(%NRelateFile, %SchemaName & '.' & %NRelateFile)
  #ENDIF
  #IF(%UseLowerCase)                                        #! MAG 02.21.08
    #SET(%NRelateFile, Lower(%NRelateFile))                 #! MAG 02.21.08
  #ENDIF                                                    #! MAG 02.21.08
#!---------------------------------------------------------------------
#GROUP(%RAModifyNameRelField1)
  #IF(%UsePrefix='All' OR %PrefixColumns)                   #! RA.2008.08.11
    #SET(%NRelateField1, %FilePrefix & '_' & %NRelateField1)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NRelateField1))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundRelatedField & %FilePrefix & ':' & %NRelateField1)
      #SET(%NRelateField1, %NRelateField1 & '_')
    #ENDIF
  #ENDIF
  #IF(%UseLowerCase)                                       #! MAG 02.21.08
    #SET(%NRelateField1, lower(%NRelateField1))            #! MAG 02.21.08
  #ENDIF                                                   #! MAG 02.21.08
#!---------------------------------------------------------------------
#GROUP(%RAModifyNameRelField2)
  #IF(%UsePrefix='All' OR %PrefixColumns)               #! RA.2008.08.11
    #SET(%NRelateField2, %RelationPrefix & '_' & %NRelateField2)
  #ENDIF
  #IF(NOT %IgnoreReserved)
    #SET(%SqlWordItem, UPPER(%NRelateField2))
    #FIND(%SqlWordList, %SqlWordItem)
    #IF(%SqlWordList)
      #ADD(%ReservedFieldList, %FoundRelatedField & %RelationPrefix & ':' & %NRelateField2)
      #SET(%NRelateField2, %NRelateField2 & '_')
    #ENDIF
  #ENDIF
  #IF(%UseLowerCase)                                    #! MAG 02.21.08
    #SET(%NRelateField2, lower(%NRelateField2))         #! MAG 02.21.08
  #ENDIF                                                #! MAG 02.21.08
#!---------------------------------------------------------------------
#GROUP(%RAModifyNameEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%SchemaTable)
      #FIX(%File,%ProcFile)                                     #! RA.2007.11.25
      #!---------------------------------------------------------------!
      #! RA.2001.12.01 - Ignore file place marker definitions.         !
      #! These are files that are defined but that contain no fields.  !
      #!---------------------------------------------------------------!
      #IF(NOT ITEMS(%Field))                                    #! RA.2001.12.01
        #CYCLE                                                  #! RA.2001.12.01
      #ENDIF                                                    #! RA.2001.12.01
      #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
      #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
      #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
      #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
      #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
      #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
      #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
      #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
      #!-------------------------------------------------------------!
      #! The first option RASQL(NO) controls if a file is processed. !
      #!-------------------------------------------------------------!
      #IF(SUB(%NFileOpt1,1,1)='N')
        #CYCLE
      #ENDIF
      #!
      #CASE(%FileType)
      #OF  ('VIEW')
      #OROF('ALIAS')
          #CYCLE
      #ENDCASE
      #!
      #CASE(%FileDriver)
        #OF('ASCII')
      #OROF('BASIC')
      #OROF('DOS')
      #OROF('IN-MEMORY')
          #CYCLE
      #ENDCASE
      #!
      #!-------------------------------------------------------------------------!
      #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
      #!-------------------------------------------------------------------------!
      #SET(%NFileOpt0,'')
      #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
      #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
      #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
      #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
      #!
      #MESSAGE('Table of: ' & %File,2)
      #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
      #!
      #INSERT(%PGModifyNameTable)                               #! RA.2010.09.25
      #!
      #IF(%CommentsSQL)                                         #! RA.2008.08.13
--
-- TABLE: (%FilePrefix:%File) %NFileName [DATABASE: %ProcFileDB, SCHEMA: %ProcFileSC]
--

      #ENDIF                                                    #! RA.2008.08.13
      #!------------------------------------------------------------------------!
      #! IF it IS a primary key, AND it is an integer, AND NOT auto-increment,  !
      #! AND there is one item in the key (only thing I can be sure about),     !
      #! THEN assume that it IS an auto-increment handled by the SQL backend.   !
      #!------------------------------------------------------------------------!
      #SET(%NFNameAuto,'')
      #SET(%AutoIncrementCount,0)
      #IF(ITEMS(%Key))
        #FOR(%Key)
#!---- Key        = %Key
          #IF(%KeyPrimary <> 1)
            #CYCLE
          #ENDIF
#!---- KeyPrimary = %KeyPrimary
          #IF(%KeyAuto = 1)
            #CYCLE
          #ENDIF
#!---- KeyAuto    = %KeyAuto
      #!
          #IF(ITEMS(%KeyField) > 1)
            #CYCLE
          #ENDIF
      #!
          #FOR(%KeyField)
#!---- KeyField   = %KeyField
            #FIX(%Field,%KeyField)
#!---- Field      = %Field
#!---- FieldType  = %FieldType
            #CASE(%FieldType)
            #OF('LONG')
              #SET(%NFNameAuto, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
              #!-------------------------------------------!
              #! RA.2010.09.13 - EXTERNAL name processing. !
              #!-------------------------------------------!
              #FIX(%Field,%KeyField)                                                            #! RA.2010.09.17
              #IF(%UseExtFieldName AND %FieldName)                                              #! RA.2010.09.13
                #IF(%UseExtFieldQuote)                                                          #! RA.2010.09.13 - Generate External Name w/ Quotes
                  #SET(%NFNameAuto, %FieldName)                                                 #! RA.2010.09.13
                #ELSE                                                                           #! RA.2010.09.13
                  #SET(%NFNameAuto, SUB(%FieldName,2,LEN(%FieldName)-2))                        #! RA.2010.09.13 - Remove Quotes in External Name
                #ENDIF                                                                          #! RA.2010.09.13
              #ENDIF                                                                            #! RA.2010.09.13
              #!-------------------------------------------!
              #!-------------------------------------------!
            #ENDCASE
          #ENDFOR
      #!
          #IF(%NFNameAuto)
#!---- NFNameAuto = %NFNameAuto
            #SET(%AutoIncrementCount,%AutoIncrementCount + 1)
            #SET(%AutoCount, %AutoCount + 1)
      #!        #SET(%NFNameAuto, SUB(%KeyAuto, INSTRING(':',%KeyAuto,1,1) + 1 , 50))
            #IF(%UsePrefix='All' OR %PrefixColumns)                                 #! RA.2008.08.11
              #SET(%NFNameAuto, %FilePrefix & '_' & %NFNameAuto)
            #ENDIF
            #!---------------------------------------------!
            #! RA.2007.10.10 - Behave according to option. !
            #!---------------------------------------------!
            #IF(NOT %IgnoreReserved)
              #SET(%SqlWordItem, UPPER(%NFNameAuto))
              #FIND(%SqlWordList, %SqlWordItem)
              #IF(%SqlWordList)
                #ADD(%ReservedFieldList, %FoundAIKeyName & %FilePrefix & ':' & %NFNameAuto)
                #SET(%NFNameAuto, %NFNameAuto & '_')
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDFOR
        #IF(%AutoIncrementCount = 0)
#!-- WARNING: %File(%FilePrefix) has no AUTO-INCREMENT KEY defined.
        #ENDIF
      #ENDIF
    #!
    #!PRINT '%NFileName'
    #!
      #IF(%nFileOpt0)
--
-- DRIVER:  %FileDriver
-- OPTIONS: %FileDriverParameter
-- OWNER:   %FileOwner
-- NAME:    %FileName
--
      #ENDIF
    #!
CREATE TABLE %NFileName (
#INSERT(%RASQLField)                                            #! Process fields
)
;
      #IF(%CommentsDB)                                          #! RA.2008.08.13
        #SET(%NComment, QUOTE(%FileDescription))                #! RA.2008.08.12
COMMENT ON TABLE %NFileName IS
'%NComment'
;
      #ENDIF                                                    #! RA.2008.08.13
#INSERT(%PGSQLFieldComment)                                     #! RA.2010.09.25 - Process fields comments

      #!  #IF (%UseOwner)
      #!ALTER TABLE %NFileName OWNER TO %OwnerName
      #!;
      #!
      #!  #ENDIF
      #!----------------------------------------------------------------!
      #! RA.2007.09.20 - If the ISIDENTITY() is set to TRUE this is     !
      #! an auto increment field. This is best descrived as a SERIAL    !
      #! (or BIG serial). SERIAL or BIGSERIAL sets up the equivalent    !
      #! in PostgreSQL of:                                              !
      #!                                                                !
      #!  CREATE TABLE pg_name (                                        !
      #!    auto_id INT NOT NULL ,                                      !
      #!    first_name CHAR(30) NOT NULL ,                              !
      #!    middle_name CHAR(30) NULL ,                                 !
      #!    last_name CHAR(30) NOT NULL ,                               !
      #!    last_name_father CHAR(30) NULL ,                            !
      #!    last_name_mother CHAR(30) NULL                              !
      #!  )                                                             !
      #!  ;                                                             !
      #!                                                                !
      #!  ALTER TABLE pg_name                                           !
      #!    ADD CONSTRAINT pg01_key0_pk PRIMARY KEY (auto_id)           !
      #!  ;                                                             !
      #!                                                                !
      #!  CREATE INDEX pg01_key1                                        !
      #!    ON pg_name (last_name)                                      !
      #!  ;                                                             !
      #!                                                                !
      #!  CREATE SEQUENCE pg_name_id_seq                                !
      #!      INCREMENT BY 1                                            !
      #!      CACHE 1                                                   !
      #!  ;                                                             !
      #!                                                                !
      #!  ALTER SEQUENCE pg_name_id_seq OWNED BY pg_name.auto_id        !
      #!  ;                                                             !
      #!                                                                !
      #!  ALTER TABLE pg_name ALTER COLUMN auto_id SET DEFAULT          !
      #!       nextval('pg_name_id_seq'::regclass)                      !
      #!  ;                                                             !
      #!                                                                !
      #!----------------------------------------------------------------!
  #IF(%nFileOpt0)                                               #! You have to have it set up in the dictionary
    #IF(%UseSerial)                                             #! And you have to want it in the template
      #!--------------------------------------!
      #! RA.2010.09.13 - EXTERNAL table name. !
      #!--------------------------------------!
      #SET(%NFileSequence, %NFilePrefix)                        #! RA.2010.09.13
      #IF(%UseExtTableName AND %NFileOpt2)                      #! RA.2010.09.13
        #SET(%NFileSequence,LOWER(%NFileOpt2))                  #! RA.2010.09.13
      #ENDIF                                                    #! RA.2010.09.13
      #!--------------------------------------!
      #!--------------------------------------!
CREATE SEQUENCE %NFileSequence_id_seq
  INCREMENT BY 1
  CACHE 1
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%FileDescription))                        #! RA.2008.08.12
COMMENT ON SEQUENCE %NFileSequence_id_seq IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

ALTER SEQUENCE %NFileSequence_id_seq
  OWNED BY %NFileName.%NFNameAuto
;

ALTER TABLE %NFileName ALTER COLUMN %NFNameAuto
  SET DEFAULT nextval('%NFileSequence_id_seq'::regclass)
;
    #ENDIF

      #ENDIF
#GROUP(%SchemaTableEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%SchemaGrant)
  #IF(NOT %optGrantDoit)                                        #! RA.2008.09.17
    #CYCLE                                                      #! RA.2008.09.17
  #ENDIF                                                        #! RA.2008.09.17
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)                                     #! RA.2010.09.25
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%FilePrefix:%File) %NFileName [DATABASE: %ProcFileDB, SCHEMA: %ProcFileSC]
--

  #ENDIF                                                        #! RA.2008.08.13
  #FOR(%optGrant)
    #SET(%optGrantTotal     , %optGrantSelect + %optGrantInsert + %optGrantUpdate + %optGrantDelete)
    #SET(%optGrantCount     , 0)
    #SET(%optGrantLine      , '')
#!-- TOTAL: %optGrantTotal
    #CASE(%optGrantTotal)
    #OF(4)
      #SET(%optGrantLine, 'GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE ' & %NFileName)
      #SET(%optGrantCount, 4)
    #OF(3)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(2)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(1)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #ENDCASE
%optGrantLine
    #IF(%optGrantType = 'User')
  TO %optGrantName
    #ELSE
  TO GROUP %optGrantName
    #ENDIF
;
  #ENDFOR
#GROUP(%SchemaGrantEnd)
#!---------------------------------------------------------------------
#GROUP(%SchemaGrantSingle)
#IF(%opt2GrantDoit AND ITEMS(%opt2Grant))

--
-- SQL script creator for POSTGRESQL database [GRANT] - Specific Tables
-- Created: %TheDate - %TheTime
--

  #FOR(%opt2Grant)
    #FIX(%File          , %opt2GrantTable)
#INSERT(%PGModifyNameTable)                                     #! RA.2010.09.25
    #MESSAGE('Table of: ' & %File,2)
#!
    #IF(%CommentsSQL)                                           #! RA.2008.08.13
--
-- TABLE: (%NFilePrefix) %NFileName
--

    #ENDIF                                                      #! RA.2008.08.13
#!
    #SET(%optGrantType  , %opt2GrantType)
    #SET(%optGrantName  , %opt2GrantName)
    #SET(%optGrantSelect, %opt2GrantSelect)
    #SET(%optGrantInsert, %opt2GrantInsert)
    #SET(%optGrantUpdate, %opt2GrantUpdate)
    #SET(%optGrantDelete, %opt2GrantDelete)
#!
    #SET(%optGrantTotal     , %optGrantSelect + %optGrantInsert + %optGrantUpdate + %optGrantDelete)
    #SET(%optGrantCount     , 0)
    #SET(%optGrantLine      , '')
#!-- TOTAL: %optGrantTotal
    #CASE(%optGrantTotal)
    #OF(4)
      #SET(%optGrantLine, 'GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE ' & %NFileName)
      #SET(%optGrantCount, 4)
    #OF(3)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(2)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT,')
        #SET(%optGrantCount, %optGrantCount + 1)
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #OF(1)
      #SET(%optGrantLine, 'GRANT')
      #IF(%optGrantSelect)
        #SET(%optGrantLine, %optGrantLine & ' SELECT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(1): %optGrantCount
      #IF(%optGrantInsert)
        #SET(%optGrantLine, %optGrantLine & ' INSERT')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(2): %optGrantCount
      #IF(%optGrantUpdate)
        #SET(%optGrantLine, %optGrantLine & ' UPDATE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(3): %optGrantCount
      #IF(%optGrantDelete)
        #SET(%optGrantLine, %optGrantLine & ' DELETE')
        #SET(%optGrantCount, %optGrantCount + 1)
        #IF(%optGrantCount = %optGrantTotal)
          #SET(%optGrantLine, %optGrantLine & ' ON TABLE ' & %NFileName)
        #ELSE
          #SET(%optGrantLine, %optGrantLine & ',')
        #ENDIF
      #ENDIF
#!-- COUNT(4): %optGrantCount
    #ENDCASE
%optGrantLine
    #IF(%optGrantType = 'User')
  TO %optGrantName
    #ELSE
  TO GROUP %optGrantName
    #ENDIF
;

  #ENDFOR
#ENDIF
#GROUP(%SchemaGrantSingleEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%SchemaIndex)
#!#FOR(%ProcFile)                                                 #! RA.2007.11.25
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)                                     #! RA.2010.09.25
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%FilePrefix:%File) %NFileName [DATABASE: %ProcFileDB, SCHEMA: %ProcFileSC]
--

  #ENDIF                                                        #! RA.2008.08.13
#!PRINT '%NFileName'
  #SET(%PrimaryCount,0)                                         #! Primary key exists
  #SET(%SecondaryCount,0)                                       #! Secondary key exists
  #IF(ITEMS(%Key))
    #FOR(%Key)
      #IF(NOT ITEMS(%KeyField))                                 #! Key has fields? No!
        #CYCLE                                                  #! Then go to the next
      #ENDIF                                                    #! key to be processed
#!
      #SET(%nLoc1,INSTRING('RASQL(',%KeyUserOptions,1,1))
      #SET(%nLoc2,INSTRING(')',%KeyUserOptions,1,%nLoc1))
      #SET(%nKeyUser,UPPER(SUB(%KeyUserOptions,%nLoc1,%nLoc2)))
      #!SET(%NKeyUser,UPPER(EXTRACT(%KeyUserOptions,'RASQL')))
      #SET(%NKeyOpt1,EXTRACT(%NKeyUser,'RASQL',1))
      #SET(%NKeyOpt2,EXTRACT(%NKeyUser,'RASQL',2))
      #SET(%NKeyOpt3,EXTRACT(%NKeyUser,'RASQL',3))
      #SET(%NKeyOpt4,EXTRACT(%NKeyUser,'RASQL',4))
#!%NKeyUser, %NKeyOpt1, %NKeyOpt2, %NKeyOpt3, %NKeyOpt4
      #!------------------------------------------------------------!
      #! The first option RASQL(NO) controls if a key is processed. !
      #!------------------------------------------------------------!
      #IF(SUB(%NKeyOpt1,1,1)='N')
        #CYCLE
      #ENDIF
#!
#! -- FileName 00: %NFileName
#INSERT(%PGModifyNameKey00)                                     #! RA.2010.09.25
#! -- FileName 01: %NFileName
#!
      #SET(%NKeyFields,'')
      #SET(%NKeyFieldCount,0)
      #FOR(%KeyField)
        #SET(%NKeyField, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
        #!-------------------------------------------------------------------------!
        #! RA.2001.12.15 - Table of keyfield-table to be able to create relations. !
        #!-------------------------------------------------------------------------!
        #IF(%DoFieldFile)
          #ADD(%FieldTableList, %NKeyField & ' ==> ' & %File)
        #ENDIF
#!----
#!---- SECTION 02: File='%File', NFileName='%NFileName'
#!---- SECTION 02: Key='%Key', NKeyName='%NKeyName', KeyField='%KeyField', NKeyField='%NKeyField'
        #!-----------------------------------------!
        #! RA.2010.09.17 - Check for external name !
        #!-----------------------------------------!
        #FIX(%Field,%KeyField)                                                                 #! RA.2010.09.13
#!---- SECTION 02: Field='%Field', NKeyField='%NKeyField', FieldName="%FieldName"
#!---- SECTION 02: UseExtFieldName = '%UseExtFieldName'
        #IF(%UseExtFieldName AND %FieldName)                                                    #! RA.2010.09.13
          #IF(%UseExtFieldQuote)                                                                #! RA.2010.09.13 - Generate External Name w/ Quotes
            #SET(%NKeyField, %FieldName)                                                        #! RA.2010.09.13
          #ELSE                                                                                 #! RA.2010.09.13
            #SET(%NKeyField, SUB(%FieldName,2,LEN(%FieldName)-2))                               #! RA.2010.09.13 - Remove Quotes in External Name
          #ENDIF                                                                                #! RA.2010.09.13
        #ENDIF                                                                                  #! RA.2010.09.13
#!---- SECTION 02: Field='%Field', NKeyField='%NKeyField', FieldName="%FieldName"
#!---- SECTION 02: NKeyFields='%NKeyFields'
        #!-----------------------------------------!
        #!-----------------------------------------!
        #!
        #IF(%UsePrefix='All' OR %PrefixColumns)                                                 #! RA.2008.08.11
          #SET(%NKeyField, %FilePrefix & '_' & %NKeyField)
        #ENDIF
        #!----------------------------------!
        #! RA.2007.12.26 - Obey the option. !
        #!----------------------------------!
        #IF(NOT %IgnoreReserved)
          #SET(%SqlWordItem, UPPER(%NKeyField))
#!-- SqlWordItem = '%SqlWordItem'
          #FIND(%SqlWordList, %SqlWordItem)
#!-- SqlWordList = '%SqlWordList'
          #IF(%SqlWordList)
            #ADD(%ReservedFieldList, %FoundKeyField & %FilePrefix & ':' & %NKeyField)
            #SET(%NKeyField, %NKeyField & '_')
          #ENDIF
        #ENDIF
        #SET(%NKeyFieldCount,%NKeyFieldCount + 1 )
        #IF(%NKeyFieldCount = 1)
          #SET(%NKeyFields,%NKeyField)
        #ELSE
          #SET(%NKeyFields, %NKeyFields & ', ' & %NKeyField)
        #ENDIF
      #ENDFOR
      #IF(%KeyPrimary)
        #SET(%PrimaryCount, 1)
        #SET(%PKeyCount, %PKeyCount + 1)
        #SET(%KeyCount, %KeyCount + 1)
#!-- 01
ALTER TABLE %NFileName
  ADD CONSTRAINT %NKeyName PRIMARY KEY (%NKeyFields)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON CONSTRAINT %NKeyName ON %NFileName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

      #ELSIF(NOT %KeyPrimary)
        #SET(%KeyOthers, %KeyOthers + 1)
        #SET(%KeyCount, %KeyCount + 1)
        #IF(%KeyDuplicate)
          #CASE(%KeyIndex)
          #OF  ('KEY')
#!-- 02
CREATE INDEX %NKeyName
 #IF(%UseLowerCase)                                             #! MAG 02.21.08
  #SET(%NKeyFields,lower(%NKeyFields))                          #! MAG 02.21.08
 #ENDIF                                                         #! MAG 02.21.08
  ON %NFileName (%NKeyFields)
;
#IF(%UseLowerCase)                                              #! MAG 02.21.08
 #SET(%NKeyName,lower(%NKeyName))                               #! MAG 02.21.08
#ENDIF                                                          #! MAG 02.21.08
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

          #OF  ('INDEX')
          #OROF('DYNAMIC')
#IF(%UseLowerCase)                                              #! MAG 02.21.08
 #SET(%NKeyName, lower(%NKeyName))                              #! MAG 02.21.08
 #SET(%NKeyFields, lower(%NKeyFields))                          #! MAG 02.21.08
#ENDIF                                                          #! MAG 02.21.08
#!-- 03
CREATE INDEX %NKeyName
  ON %NFileName (%NKeyFields)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

          #ENDCASE
        #ELSE
          #CASE(%KeyIndex)
          #OF  ('KEY')
#!-- 04
CREATE UNIQUE INDEX %NKeyName
#IF(%UseLowerCase)                                      #! MAG 02.21.08
  #SET(%NKeyFields,Lower(%NKeyFields))                  #! RA.2008.03.22 - Correction
#ENDIF                                                  #! MAG 02.21.08
  ON %NFileName (%NKeyFields)
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
  #ENDIF                                                        #! RA.2008.08.13

          #OF  ('INDEX')
          #OROF('DYNAMIC')
#!-- 05
CREATE UNIQUE INDEX %NKeyName
  #IF(%UseLowerCase)                                            #! MAG 02.21.08
  ON %NFileName (lower(%NKeyFields))
  #ELSE                                                         #! MAG 02.21.08
  ON %NFileName (%NKeyFields)
  #ENDIF                                                        #! MAG 02.21.08
;
  #IF(%CommentsDB)                                              #! RA.2008.08.13
#SET(%NComment, QUOTE(%KeyDescription))                         #! RA.2008.08.12
COMMENT ON INDEX %NKeyName IS
'%NComment'
;
#ENDIF                                                          #! RA.2008.08.13

          #ENDCASE
        #ENDIF
      #ENDIF
    #ENDFOR
    #IF(NOT %PrimaryCount)
--
-- WARNING: %File(%FilePrefix) has no PRIMARY KEY defined.
--
    #ENDIF
  #ELSE
--
-- WARNING: %File(%FilePrefix) has no KEYS defined.
--
  #ENDIF
  #! +++++ RA.2008.08.06 - Special indexes from options here
#GROUP(%SchemaIndexEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2010.09.25 - Added getting file options, they were missing.
#!---------------------------------------------------------------------
#GROUP(%SchemaRelat)
    #FIX(%File,%ProcFile)                                       #! RA.2007.11.25
#!    #SET(%NRelateSequence, 0)                                   #! RA.2010.09.25
#!
    #!---------------------------------------------------------------!
    #! RA.2001.12.01 - Ignore file place marker definitions.         !
    #! These are files that are defined but that contain no fields.  !
    #!---------------------------------------------------------------!
    #IF(NOT ITEMS(%Field))
      #CYCLE
    #ENDIF
    #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
    #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
    #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
    #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
    #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
    #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
    #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
    #!-------------------------------------------------------------!
    #! The first option RASQL(NO) controls if a file is processed. !
    #!-------------------------------------------------------------!
    #IF(SUB(%NFileOpt1,1,1)='N')
      #CYCLE
    #ENDIF
#!
    #CASE(%FileDriver)
      #OF('ASCII')
    #OROF('BASIC')
    #OROF('DOS')
    #OROF('IN-MEMORY')
        #CYCLE
    #ENDCASE
#!
    #CASE(%FileType)
    #OF  ('VIEW')
#!------------------------------------------------------------!
#! RA.2001.07.22 - Need to deal with aliases for the purpose  !
#! of discovering additional key relationships that can not   !
#! be done with a single file from Clarion. In specific       !
#!                                                            !
#! Tables                                                     !
#!  Party_Table         Party_Relationship_Table              !
#!  Party_Id            Party_Id_From                         !
#!                      Party_Id_To                           !
#! Relations                                                  !
#!  Party_Id    <->>    Party_Id_From                         !
#!  Party_Id    <->>    Party_Id_To                           !
#!                                                            !
#! Clarion would need an alias of Party_Relationship_Table to !
#! deal with the second relationship. There would be no way   !
#! to use the second table again since Clarion restricts that !
#! specific operation.                                        !
#!                                                            !
#! SQL handles these type of relationships correctly and they !
#! need to be generated as an original file relationship.     !
#!------------------------------------------------------------!
#!  #OROF('ALIAS')
        #CYCLE
    #ENDCASE
#!
#INSERT(%PGModifyNameTable)                                     #! RA.2010.09.25
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%FilePrefix:%File) %NFileName [DATABASE: %ProcFileDB, SCHEMA: %ProcFileSC]
--

  #ENDIF                                                        #! RA.2008.08.13
    #SET(%TheCount, 0)
    #IF(ITEMS(%Relation))
      #FOR(%Relation)
        #SET(%NRelateSave, %Relation)                                                               #! RA.2010.09.25
        #SET(%nLoc1,INSTRING('RASQL(',%RelationUserOptions,1,1))
        #SET(%nLoc2,INSTRING(')',%RelationUserOptions,1,%nLoc1))
        #SET(%nRelationUser,UPPER(SUB(%RelationUserOptions,%nLoc1,%nLoc2)))
        #!SET(%NRelationUser,UPPER(EXTRACT(%RelationUserOptions,'RASQL')))
        #SET(%NRelationOpt1,EXTRACT(%NRelationUser,'RASQL',1))
        #SET(%NRelationOpt2,EXTRACT(%NRelationUser,'RASQL',2))
        #SET(%NRelationOpt3,EXTRACT(%NRelationUser,'RASQL',3))
        #SET(%NRelationOpt4,EXTRACT(%NRelationUser,'RASQL',4))
#!-- %FileRelationType
#!-- %NFileName  <=  %NRelateFile [ %FileType ] %AliasFile : %Relation  ==  %RelationAlias
#!-- "%NRelationUser", "%NRelationOpt1", "%NRelationOpt2", "%NRelationOpt3", "%NRelationOpt4"
        #!-----------------------------------------------------------------!
        #! The first option RASQL(NO) controls if a relation is processed. !
        #!-----------------------------------------------------------------!
        #IF(SUB(%NRelationOpt1,1,1)='N')
          #CYCLE
        #ENDIF
#!
        #!--------------------------------------------------------------------!
        #! RA.2007.10.02 - References always go from the child to the parent. !
        #!--------------------------------------------------------------------!
        #IF(%FileRelationType = 'MANY:1')
          #SET(%Relationfield1, '')
          #SET(%Relationfield2, '')
#!
#INSERT(%PGModifyNameRelTable)                                  #! RA.2010.09.25
#!
#INSERT(%PGModifyNameKey01)                                     #! RA.2010.09.25
#!
#!--
#!-- SCHEMA 1: %ProcFile [%NRelateSchema1] %NFileName (%NKeyField1)
#!-- SCHEMA 2: %Relation [%NRelateSchema2] %NRelateFile (%NKeyField2)
#!--
#!-- [%FileRelationType] %NFileName  <=  %NRelateFile [ %FileType ] %AliasFile : %Relation  ==  %RelationAlias
#!--
          #!
          #SET(%RelationField1Count, ITEMS(%FileKeyField))
          #SET(%RelationField2Count, ITEMS(%RelationKeyField))
          #!
          #SET(%NRelateCount, %RelationField1Count)
          #IF(%RelationField1Count > %RelationField2Count)     #! RA.2010.09.25
            #SET(%NRelateCount, %RelationField2Count)          #! RA.2010.09.25
          #ENDIF                                               #! RA.2010.09.25
          #SET(%NRelateComma, %NRelateCount - 1)
#!-- RelationField1Count=%RelationField1Count
#!-- RelationField2Count=%RelationField2Count
#!-- NRelateCount=%NRelateCount
          #IF(NOT %NRelateCount AND (%RelationField1Count OR %RelationField2Count))
--
-- WARNING: One of the RELATIONS has a ZERO field count in the KEY that is the relationship.
--
          #ENDIF                                               #! RA.2010.09.25
          #SET(%NRelateItem, 0)
          #FOR(%FileKeyField)
            #SET(%NRelateItem, %NRelateItem + 1)
            #IF(%NRelateItem > %NRelateCount)
              #BREAK
            #ENDIF
            #SET(%FileKeyFieldSave,%FileKeyField)               #! RA.2010.09.25
            #SET(%NRelateField1, SUB(%FileKeyField,INSTRING(':',%FileKeyField,1,1)+1,50))
            #SET(%NRelateField2, SUB(%FileKeyFieldLink,INSTRING(':',%FileKeyFieldLink,1,1)+1,50))
            #!
#INSERT(%PGModifyNameRelField1)                                 #! RA.2010.09.25
            #!
#INSERT(%PGModifyNameRelField2)                                 #! RA.2010.09.25
            #!
            #SET(%RelationField1, %RelationField1 & %NRelateField1)
            #SET(%RelationField2, %RelationField2 & %NRelateField2)
            #IF(%NRelateComma)
              #SET(%NRelateComma, %NRelateComma - 1)
              #SET(%RelationField1, %RelationField1 & ', ')
              #SET(%RelationField2, %RelationField2 & ', ')
            #ENDIF
          #ENDFOR
          #!-------------------------------------------!
          #! RA.2001.01.20 - Added this feature.       !
          #! Has syntax errors, so commented out.      !
          #!-------------------------------------------!
          #! Added to the comments so programmer is at !
          #! aware that other relationships may exist. !
          #!-------------------------------------------!
          #SET(%RelationUpdate,%RelationConstraintUpdate)       #! ON UPDATE ?
          #SET(%RelationDelete,%RelationConstraintDelete)       #! ON DELETE ?
          #!-------------------------------------------!
          #IF(%Relationfield1)
            #MESSAGE('Relation of: ' & %File,2)
            #SET(%RelCount, %RelCount + 1)
            #!----------------------------------------------------------!
            #! RA.2001.07.22 - The alias name gets changed to the real  !
            #! name to generate the SQL statement for the relationship. !
            #!----------------------------------------------------------!
            #IF(%FileType = 'ALIAS')
              #SET(%NFileName,%AliasFile)
              #FIX(%File, %AliasFile)
              #SET(%NRelateSchema2, EXTRACT(%FileUserOptions, 'SCHEMA', 2))         #! RA.2009.02.18
              #IF(%UsePrefix='All' OR %PrefixTables)                                #! RA.2008.08.11
                #SET(%NFileName,%FilePrefix & '_' & %File)
              #ENDIF
            #ENDIF
            #IF(%TheCount = 0)
#!PRINT '%NFileName'
            #ENDIF
            #!
            #SET(%TheCount,%TheCount+1)
            #SET(%NRelateSequence,%NRelateSequence+1)                               #! RA.2010.09.25
ALTER TABLE %NRelateSchema1.%NFileName
#!   ADD CONSTRAINT rel_%@N03@(%NRelateSequence)_%NKeyField
   ADD CONSTRAINT %ProcFileSC_%@N03@(%NRelateSequence)_%NKeyField
   FOREIGN KEY (%Relationfield1)
   REFERENCES %NRelateSchema2.%NRelateFile (%Relationfield2)
   #!--------------------------------------------------------!
   #! MG.2008.07.17 - Completed work on the Relationships.   !
   #! RA.2007.10.03 - Work on this - PostgreSQL supports it. !
   #!--------------------------------------------------------!
            #IF(%RelationUpdate)
              #CASE(%RelationUpdate)
              #OF('RESTRICT_SERVER')
   ON UPDATE RESTRICT
              #OF('CASCADE_SERVER')
   ON UPDATE CASCADE
              #OF('CLEAR_SERVER')
              #OROF('CLEAR')
   ON UPDATE SET NULL
              #OF('NONE')
              #OROF('NONE_SERVER')
              #ELSE
   ON UPDATE %RelationUpdate
              #ENDCASE
            #ENDIF
            #IF(%RelationDelete)
              #CASE(%RelationDelete)
              #OF('RESTRICT_SERVER')
   ON DELETE RESTRICT
              #OF('CASCADE_SERVER')
   ON DELETE CASCADE
              #OF('CLEAR_SERVER')
              #OROF('CLEAR')
   ON DELETE SET NULL
              #OF('NONE')
              #OROF('NONE_SERVER')
            #ELSE
   ON DELETE %RelationDelete
              #ENDCASE
            #ENDIF
            #IF(%SQLRelatDefer)
              #IF(SUB(%NRelationOpt3,1,1) = 'Y')
   DEFERRABLE
   INITIALLY DEFERRED
             #ENDIF
           #ENDIF
;
  #IF(%CommentsDB)                                                                                                                                              #! RA.2008.08.13
#SET(%NComment, 'Relation from table (FK) ' & %NRelateSchema1 & '.' & %NFileName & ' to table (PK) ' & %NRelateSchema2 & '.' & %NRelateFile & ' constraint.')   #! RA.2009.02.18
#SET(%NComment, QUOTE(%NComment))                                                                                                                               #! RA.2008.08.13
#! COMMENT ON CONSTRAINT rel_%@N03@(%NRelateSequence)_%NKeyField ON %NRelateSchema1.%NFileName IS
COMMENT ON CONSTRAINT %ProcFileSC_%@N03@(%NRelateSequence)_%NKeyField ON %NRelateSchema1.%NFileName IS
'%NComment'
;
  #ENDIF                                                                                                                                                        #! RA.2008.08.13

          #ENDIF
        #ENDIF
      #ENDFOR
    #ENDIF
#GROUP(%SchemaRelatEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%SchemaValid)
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)                                     #! RA.2010.09.25
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%FilePrefix:%File) %NFileName [DATABASE: %ProcFileDB, SCHEMA: %ProcFileSC]
--

  #ENDIF                                                        #! RA.2008.08.13
  #FOR(%Field)
    #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
    #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
    #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
    #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
    #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
    #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
    #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
    #!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
    #!--------------------------------------------------------------!
    #! The first option RASQL(NO) controls if a field is processed. !
    #!--------------------------------------------------------------!
    #IF(SUB(%NFieldOpt1,1,1)='N')
      #CYCLE
    #ENDIF
    #!------------------------------------------------!
    #! Begin removal of types that are not processed. !
    #!------------------------------------------------!
    #IF(%FieldType='GROUP')
      #CYCLE
    #ENDIF
    #IF(%FieldType='END')
      #CYCLE
    #ENDIF
    #!--------------------------------------------!
    #! RA.2007.10.03 - Simple name for functions. !
    #!--------------------------------------------!
    #SET(%NFieldName, %FieldID)                                     #! Field Name
    #!-------------------------------------------!
    #! RA.2010.09.25 - EXTERNAL name processing. !
    #!-------------------------------------------!
    #IF(%UseExtFieldName AND %FieldName)                                                        #! RA.2010.09.25
      #IF(%UseExtFieldQuote)                                                                    #! RA.2010.09.25 - Generate External Name w/ Quotes
        #SET(%NFieldName, %FieldName)                                                           #! RA.2010.09.25
      #ELSE                                                                                     #! RA.2010.09.25
        #SET(%NFieldName, SUB(%FieldName,2,LEN(%FieldName)-2))                                  #! RA.2010.09.25 - Remove Quotes in External Name
      #ENDIF                                                                                    #! RA.2010.09.25
    #ENDIF                                                                                      #! RA.2010.09.25
    #!-------------------------------------------!
    #!-------------------------------------------!
    #!
    #SET(%ValTypeDCT        ,UPPER(%FieldType))                     #! Original type from dictionary
    #SET(%ValType           ,'')                                    #! Validation type for backend
    #SET(%ValLength         ,%FieldMemoSize)                        #! Length in characters
    #SET(%ValNumeric        ,%FieldFormatWidth)                     #! Numer of characters in entry control
    #SET(%ValDecimal        ,%FieldPlaces)                          #! Number of decimal places
    #SET(%ValTrue           ,%FieldTrueValue)                       #! TRUE Value
    #SET(%ValFalse          ,%FieldFalseValue)                      #! FALSE Value
    #FREE(%ValList)                                                 #! INLIST values
    #!------------------------------------------------------!
    #! RA.2007.10.04 - Figure type of variable for backend. !
    #!------------------------------------------------------!
    #CASE(%ValTypeDCT)
    #OF('BLOB')                                                     #! This should not make it thru
      #SET(%ValType,'bytea')                                        #! since it is binary data
    #OF('MEMO')
      #SET(%ValType,'text')
    #OF('CSTRING')
      #SET(%ValLength,%ValLength - 1)                               #! Adjust for null terminator
    #ENDCASE
    #!=============================================================!
    #! In some cases it is more accurate to check the display mask !
    #! to determine the web type. Dates can be a LONG or a DATE    !
    #! dictionary type, and the first part of the display mask is  !
    #! going to always be a '@D.                                   !
    #!=============================================================!
    #CASE(SUB(UPPER(%FieldDisplayPicture),1,2))
    #OF('@D')
      #SET(%ValType,'date')
    #OF('@T')
      #SET(%ValType,'time without time zone')
    #OF('@S')
      #SET(%ValType,'text')
      #IF(%ValLength > 255)
        #SET(%ValType,'text')
      #ENDIF
    #OF('@N')
      #SET(%ValType,'integer')
      #IF(%ValDecimal > 0)
        #SET(%ValType,'numeric')
      #ENDIF
      #IF(%ValType = 'integer')                                     #! RA.2009.02.19
        #IF(%FieldValidation = 'BOOLEAN')                           #! RA.2009.02.19
          #SET(%ValType,'boolean')                                  #! RA.2009.02.19
        #ENDIF                                                      #! RA.2009.02.19
      #ENDIF                                                        #! RA.2009.02.19
    #ENDCASE
    #!================================!
    #!================================!
    #IF(ITEMS(%FieldValues) > 0)
      #FOR(%FieldValues)
        #CASE(%ValType)
        #OF('text')
          #ADD(%ValList,'''' & %FieldValues & '''')
        #ELSE
          #ADD(%ValList,%FieldValues)
        #ENDCASE
      #ENDFOR
    #ENDIF
    #!=================================!
    #! Description setup happens here. !
    #!=================================!
    #CASE(%FieldValidation)                                         #! PREFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
CREATE OR REPLACE FUNCTION %NRelateSchema1.%NFilePrefix_%NFieldName_description (param %ValType)
  RETURNS text AS $$
DECLARE
BEGIN
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! LOGIC
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
-- INFILE
    #OF  ('BOOLEAN')
-- BOOLEAN
  RETURN CASE(LOWER(TRIM(param)))
    WHEN 'y' THEN 'Yes'
    WHEN '1' THEN 'Yes'
    WHEN 't' THEN 'Yes'
    WHEN 'n' THEN 'No'
    WHEN '0' THEN 'No'
    WHEN 'f' THEN 'No'
    ELSE ''
  END;
    #OF  ('INRANGE')
-- INRANGE
    #OF  ('INLIST')
-- INLIST
      #CASE(%ValType)
      #OF('text')
  IF LENGTH(param) > %ValLength THEN
    RETURN '';
  END IF;
      #ENDCASE
      #LOOP,FOR(%ValI,1,ITEMS(%ValList))
        #SELECT(%FieldValues, %ValI)
        #SELECT(%FieldChoices, %ValI)
-- %FieldValues = %FieldChoices
      #ENDLOOP
      #IF(ITEMS(%ValList) > 0)
  RETURN CASE param
      #LOOP,FOR(%ValI,1,ITEMS(%ValList))
        #SELECT(%FieldValues, %ValI)
        #SELECT(%FieldChoices, %ValI)
        #CASE(%ValType)
        #OF('text')
    WHEN '%FieldValues' THEN '%FieldChoices'
        #ELSE
    WHEN %FieldValues THEN '%FieldChoices'
        #ENDCASE
      #ENDLOOP
    ELSE ''
  END;
      #ENDIF
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! POSTFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
  RETURN '';
END;
$$ LANGUAGE plpgsql
;
  #IF(%CommentsDB)                                                                                              #! RA.2008.08.13
#SET(%NComment, 'TABLE ' & %NRelateSchema1 & '.' & %NFileName & ' FIELD ' & %NFieldName & ' DESCRIPTION.')      #! RA.2009.02.19
#SET(%NComment, QUOTE(%NComment))                                                                               #! RA.2008.08.12
COMMENT ON FUNCTION %NRelateSchema1.%NFilePrefix_%NFieldName_description (param %ValType) IS
'%NComment'
;
  #ENDIF                                                                            #! RA.2008.08.13

    #ENDCASE
    #!================================!
    #! Validation setup happens here. !
    #!================================!
    #CASE(%FieldValidation)                                         #! PREFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
CREATE OR REPLACE FUNCTION %NRelateSchema1.%NFilePrefix_%NFieldName_validate (param %ValType)
  RETURNS boolean AS $$
DECLARE
BEGIN
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! LOGIC
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
-- INFILE
    #OF  ('BOOLEAN')
-- BOOLEAN
      #CASE(%ValType)
      #OF('text')
        #SET(%ValTrue, '''' & %ValTrue & '''')
        #SET(%ValFalse, '''' & %ValFalse & '''')
  IF LENGTH(param) > %ValLength THEN
    RETURN FALSE;
  END IF;
      #ENDCASE
  IF    param = %ValTrue THEN RETURN TRUE;
  ELSIF param = %ValFalse THEN RETURN TRUE;
  END IF;
    #OF  ('INRANGE')
-- INRANGE
    #OF  ('INLIST')
-- INLIST
      #CASE(%ValType)
      #OF('text')
  IF LENGTH(param) > %ValLength THEN
    RETURN FALSE;
  END IF;
      #ENDCASE
      #LOOP,FOR(%ValI,1,ITEMS(%ValList))
        #SELECT(%FieldValues, %ValI)
        #SELECT(%FieldChoices, %ValI)
-- %FieldValues = %FieldChoices
      #ENDLOOP
      #IF(ITEMS(%ValList) > 0)
  RETURN CASE param
        #FOR(%ValList)
    WHEN %ValList THEN TRUE
        #ENDFOR
    ELSE FALSE
  END;
      #ENDIF
    #ENDCASE
#!
    #CASE(%FieldValidation)                                         #! POSTFIX
    #OF  ('NONZERO')                                                #! NULL / NOT NULL
    #OF  ('INFILE')
    #OROF('BOOLEAN')
    #OROF('INRANGE')
    #OROF('INLIST')
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql
;
  #IF(%CommentsDB)                                                                                              #! RA.2008.08.13
#SET(%NComment, 'TABLE ' & %NRelateSchema1 & '.' & %NFileName & ' FIELD ' & %NFieldName & ' VALIDATION.')       #! RA.2009.02.19
#SET(%NComment, QUOTE(%NComment))                                                                               #! RA.2008.08.12
COMMENT ON FUNCTION %NRelateSchema1.%NFilePrefix_%NFieldName_validate (param %ValType) IS
'%NComment'
;
  #ENDIF                                                                            #! RA.2008.08.13

      #IF(%SQLValidCheck)
ALTER TABLE %NRelateSchema1.%NFileName ADD CONSTRAINT bad_%NFilePrefix_%NFieldName
  CHECK (%NRelateSchema1.%NFilePrefix_%NFieldName_validate(%NFieldName))
;

      #ENDIF
    #ENDCASE
  #ENDFOR
#GROUP(%SchemaValidEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%SchemaTrigr)
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)                                     #! RA.2010.09.25
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%FilePrefix:%File) %NFileName [DATABASE: %ProcFileDB, SCHEMA: %ProcFileSC]
--

  #ENDIF                                                        #! RA.2008.08.13
  #FREE(%TriggerList)                                           #! TRIGGER list
  #SET(%TriggerBefore       , 0)                                #! RA.2008.06.30
  #SET(%TriggerAfter        , 0)                                #! RA.2008.06.30
#!
  #FOR(%Field)
    #SET(%nLoc1,INSTRING('RASQL(',%FieldUserOptions,1,1))
    #SET(%nLoc2,INSTRING(')',%FieldUserOptions,1,%nLoc1))
    #SET(%nFieldUser,UPPER(SUB(%FieldUserOptions,%nLoc1,%nLoc2)))
    #!SET(%NFieldUser,UPPER(EXTRACT(%FieldUserOptions,'RASQL')))
    #SET(%NFieldOpt1,EXTRACT(%NFieldUser,'RASQL',1))
    #SET(%NFieldOpt2,EXTRACT(%NFieldUser,'RASQL',2))
    #SET(%NFieldOpt3,EXTRACT(%NFieldUser,'RASQL',3))
    #SET(%NFieldOpt4,EXTRACT(%NFieldUser,'RASQL',4))
    #!%NFieldUser, %NFieldOpt1, %NFieldOpt2, %NFieldOpt3, %NFieldOpt4
    #!--------------------------------------------------------------!
    #! The first option RASQL(NO) controls if a field is processed. !
    #!--------------------------------------------------------------!
    #IF(SUB(%NFieldOpt1,1,1)='N')
      #CYCLE
    #ENDIF
    #!------------------------------------------------!
    #! Begin removal of types that are not processed. !
    #!------------------------------------------------!
    #IF(%FieldType='GROUP')
      #CYCLE
    #ENDIF
    #IF(%FieldType='END')
      #CYCLE
    #ENDIF
    #!--------------------------------------------!
    #! RA.2007.10.03 - Simple name for functions. !
    #!--------------------------------------------!
    #SET(%NFieldName, %FieldID)                                     #! Field Name
    #!-------------------------------------------!
    #! RA.2010.09.25 - EXTERNAL name processing. !
    #!-------------------------------------------!
    #IF(%UseExtFieldName AND %FieldName)                                                        #! RA.2010.09.25
      #IF(%UseExtFieldQuote)                                                                    #! RA.2010.09.25 - Generate External Name w/ Quotes
        #SET(%NFieldName, %FieldName)                                                           #! RA.2010.09.25
      #ELSE                                                                                     #! RA.2010.09.25
        #SET(%NFieldName, SUB(%FieldName,2,LEN(%FieldName)-2))                                  #! RA.2010.09.25 - Remove Quotes in External Name
      #ENDIF                                                                                    #! RA.2010.09.25
    #ENDIF                                                                                      #! RA.2010.09.25
    #!-------------------------------------------!
    #!-------------------------------------------!
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLBEFOREINSERT'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLBEFOREINSERT',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'BEFORE')
      #SET(%TriggerOp       , 'INSERT')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerBefore   , %TriggerBefore + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLBEFOREUPDATE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLBEFOREUPDATE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'BEFORE')
      #SET(%TriggerOp       , 'UPDATE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerBefore   , %TriggerBefore + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLBEFOREDELETE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLBEFOREDELETE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'BEFORE')
      #SET(%TriggerOp       , 'DELETE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerBefore   , %TriggerBefore + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLAFTERINSERT'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLAFTERINSERT',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'AFTER')
      #SET(%TriggerOp       , 'INSERT')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerAfter    , %TriggerAfter + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLAFTERUPDATE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLAFTERUPDATE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'AFTER')
      #SET(%TriggerOp       , 'UPDATE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerAfter    , %TriggerAfter + 1)
    #ENDIF
    #!
    #SET(%NFieldUser,EXTRACT(%FieldUserOptions,'RASQLAFTERDELETE'))
    #SET(%NFieldCheck,EXTRACT(%NFieldUser,'RASQLAFTERDELETE',1))
    #IF(%NFieldCheck)
      #ADD(%TriggerList     , ITEMS(%TriggerList) + 1)
      #SET(%TriggerWhen     , 'AFTER')
      #SET(%TriggerOp       , 'DELETE')
      #SET(%TriggerStmt     , %NFieldCheck)
      #SET(%TriggerAfter    , %TriggerAfter + 1)
    #ENDIF
  #ENDFOR
#!
#!  #IF(ITEMS(%TriggerList))
#!    #FOR(%TriggerList)
#!--        == %TriggerWhen == %TriggerOp == %TriggerStmt ==
#!    #ENDFOR
#!  #ENDIF
#!
  #IF(ITEMS(%TriggerList))
CREATE OR REPLACE FUNCTION %NRelateSchema1.%NFileName_trigger()
  RETURNS "trigger"
AS $$
BEGIN

IF    (TG_WHEN = 'BEFORE') THEN
  IF    (TG_OP = 'INSERT') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'BEFORE' AND %TriggerOp = 'INSERT')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'UPDATE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'BEFORE' AND %TriggerOp = 'UPDATE')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'DELETE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'BEFORE' AND %TriggerOp = 'DELETE')
    %TriggerStmt
    #ENDFOR
  END IF;
  RETURN NEW;
ELSIF (TG_WHEN = 'AFTER') THEN
  IF    (TG_OP = 'INSERT') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'AFTER' AND %TriggerOp = 'INSERT')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'UPDATE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'AFTER' AND %TriggerOp = 'UPDATE')
    %TriggerStmt
    #ENDFOR
  ELSIF (TG_OP = 'DELETE') THEN
    #FOR(%TriggerList),WHERE(%TriggerWhen = 'AFTER' AND %TriggerOp = 'DELETE')
    %TriggerStmt
    #ENDFOR
  END IF;
  RETURN OLD;
END IF;

END $$
LANGUAGE plpgsql VOLATILE
;
    #IF(%SQLTrigrConnect)
      #IF(%TriggerBefore)
CREATE TRIGGER trigger_before_%NFileName
  BEFORE INSERT OR UPDATE OR DELETE ON %NRelateSchema1.%NFileName
  FOR EACH ROW EXECUTE PROCEDURE %NRelateSchema1.%NFileName_trigger()
;
      #ENDIF
      #IF(%TriggerAfter)
CREATE TRIGGER trigger_after_%NFileName
  AFTER INSERT OR UPDATE OR DELETE ON %NRelateSchema1.%NFileName
  FOR EACH ROW EXECUTE PROCEDURE %NRelateSchema1.%NFileName_trigger()
;
      #ENDIF
    #ENDIF

  #ENDIF
  #FREE(%TriggerList)                                               #! TRIGGER list
#GROUP(%SchemaTrigrEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%SchemaViews)
  #FIX(%File,%ProcFile)                                         #! RA.2007.11.25
  #!---------------------------------------------------------------!
  #! RA.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.  !
  #!---------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RA.2001.12.01
    #CYCLE                                                      #! RA.2001.12.01
  #ENDIF                                                        #! RA.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!
#INSERT(%PGModifyNameTable)                                     #! RA.2010.09.25
#!
  #IF(%CommentsSQL)                                             #! RA.2008.08.13
--
-- TABLE: (%FilePrefix:%File) %NFileName [DATABASE: %ProcFileDB, SCHEMA: %ProcFileSC]
--

  #ENDIF                                                        #! RA.2008.08.13
  #!------------------------------------------------------------------------!
  #! IF it IS a primary key, AND it is an integer, AND NOT auto-increment,  !
  #! AND there is one item in the key (only thing I can be sure about),     !
  #! THEN assume that it IS an auto-increment handled by the SQL backend.   !
  #!------------------------------------------------------------------------!
  #SET(%NFNameAuto,'')
  #SET(%AutoIncrementCount,0)
  #IF(ITEMS(%Key))
    #FOR(%Key)
#!---- Key        = %Key
      #IF(%KeyPrimary <> 1)
        #CYCLE
      #ENDIF
#!---- KeyPrimary = %KeyPrimary
      #IF(%KeyAuto = 1)
        #CYCLE
      #ENDIF
#!---- KeyAuto    = %KeyAuto
#!
      #IF(ITEMS(%KeyField) > 1)
        #CYCLE
      #ENDIF
#!
      #FOR(%KeyField)
#!---- KeyField   = %KeyField
        #FIX(%Field,%KeyField)
#!---- Field      = %Field
#!---- FieldType  = %FieldType
        #CASE(%FieldType)
        #OF('LONG')
          #SET(%NFNameAuto, SUB(%KeyField, INSTRING(':',%KeyField,1,1) + 1 , 50))
          #!-------------------------------------------!
          #! RA.2010.09.13 - EXTERNAL name processing. !
          #!-------------------------------------------!
          #FIX(%Field,%KeyField)                                                                #! RA.2010.09.17
          #IF(%UseExtFieldName AND %FieldName)                                                  #! RA.2010.09.13
            #IF(%UseExtFieldQuote)                                                              #! RA.2010.09.13 - Generate External Name w/ Quotes
              #SET(%NFNameAuto, %FieldName)                                                     #! RA.2010.09.13
            #ELSE                                                                               #! RA.2010.09.13
              #SET(%NFNameAuto, SUB(%FieldName,2,LEN(%FieldName)-2))                            #! RA.2010.09.13 - Remove Quotes in External Name
            #ENDIF                                                                              #! RA.2010.09.13
          #ENDIF                                                                                #! RA.2010.09.13
          #!-------------------------------------------!
          #!-------------------------------------------!
        #ENDCASE
      #ENDFOR
#!
      #IF(%NFNameAuto)
#!---- NFNameAuto = %NFNameAuto
        #SET(%AutoIncrementCount,%AutoIncrementCount + 1)
        #SET(%AutoCount, %AutoCount + 1)
#!        #SET(%NFNameAuto, SUB(%KeyAuto, INSTRING(':',%KeyAuto,1,1) + 1 , 50))
        #IF(%UsePrefix='All' OR %PrefixColumns)                                 #! RA.2008.08.11
          #SET(%NFNameAuto, %FilePrefix & '_' & %NFNameAuto)
        #ENDIF
        #!---------------------------------------------!
        #! RA.2007.10.10 - Behave according to option. !
        #!---------------------------------------------!
        #IF(NOT %IgnoreReserved)
          #SET(%SqlWordItem, UPPER(%NFNameAuto))
          #FIND(%SqlWordList, %SqlWordItem)
          #IF(%SqlWordList)
            #ADD(%ReservedFieldList, %FoundAIKeyName & %FilePrefix & ':' & %NFNameAuto)
            #SET(%NFNameAuto, %NFNameAuto & '_')
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDFOR
    #IF(%AutoIncrementCount = 0)
#!-- WARNING: %File(%FilePrefix) has no AUTO-INCREMENT KEY defined.
    #ENDIF
  #ENDIF
#!--
#!-- '%NFilePrefix' = '%NFileName' = '%NFNameAuto'
#!--
CREATE OR REPLACE VIEW %NRelateSchema1.list_%NFileName_00 AS
SELECT %NFilePrefix.*
FROM %NRelateSchema1.%NFileName AS %NFilePrefix
  #!-------------------------------------------------------------------------!
  #! RA.2011.04.09 - If there is no primary key, DO NOT output a sort order. !
  #!-------------------------------------------------------------------------!
  #IF(%NFNameAuto)
ORDER BY %NFilePrefix.%NFNameAuto
  #ENDIF
;
  #IF(%CommentsDB)                                                                              #! RA.2008.08.13
  #IF(%NFNameAuto)
#SET(%NComment, 'LIST (' & %NFilePrefix & ') ' & %FileDescription & ' ORDER BY primary id.')    #! RA.2008.08.12
    #ELSE
#SET(%NComment, 'LIST (' & %NFilePrefix & ') ' & %FileDescription & ' (NO ORDER).')             #! RA.2011.04.09
    #ENDIF
#SET(%NComment, QUOTE(%NComment))                                                               #! RA.2008.08.12
COMMENT ON VIEW %NRelateSchema1.list_%NFileName_00 IS
'%NComment'
;
  #ENDIF                                                                                        #! RA.2088.0813

#GROUP(%SchemaViewsEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#! RA.2007.10.03 - DOES NOT WORK - CAN NOT USE
#! RA.2007.10.03 - The file preprocess was the same in several places
#! So I made it into a group to make sure the code was consistant.
#! This DOES NOT work. I get ALIASES when I insert this group.
#!---------------------------------------------------------------------
#GROUP(%RAFilePreProcess)
  #!----------------------------------------------------------------!
  #! RAS.2001.12.01 - Ignore file place marker definitions.         !
  #! These are files that are defined but that contain no fields.   !
  #!----------------------------------------------------------------!
  #IF(NOT ITEMS(%Field))                                        #! RAS.2001.12.01
    #CYCLE                                                      #! RAS.2001.12.01
  #ENDIF                                                        #! RAS.2001.12.01
  #SET(%nLoc1,INSTRING('RASQL(',%FileUserOptions,1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #!SET(%NFileUser,UPPER(EXTRACT(%FileUserOptions,'RASQL')))
  #SET(%NFileOpt1,EXTRACT(%NFileUser,'RASQL',1))
  #SET(%NFileOpt2,EXTRACT(%NFileUser,'RASQL',2))
  #SET(%NFileOpt3,EXTRACT(%NFileUser,'RASQL',3))
  #SET(%NFileOpt4,EXTRACT(%NFileUser,'RASQL',4))
  #!-------------------------------------------------------------!
  #! The first option RASQL(NO) controls if a file is processed. !
  #!-------------------------------------------------------------!
  #IF(SUB(%NFileOpt1,1,1)='N')
    #CYCLE
  #ENDIF
#!
  #CASE(%FileType)
  #OF  ('VIEW')
  #OROF('ALIAS')
      #CYCLE
  #ENDCASE
#!
  #CASE(%FileDriver)
    #OF('ASCII')
  #OROF('BASIC')
  #OROF('DOS')
  #OROF('IN-MEMORY')
      #CYCLE
  #ENDCASE
#!
  #!-------------------------------------------------------------------------!
  #! RA.2007.09.20 - SQL file option to emulate auto increment (TRUE,FALSE). !
  #!-------------------------------------------------------------------------!
  #SET(%NFileOpt0,'')
  #SET(%nLoc1,INSTRING('EMULATEAUTONUMKEY(',UPPER(%FileUserOptions),1,1))
  #SET(%nLoc2,INSTRING(')',%FileUserOptions,1,%nLoc1))
  #SET(%nFileUser,UPPER(SUB(%FileUserOptions,%nLoc1,%nLoc2)))
  #SET(%NFileOpt0,EXTRACT(%NFileUser,'EMULATEAUTONUMKEY',1))
#!
  #MESSAGE('Table of: ' & %File,2)
  #SET(%NFieldPKey,UPPER(%FilePrefix) & '_PK')
#!---------------------------------------------------------------------
#GROUP(%RAFilePreProcessEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#GROUP(%Dct2PostgreSQLRobertArtigasEnd)
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
#!---------------------------------------------------------------------
